msgid ""
msgstr ""
"Project-Id-Version: Rust By Example\n"
"POT-Creation-Date: 2026-01-13T13:46:42+09:00\n"
"PO-Revision-Date: 2026-01-13 13:46+0900\n"
"Last-Translator: ehottl <deepthought@postech.ac.kr>\n"
"Language-Team: Korean <translation-team-ko@googlegroups.com>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ko\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/SUMMARY.md:1
msgid "Summary"
msgstr "요약"

#: src/SUMMARY.md:3
msgid "Introduction"
msgstr "소개"

#: src/SUMMARY.md:5 src/hello.md:1
msgid "Hello World"
msgstr "Hello World"

#: src/SUMMARY.md:6 src/hello/comment.md:1
msgid "Comments"
msgstr "주석"

#: src/SUMMARY.md:7 src/hello/print.md:1
msgid "Formatted print"
msgstr "형식화된 출력"

#: src/SUMMARY.md:8 src/hello/print/print_debug.md:1
msgid "Debug"
msgstr "디버그"

#: src/SUMMARY.md:9 src/hello/print/print_display.md:1
msgid "Display"
msgstr "디스플레이"

#: src/SUMMARY.md:10 src/hello/print/print_display/testcase_list.md:1
msgid "Testcase: List"
msgstr "테스트케이스: 리스트"

#: src/SUMMARY.md:11 src/hello/print/fmt.md:1
msgid "Formatting"
msgstr "형식화"

#: src/SUMMARY.md:13 src/primitives.md:1
msgid "Primitives"
msgstr "기본 자료형"

#: src/SUMMARY.md:14 src/primitives/literals.md:1
msgid "Literals and operators"
msgstr "리터럴과 연산자"

#: src/SUMMARY.md:15 src/primitives/tuples.md:1
msgid "Tuples"
msgstr "튜플"

#: src/SUMMARY.md:16 src/primitives/array.md:1
msgid "Arrays and Slices"
msgstr "배열과 슬라이스"

#: src/SUMMARY.md:18 src/custom_types.md:1
msgid "Custom Types"
msgstr "사용자 정의 타입"

#: src/SUMMARY.md:19 src/custom_types/structs.md:1
msgid "Structures"
msgstr "구조체"

#: src/SUMMARY.md:20 src/custom_types/enum.md:1
msgid "Enums"
msgstr "열거형"

#: src/SUMMARY.md:21 src/custom_types/enum/enum_use.md:1
msgid "use"
msgstr "use"

#: src/SUMMARY.md:22 src/custom_types/enum/c_like.md:1
msgid "C-like"
msgstr "C-like"

#: src/SUMMARY.md:23 src/custom_types/enum/testcase_linked_list.md:1
msgid "Testcase: linked-list"
msgstr "테스트케이스: 연결 리스트"

#: src/SUMMARY.md:24 src/custom_types/constants.md:1
msgid "constants"
msgstr "상수"

#: src/SUMMARY.md:26 src/variable_bindings.md:1
msgid "Variable Bindings"
msgstr "변수 바인딩"

#: src/SUMMARY.md:27 src/SUMMARY.md:120 src/SUMMARY.md:123
#: src/variable_bindings/mut.md:1 src/scope/move/mut.md:1
#: src/scope/borrow/mut.md:1
msgid "Mutability"
msgstr "가변성"

#: src/SUMMARY.md:28 src/variable_bindings/scope.md:1
msgid "Scope and Shadowing"
msgstr "스코프와 섀도잉"

#: src/SUMMARY.md:29 src/variable_bindings/declare.md:1
msgid "Declare first"
msgstr "선언 우선"

#: src/SUMMARY.md:30 src/variable_bindings/freeze.md:1
msgid "Freezing"
msgstr "동결"

#: src/SUMMARY.md:32 src/types.md:1
msgid "Types"
msgstr "타입"

#: src/SUMMARY.md:33 src/types/cast.md:1
msgid "Casting"
msgstr "형변환"

#: src/SUMMARY.md:34 src/types/literals.md:1
msgid "Literals"
msgstr "리터럴"

#: src/SUMMARY.md:35 src/types/inference.md:1
msgid "Inference"
msgstr "추론"

#: src/SUMMARY.md:36 src/SUMMARY.md:124 src/types/alias.md:1
#: src/scope/borrow/alias.md:1
msgid "Aliasing"
msgstr "별칭"

#: src/SUMMARY.md:38 src/conversion.md:1
msgid "Conversion"
msgstr "타입 변환"

#: src/SUMMARY.md:39 src/conversion/from_into.md:1
msgid "`From` and `Into`"
msgstr "`From`과 `Into`"

#: src/SUMMARY.md:40 src/conversion/try_from_try_into.md:1
msgid "`TryFrom` and `TryInto`"
msgstr "`TryFrom`과 `TryInto`"

#: src/SUMMARY.md:41
msgid "To and from `String`s"
msgstr "`String` 변환"

#: src/SUMMARY.md:43 src/expression.md:1
msgid "Expressions"
msgstr "표현식"

#: src/SUMMARY.md:45 src/flow_control.md:1
msgid "Flow of Control"
msgstr "제어 흐름"

#: src/SUMMARY.md:46 src/flow_control/if_else.md:1
msgid "if/else"
msgstr "if/else"

#: src/SUMMARY.md:47 src/flow_control/loop.md:1
msgid "loop"
msgstr "loop"

#: src/SUMMARY.md:48 src/flow_control/loop/nested.md:1
msgid "Nesting and labels"
msgstr "중첩과 레이블"

#: src/SUMMARY.md:49 src/flow_control/loop/return.md:1
msgid "Returning from loops"
msgstr "반복문에서 리턴하기"

#: src/SUMMARY.md:50 src/flow_control/while.md:1
msgid "while"
msgstr "while"

#: src/SUMMARY.md:51 src/flow_control/for.md:3
msgid "for and range"
msgstr "for와 range"

#: src/SUMMARY.md:52 src/flow_control/match.md:1
msgid "match"
msgstr "match"

#: src/SUMMARY.md:53 src/flow_control/match/destructuring.md:1
msgid "Destructuring"
msgstr "구조 분해"

#: src/SUMMARY.md:54
#: src/flow_control/match/destructuring/destructure_tuple.md:1
msgid "tuples"
msgstr "튜플"

#: src/SUMMARY.md:55
#: src/flow_control/match/destructuring/destructure_slice.md:1
msgid "arrays/slices"
msgstr "배열/슬라이스"

#: src/SUMMARY.md:56 src/flow_control/match/destructuring/destructure_enum.md:1
msgid "enums"
msgstr "열거형"

#: src/SUMMARY.md:57
#: src/flow_control/match/destructuring/destructure_pointers.md:1
msgid "pointers/ref"
msgstr "포인터/ref"

#: src/SUMMARY.md:58
#: src/flow_control/match/destructuring/destructure_structures.md:1
msgid "structs"
msgstr "구조체"

#: src/SUMMARY.md:59 src/flow_control/match/guard.md:1
msgid "Guards"
msgstr "가드"

#: src/SUMMARY.md:60 src/flow_control/match/binding.md:1
msgid "Binding"
msgstr "바인딩"

#: src/SUMMARY.md:61 src/flow_control/if_let.md:1
msgid "if let"
msgstr "if let"

#: src/SUMMARY.md:62 src/flow_control/let_else.md:1
msgid "let-else"
msgstr "let-else"

#: src/SUMMARY.md:63 src/flow_control/while_let.md:1
msgid "while let"
msgstr "while let"

#: src/SUMMARY.md:65 src/SUMMARY.md:103 src/SUMMARY.md:128 src/fn.md:1
#: src/generics/gen_fn.md:1 src/scope/lifetime/fn.md:1
msgid "Functions"
msgstr "함수"

#: src/SUMMARY.md:66 src/SUMMARY.md:129 src/scope/lifetime/methods.md:1
msgid "Methods"
msgstr "메서드"

#: src/SUMMARY.md:67 src/fn/closures.md:1
msgid "Closures"
msgstr "클로저"

#: src/SUMMARY.md:68 src/fn/closures/capture.md:1
msgid "Capturing"
msgstr "캡처"

#: src/SUMMARY.md:69 src/fn/closures/input_parameters.md:1
msgid "As input parameters"
msgstr "입력 파라미터로 사용"

#: src/SUMMARY.md:70 src/fn/closures/anonymity.md:1
msgid "Type anonymity"
msgstr "타입 익명성"

#: src/SUMMARY.md:71 src/fn/closures/input_functions.md:1
msgid "Input functions"
msgstr "입력 함수"

#: src/SUMMARY.md:72 src/fn/closures/output_parameters.md:1
msgid "As output parameters"
msgstr "출력 파라미터로 사용"

#: src/SUMMARY.md:73 src/fn/closures/closure_examples.md:1
msgid "Examples in `std`"
msgstr "`std` 예제"

#: src/SUMMARY.md:74 src/fn/closures/closure_examples/iter_any.md:1
msgid "Iterator::any"
msgstr "Iterator::any"

#: src/SUMMARY.md:75 src/fn/closures/closure_examples/iter_find.md:1
msgid "Searching through iterators"
msgstr "이터레이터 검색"

#: src/SUMMARY.md:76 src/fn/hof.md:1
msgid "Higher Order Functions"
msgstr "고차 함수"

#: src/SUMMARY.md:77 src/fn/diverging.md:1
msgid "Diverging functions"
msgstr "발산 함수"

#: src/SUMMARY.md:79 src/mod.md:1
msgid "Modules"
msgstr "모듈"

#: src/SUMMARY.md:80 src/mod/visibility.md:1
msgid "Visibility"
msgstr "가시성"

#: src/SUMMARY.md:81 src/mod/struct_visibility.md:1
msgid "Struct visibility"
msgstr "구조체 가시성"

#: src/SUMMARY.md:82 src/mod/use.md:1
msgid "The `use` declaration"
msgstr "`use` 선언"

#: src/SUMMARY.md:83 src/mod/super.md:1
msgid "`super` and `self`"
msgstr "`super`와 `self`"

#: src/SUMMARY.md:84 src/mod/split.md:1
msgid "File hierarchy"
msgstr "파일 계층 구조"

#: src/SUMMARY.md:86 src/SUMMARY.md:98 src/crates.md:1 src/attribute/crate.md:1
#: src/std_misc/arg.md:30
msgid "Crates"
msgstr "크레이트"

#: src/SUMMARY.md:87 src/crates/lib.md:1
msgid "Creating a Library"
msgstr "라이브러리 생성"

#: src/SUMMARY.md:88 src/crates/using_lib.md:1
msgid "Using a Library"
msgstr "라이브러리 사용"

#: src/SUMMARY.md:90 src/cargo.md:1
msgid "Cargo"
msgstr "카고"

#: src/SUMMARY.md:91 src/cargo/deps.md:1
msgid "Dependencies"
msgstr "의존성"

#: src/SUMMARY.md:92 src/cargo/conventions.md:1
msgid "Conventions"
msgstr "관례"

#: src/SUMMARY.md:93
msgid "Tests"
msgstr "테스트"

#: src/SUMMARY.md:94 src/cargo/build_scripts.md:1
msgid "Build Scripts"
msgstr "빌드 스크립트"

#: src/SUMMARY.md:96 src/attribute.md:1
msgid "Attributes"
msgstr "속성"

#: src/SUMMARY.md:97 src/attribute/unused.md:1
msgid "`dead_code`"
msgstr "`dead_code`"

#: src/SUMMARY.md:99 src/attribute/cfg.md:1
msgid "`cfg`"
msgstr "`cfg`"

#: src/SUMMARY.md:100 src/attribute/cfg/custom.md:1
msgid "Custom"
msgstr "사용자 정의"

#: src/SUMMARY.md:102 src/generics.md:1
msgid "Generics"
msgstr "제네릭"

#: src/SUMMARY.md:104 src/generics/impl.md:1
msgid "Implementation"
msgstr "구현"

#: src/SUMMARY.md:105 src/SUMMARY.md:131 src/SUMMARY.md:137
#: src/generics/gen_trait.md:1 src/scope/lifetime/trait.md:1 src/trait.md:1
msgid "Traits"
msgstr "트레이트"

#: src/SUMMARY.md:106 src/SUMMARY.md:132 src/generics/bounds.md:1
#: src/scope/lifetime/lifetime_bounds.md:1
msgid "Bounds"
msgstr "바운드"

#: src/SUMMARY.md:107 src/generics/bounds/testcase_empty.md:1
msgid "Testcase: empty bounds"
msgstr "테스트케이스: 빈 바운드"

#: src/SUMMARY.md:108 src/generics/multi_bounds.md:1
msgid "Multiple bounds"
msgstr "다중 바운드"

#: src/SUMMARY.md:109 src/generics/where.md:1
msgid "Where clauses"
msgstr "Where 절"

#: src/SUMMARY.md:110 src/generics/new_types.md:1
msgid "New Type Idiom"
msgstr "New Type 관용구"

#: src/SUMMARY.md:111 src/generics/assoc_items.md:1
msgid "Associated items"
msgstr "연관 아이템"

#: src/SUMMARY.md:112 src/generics/assoc_items/the_problem.md:1
msgid "The Problem"
msgstr "문제점"

#: src/SUMMARY.md:113 src/generics/assoc_items/types.md:1
msgid "Associated types"
msgstr "연관 타입"

#: src/SUMMARY.md:114 src/generics/phantom.md:1
msgid "Phantom type parameters"
msgstr "팬텀 타입 파라미터"

#: src/SUMMARY.md:115 src/generics/phantom/testcase_units.md:1
msgid "Testcase: unit clarification"
msgstr "테스트케이스: 단위 명확화"

#: src/SUMMARY.md:117 src/scope.md:1
msgid "Scoping rules"
msgstr "스코프 규칙"

#: src/SUMMARY.md:118 src/scope/raii.md:1
msgid "RAII"
msgstr "RAII"

#: src/SUMMARY.md:119 src/scope/move.md:1
msgid "Ownership and moves"
msgstr "소유권과 이동"

#: src/SUMMARY.md:121 src/scope/move/partial_move.md:1
msgid "Partial moves"
msgstr "부분 이동"

#: src/SUMMARY.md:122 src/scope/borrow.md:1
msgid "Borrowing"
msgstr "빌림"

#: src/SUMMARY.md:125 src/scope/borrow/ref.md:1
msgid "The ref pattern"
msgstr "ref 패턴"

#: src/SUMMARY.md:126 src/scope/lifetime.md:1
msgid "Lifetimes"
msgstr "라이프타임"

#: src/SUMMARY.md:127 src/scope/lifetime/explicit.md:1
msgid "Explicit annotation"
msgstr "명시적 어노테이션"

#: src/SUMMARY.md:130 src/scope/lifetime/struct.md:1
msgid "Structs"
msgstr "구조체"

#: src/SUMMARY.md:133 src/scope/lifetime/lifetime_coercion.md:1
msgid "Coercion"
msgstr "강제"

#: src/SUMMARY.md:134 src/scope/lifetime/static_lifetime.md:1
msgid "Static"
msgstr "Static"

#: src/SUMMARY.md:135 src/scope/lifetime/elision.md:1
msgid "Elision"
msgstr "생략"

#: src/SUMMARY.md:138 src/trait/derive.md:1
msgid "Derive"
msgstr "Derive"

#: src/SUMMARY.md:139 src/trait/dyn.md:1
msgid "Returning Traits with `dyn`"
msgstr "`dyn`으로 트레이트 반환하기"

#: src/SUMMARY.md:140 src/trait/ops.md:1
msgid "Operator Overloading"
msgstr "연산자 오버로딩"

#: src/SUMMARY.md:141 src/trait/drop.md:1
msgid "Drop"
msgstr "Drop"

#: src/SUMMARY.md:142 src/trait/iter.md:1
msgid "Iterators"
msgstr "이터레이터"

#: src/SUMMARY.md:143 src/trait/impl_trait.md:1
msgid "`impl Trait`"
msgstr "`impl Trait`"

#: src/SUMMARY.md:144 src/trait/clone.md:1
msgid "Clone"
msgstr "Clone"

#: src/SUMMARY.md:145 src/trait/supertraits.md:1
msgid "Supertraits"
msgstr "슈퍼트레이트"

#: src/SUMMARY.md:146 src/trait/disambiguating.md:1
msgid "Disambiguating overlapping traits"
msgstr "중복 트레이트 명확화"

#: src/SUMMARY.md:148
msgid "macro_rules!"
msgstr "macro_rules!"

#: src/SUMMARY.md:149 src/macros/syntax.md:1
msgid "Syntax"
msgstr "문법"

#: src/SUMMARY.md:150 src/macros/designators.md:1
msgid "Designators"
msgstr "지시자"

#: src/SUMMARY.md:151 src/macros/overload.md:1
msgid "Overload"
msgstr "오버로드"

#: src/SUMMARY.md:152 src/macros/repeat.md:1
msgid "Repeat"
msgstr "반복"

#: src/SUMMARY.md:153 src/macros/dry.md:1
msgid "DRY (Don't Repeat Yourself)"
msgstr "DRY (반복하지 말라)"

#: src/SUMMARY.md:154
msgid "DSL (Domain Specific Languages)"
msgstr "DSL (도메인 특화 언어)"

#: src/SUMMARY.md:155
msgid "Variadics"
msgstr "가변 인자"

#: src/SUMMARY.md:157 src/error.md:1
msgid "Error handling"
msgstr "에러 핸들링"

#: src/SUMMARY.md:158 src/error/panic.md:1
msgid "`panic`"
msgstr "`panic`"

#: src/SUMMARY.md:159
msgid "`abort` & `unwind`"
msgstr "`abort`와 `unwind`"

#: src/SUMMARY.md:160 src/error/option_unwrap.md:1
msgid "`Option` & `unwrap`"
msgstr "`Option`과 `unwrap`"

#: src/SUMMARY.md:161 src/error/option_unwrap/question_mark.md:1
msgid "Unpacking options with `?`"
msgstr "`?`로 옵션 풀기"

#: src/SUMMARY.md:162 src/error/option_unwrap/map.md:1
msgid "Combinators: `map`"
msgstr "콤비네이터: `map`"

#: src/SUMMARY.md:163 src/error/option_unwrap/and_then.md:1
msgid "Combinators: `and_then`"
msgstr "콤비네이터: `and_then`"

#: src/SUMMARY.md:164
msgid "Defaults: `or`, `or_else`, `get_or_insert`, `get_or_insert_with`"
msgstr "기본값: `or`, `or_else`, `get_or_insert`, `get_or_insert_with`"

#: src/SUMMARY.md:165 src/SUMMARY.md:183 src/error/result.md:1
#: src/std/result.md:1
msgid "`Result`"
msgstr "`Result`"

#: src/SUMMARY.md:166 src/error/result/result_map.md:1
msgid "`map` for `Result`"
msgstr "`Result`에서의 `map`"

#: src/SUMMARY.md:167 src/error/result/result_alias.md:1
msgid "aliases for `Result`"
msgstr "`Result`의 별칭"

#: src/SUMMARY.md:168 src/error/result/early_returns.md:1
msgid "Early returns"
msgstr "조기 리턴"

#: src/SUMMARY.md:169 src/error/result/enter_question_mark.md:1
msgid "Introducing `?`"
msgstr "`?` 소개"

#: src/SUMMARY.md:170 src/error/multiple_error_types.md:1
msgid "Multiple error types"
msgstr "여러 에러 타입"

#: src/SUMMARY.md:171 src/error/multiple_error_types/option_result.md:1
msgid "Pulling `Result`s out of `Option`s"
msgstr "`Option`에서 `Result` 꺼내기"

#: src/SUMMARY.md:172 src/error/multiple_error_types/define_error_type.md:1
msgid "Defining an error type"
msgstr "에러 타입 정의하기"

#: src/SUMMARY.md:173 src/error/multiple_error_types/boxing_errors.md:1
msgid "`Box`ing errors"
msgstr "에러 `Box`하기"

#: src/SUMMARY.md:174 src/error/multiple_error_types/reenter_question_mark.md:1
msgid "Other uses of `?`"
msgstr "`?`의 다른 용도"

#: src/SUMMARY.md:175 src/error/multiple_error_types/wrap_error.md:1
msgid "Wrapping errors"
msgstr "에러 감싸기"

#: src/SUMMARY.md:176 src/error/iter_result.md:1
msgid "Iterating over `Result`s"
msgstr "`Result` 반복하기"

#: src/SUMMARY.md:178 src/std.md:1
msgid "Std library types"
msgstr "표준 라이브러리 타입"

#: src/SUMMARY.md:179 src/std/box.md:1
msgid "Box, stack and heap"
msgstr "Box, 스택과 힙"

#: src/SUMMARY.md:180 src/std/vec.md:1
msgid "Vectors"
msgstr "벡터"

#: src/SUMMARY.md:181 src/std/str.md:1
msgid "Strings"
msgstr "문자열"

#: src/SUMMARY.md:182 src/std/option.md:1
msgid "`Option`"
msgstr "`Option`"

#: src/SUMMARY.md:184 src/std/result/question_mark.md:1
msgid "`?`"
msgstr "`?`"

#: src/SUMMARY.md:185 src/std/panic.md:1
msgid "`panic!`"
msgstr "`panic!`"

#: src/SUMMARY.md:186 src/std/hash.md:1
msgid "HashMap"
msgstr "해시맵"

#: src/SUMMARY.md:187 src/std/hash/alt_key_types.md:1
msgid "Alternate/custom key types"
msgstr "대체/사용자 정의 키 타입"

#: src/SUMMARY.md:188 src/std/hash/hashset.md:1
msgid "HashSet"
msgstr "해시셋"

#: src/SUMMARY.md:189 src/std/rc.md:1
msgid "`Rc`"
msgstr "`Rc`"

#: src/SUMMARY.md:190
msgid "`Arc`"
msgstr "`Arc`"

#: src/SUMMARY.md:192 src/std_misc.md:1
msgid "Std misc"
msgstr "기타 표준 라이브러리"

#: src/SUMMARY.md:193 src/std_misc.md:6 src/std_misc/threads.md:1
msgid "Threads"
msgstr "스레드"

#: src/SUMMARY.md:194 src/std_misc/threads/testcase_mapreduce.md:1
msgid "Testcase: map-reduce"
msgstr "테스트케이스: 맵-리듀스"

#: src/SUMMARY.md:195 src/std_misc.md:7 src/std_misc/channels.md:1
msgid "Channels"
msgstr "채널"

#: src/SUMMARY.md:196 src/std_misc/path.md:1
msgid "Path"
msgstr "경로"

#: src/SUMMARY.md:197 src/std_misc.md:8 src/std_misc/file.md:1
msgid "File I/O"
msgstr "파일 입출력"

#: src/SUMMARY.md:198 src/std_misc/file/open.md:1
msgid "`open`"
msgstr "`open`"

#: src/SUMMARY.md:199 src/std_misc/file/create.md:1
msgid "`create`"
msgstr "`create`"

#: src/SUMMARY.md:200 src/std_misc/file/read_lines.md:1
msgid "`read_lines`"
msgstr "`read_lines`"

#: src/SUMMARY.md:201 src/std_misc/process.md:1
msgid "Child processes"
msgstr "자식 프로세스"

#: src/SUMMARY.md:202 src/std_misc/process/pipe.md:1
msgid "Pipes"
msgstr "파이프"

#: src/SUMMARY.md:203 src/std_misc/process/wait.md:1
msgid "Wait"
msgstr "대기"

#: src/SUMMARY.md:204 src/std_misc/fs.md:1
msgid "Filesystem Operations"
msgstr "파일시스템 연산"

#: src/SUMMARY.md:205 src/std_misc/arg.md:1
msgid "Program arguments"
msgstr "프로그램 인자"

#: src/SUMMARY.md:206 src/std_misc/arg/matching.md:1
msgid "Argument parsing"
msgstr "인자 파싱"

#: src/SUMMARY.md:207 src/std_misc/ffi.md:1
msgid "Foreign Function Interface"
msgstr "외부 함수 인터페이스"

#: src/SUMMARY.md:209 src/cargo/test.md:1 src/testing.md:1
msgid "Testing"
msgstr "테스트"

#: src/SUMMARY.md:210 src/testing/unit_testing.md:1
msgid "Unit testing"
msgstr "유닛 테스트"

#: src/SUMMARY.md:211 src/testing/doc_testing.md:1
msgid "Documentation testing"
msgstr "문서 테스트"

#: src/SUMMARY.md:212 src/testing/integration_testing.md:1
msgid "Integration testing"
msgstr "통합 테스트"

#: src/SUMMARY.md:213
msgid "Dev-dependencies"
msgstr "개발 의존성"

#: src/SUMMARY.md:215 src/unsafe.md:1
msgid "Unsafe Operations"
msgstr "Unsafe 연산"

#: src/SUMMARY.md:216 src/unsafe/asm.md:1
msgid "Inline assembly"
msgstr "인라인 어셈블리"

#: src/SUMMARY.md:218 src/compatibility.md:1
msgid "Compatibility"
msgstr "호환성"

#: src/SUMMARY.md:219 src/compatibility/raw_identifiers.md:1
msgid "Raw identifiers"
msgstr "Raw 식별자"

#: src/SUMMARY.md:221 src/meta.md:1
msgid "Meta"
msgstr "메타"

#: src/SUMMARY.md:222 src/meta/doc.md:1
msgid "Documentation"
msgstr "문서화"

#: src/SUMMARY.md:223 src/meta/playground.md:1
msgid "Playground"
msgstr "플레이그라운드"

#: src/index.md:1
msgid "Rust by Example"
msgstr "Rust by Example"

#: src/index.md:3
msgid ""
"[Rust](https://www.rust-lang.org/) is a modern systems programming language "
"focusing on safety, speed, and concurrency. It accomplishes these goals by "
"being memory safe without using garbage collection."
msgstr ""
"[Rust](https://www.rust-lang.org/)는 안전성, 속도, 동시성에 중점을 둔 현대적인 시스템 프로그래밍 언어입니다. 가비지 컬렉션을 사용하지 않고도 메모리 안전성을 확보하여 이러한 목표를 달성합니다."

#: src/index.md:7
msgid ""
"Rust by Example (RBE) is a collection of runnable examples that illustrate "
"various Rust concepts and standard libraries. To get even more out of these "
"examples, don't forget to [install Rust locally](https://www.rust-lang.org/"
"tools/install) and check out the [official docs](https://doc.rust-lang.org/"
"std/). Additionally for the curious, you can also [check out the source code "
"for this site](https://github.com/rust-lang/rust-by-example)."
msgstr ""
"Rust by Example (RBE)는 다양한 Rust 개념과 표준 라이브러리를 보여주는 실행 가능한 예제 모음입니다. 이러한 예제를 더 잘 활용하려면 [Rust를 로컬에 설치](https://www.rust-lang.org/tools/install)하고 [공식 문서](https://doc.rust-lang.org/std/)를 확인해 보세요. 또한 궁금하신 분들은 [이 사이트의 소스 코드](https://github.com/rust-lang/rust-by-example)도 확인하실 수 있습니다."

#: src/index.md:12
msgid "Now let's begin!"
msgstr "자, 이제 시작해 봅시다!"

#: src/index.md:14
msgid "[Hello World](hello.md) - Start with a traditional Hello World program."
msgstr "[Hello World](hello.md) - 전통적인 Hello World 프로그램으로 시작합니다."

#: src/index.md:16
msgid ""
"[Primitives](primitives.md) - Learn about signed integers, unsigned integers "
"and other primitives."
msgstr "[기본 자료형](primitives.md) - 부호 있는 정수, 부호 없는 정수 및 기타 기본 자료형에 대해 배웁니다."

#: src/index.md:18
msgid "[Custom Types](custom_types.md) - `struct` and `enum`."
msgstr "[사용자 정의 타입](custom_types.md) - `struct`와 `enum`."

#: src/index.md:20
msgid ""
"[Variable Bindings](variable_bindings.md) - mutable bindings, scope, "
"shadowing."
msgstr "[변수 바인딩](variable_bindings.md) - 가변 바인딩, 스코프, 섀도잉."

#: src/index.md:22
msgid "[Types](types.md) - Learn about changing and defining types."
msgstr "[타입](types.md) - 타입을 변경하고 정의하는 법을 배웁니다."

#: src/index.md:24
msgid ""
"[Conversion](conversion.md) - Convert between different types, such as "
"strings, integers, and floats."
msgstr "[타입 변환](conversion.md) - 문자열, 정수, 부동 소수점 등 서로 다른 타입 간의 변환에 대해 배웁니다."

#: src/index.md:26
msgid ""
"[Expressions](expression.md) - Learn about Expressions & how to use them."
msgstr "[표현식](expression.md) - 표현식과 그 사용법에 대해 배웁니다."

#: src/index.md:28
msgid "[Flow of Control](flow_control.md) - `if`/`else`, `for`, and others."
msgstr "[제어 흐름](flow_control.md) - `if`/`else`, `for` 등을 배웁니다."

#: src/index.md:30
msgid ""
"[Functions](fn.md) - Learn about Methods, Closures and Higher Order "
"Functions."
msgstr "[함수](fn.md) - 메서드, 클로저, 고차 함수에 대해 배웁니다."

#: src/index.md:32
msgid "[Modules](mod.md) - Organize code using modules"
msgstr "[모듈](mod.md) - 모듈을 사용하여 코드를 구성합니다."

#: src/index.md:34
msgid ""
"[Crates](crates.md) - A crate is a compilation unit in Rust. Learn to create "
"a library."
msgstr "[크레이트](crates.md) - 크레이트는 Rust의 컴파일 단위입니다. 라이브러리를 만드는 법을 배웁니다."

#: src/index.md:36
msgid ""
"[Cargo](cargo.md) - Go through some basic features of the official Rust "
"package management tool."
msgstr "[Cargo](cargo.md) - Rust 공식 패키지 관리 도구의 기본적인 기능을 살펴봅니다."

#: src/index.md:38
msgid ""
"[Attributes](attribute.md) - An attribute is metadata applied to some "
"module, crate or item."
msgstr "[속성](attribute.md) - 속성은 모듈, 크레이트 또는 아이템에 적용되는 메타데이터입니다."

#: src/index.md:40
msgid ""
"[Generics](generics.md) - Learn about writing a function or data type which "
"can work for multiple types of arguments."
msgstr "[제네릭](generics.md) - 다양한 타입의 인자에 대해 작동할 수 있는 함수나 데이터 타입을 작성하는 법을 배웁니다."

#: src/index.md:42
msgid ""
"[Scoping rules](scope.md) - Scopes play an important part in ownership, "
"borrowing, and lifetimes."
msgstr "[스코프 규칙](scope.md) - 스코프는 소유권, 빌림, 라이프타임에서 중요한 역할을 합니다."

#: src/index.md:44
msgid ""
"[Traits](trait.md) - A trait is a collection of methods defined for an "
"unknown type: `Self`"
msgstr "[트레이트](trait.md) - 트레이트는 알 수 없는 타입 `Self`에 대해 정의된 메서드 모음입니다."

#: src/index.md:46
msgid ""
"[Macros](macros.md) - Macros are a way of writing code that writes other "
"code, which is known as metaprogramming."
msgstr "[매크로](macros.md) - 매크로는 다른 코드를 작성하는 코드를 작성하는 방법으로, 메타프로그래밍이라고도 합니다."

#: src/index.md:48
msgid "[Error handling](error.md) - Learn Rust way of handling failures."
msgstr "[에러 핸들링](error.md) - 실패를 처리하는 Rust의 방식을 배웁니다."

#: src/index.md:50
msgid ""
"[Std library types](std.md) - Learn about some custom types provided by "
"`std` library."
msgstr "[표준 라이브러리 타입](std.md) - `std` 라이브러리에서 제공하는 몇 가지 사용자 정의 타입에 대해 배웁니다."

#: src/index.md:52
msgid "[Std misc](std_misc.md) - More custom types for file handling, threads."
msgstr "[기타 표준 라이브러리](std_misc.md) - 파일 처리, 스레드 등을 위한 추가적인 사용자 정의 타입을 배웁니다."

#: src/index.md:54
msgid "[Testing](testing.md) - All sorts of testing in Rust."
msgstr "[테스트](testing.md) - Rust에서의 다양한 테스트 방식을 배웁니다."

#: src/index.md:56
msgid ""
"[Unsafe Operations](unsafe.md) - Learn about entering a block of unsafe "
"operations."
msgstr "[Unsafe 연산](unsafe.md) - Unsafe 연산 블록에 진입하는 법을 배웁니다."

#: src/index.md:58
msgid ""
"[Compatibility](compatibility.md) - Handling Rust's evolution and potential "
"compatibility issues."
msgstr "[호환성](compatibility.md) - Rust의 발전과 잠재적인 호환성 문제를 처리하는 법을 배웁니다."

#: src/index.md:60
msgid "[Meta](meta.md) - Documentation, Benchmarking."
msgstr "[메타](meta.md) - 문서화, 벤치마킹."

#: src/hello.md:3
msgid "This is the source code of the traditional Hello World program."
msgstr "전통적인 Hello World 프로그램의 소스 코드입니다."

#: src/hello.md:6
msgid ""
"// This is a comment, and is ignored by the compiler.\n"
"// You can test this code by clicking the \"Run\" button over there ->\n"
"// or if you prefer to use your keyboard, you can use the \"Ctrl + Enter\"\n"
"// shortcut.\n"
msgstr ""
"// 이것은 주석이며, 컴파일러에 의해 무시됩니다.\n"
"// 오른쪽에 있는 \"Run\" 버튼을 클릭하거나,\n"
"// 키보드를 사용하고 싶다면 \"Ctrl + Enter\" 단축키를 사용하여\n"
"// 이 코드를 테스트해 볼 수 있습니다.\n"

#: src/hello.md:10
msgid ""
"// This code is editable, feel free to hack it!\n"
"// You can always return to the original code by clicking the \"Reset\" "
"button ->\n"
msgstr ""
"// 이 코드는 수정 가능하므로, 자유롭게 고쳐보세요!\n"
"// \"Reset\" 버튼을 클릭하면 언제든지 원래 코드로 되돌릴 수 있습니다 ->\n"

#: src/hello.md:13
msgid "// This is the main function.\n"
msgstr "// 메인 함수입니다.\n"

#: src/hello.md:16
msgid "// Statements here are executed when the compiled binary is called.\n"
msgstr "// 여기에 있는 문장들은 컴파일된 바이너리가 호출될 때 실행됩니다.\n"

#: src/hello.md:18
msgid "// Print text to the console.\n"
msgstr "// 콘솔에 텍스트를 출력합니다.\n"

#: src/hello.md:19 src/error/result.md:55 src/meta/playground.md:12
msgid "\"Hello World!\""
msgstr "\"Hello World!\""

#: src/hello.md:23
msgid "`println!` is a [_macro_](macros.md) that prints text to the console."
msgstr "`println!`은 콘솔에 텍스트를 출력하는 [_매크로_](macros.md)입니다."

#: src/hello.md:26
msgid "A binary can be generated using the Rust compiler: `rustc`."
msgstr "Rust 컴파일러인 `rustc`를 사용하여 바이너리를 생성할 수 있습니다."

#: src/hello.md:32
msgid "`rustc` will produce a `hello` binary that can be executed."
msgstr "`rustc`는 실행 가능한 `hello` 바이너리를 생성합니다."

#: src/hello.md:39 src/hello/print/print_display.md:107
#: src/hello/print/print_display/testcase_list.md:53 src/hello/print/fmt.md:70
#: src/primitives/tuples.md:64 src/custom_types/structs.md:89
msgid "Activity"
msgstr "실습"

#: src/hello.md:41
msgid ""
"Click 'Run' above to see the expected output. Next, add a new line with a "
"second `println!` macro so that the output shows:"
msgstr "위의 'Run'을 클릭하여 예상 출력을 확인하세요. 그런 다음, 두 번째 `println!` 매크로를 사용하여 다음과 같은 출력이 나오도록 새로운 라인을 추가하세요."

#: src/hello/comment.md:3
msgid ""
"Any program requires comments, and Rust supports a few different varieties:"
msgstr "어떤 프로그램이든 주석이 필요하며, Rust는 몇 가지 다른 종류를 지원합니다."

#: src/hello/comment.md:6
msgid "Regular Comments"
msgstr "일반 주석"

#: src/hello/comment.md:8
msgid "These are ignored by the compiler:"
msgstr "이것들은 컴파일러에 의해 무시됩니다:"

#: src/hello/comment.md:10
msgid "**Line comments**: Start with `//` and continue to the end of the line"
msgstr "**라인 주석**: `//`로 시작하여 줄의 끝까지 이어집니다."

#: src/hello/comment.md:11
msgid "**Block comments**: Enclosed in `/* ... */` and can span multiple lines"
msgstr "**블록 주석**: `/* ... */`로 감싸여 여러 줄에 걸쳐 있을 수 있습니다."

#: src/hello/comment.md:13
msgid ""
"Documentation Comments (Doc Comments) which are parsed into HTML library "
"[documentation](../meta/doc.md):"
msgstr ""
"HTML 라이브러리 [문서](../meta/doc.md)로 파싱되는 문서화 주석 (Doc Comments):"

#: src/hello/comment.md:15
msgid "`///` - Generates docs for the item that follows it"
msgstr "`///` - 다음에 오는 아이템에 대한 문서를 생성합니다."

#: src/hello/comment.md:16
msgid ""
"`//!` - Generates docs for the enclosing item (typically used at the top of "
"a file or module)"
msgstr ""
"`//!` - 해당 아이템을 포함하는 아이템(주로 파일이나 모듈의 상단에서 사용됨)에 대한 문서를 생성합니다."

#: src/hello/comment.md:20
msgid ""
"// Line comments start with two slashes.\n"
"    // Everything after the slashes is ignored by the compiler.\n"
msgstr ""
"// 라인 주석은 두 개의 슬래시로 시작합니다.\n"
"    // 슬래시 이후의 모든 내용은 컴파일러에 의해 무시됩니다.\n"

#: src/hello/comment.md:23
msgid ""
"// Example: This line won't execute\n"
"    // println!(\"Hello, world!\");\n"
msgstr ""
"// 예시: 이 줄은 실행되지 않습니다\n"
"    // println!(\"Hello, world!\");\n"

#: src/hello/comment.md:26
msgid "// Try removing the slashes above and running the code again.\n"
msgstr "// 위의 슬래시를 제거하고 코드를 다시 실행해 보세요.\n"

#: src/hello/comment.md:28
msgid ""
"/*\n"
"     * Block comments are useful for temporarily disabling code.\n"
"     * They can also be nested: /* like this */ which makes it easy\n"
"     * to comment out large sections quickly.\n"
"     */"
msgstr ""
"/*\n"
"     * 블록 주석은 코드를 일시적으로 비활성화하는 데 유용합니다.\n"
"     * 블록 주석은 중첩될 수도 있습니다: /* 이와 같이 */ 중첩이 가능하여\n"
"     * 큰 섹션을 빠르게 주석 처리하기 쉽습니다.\n"
"     */"

#: src/hello/comment.md:34
msgid ""
"/*\n"
"    Note: The asterisk column on the left is just for style - \n"
"    it's not required by the language.\n"
"    */"
msgstr ""
"/*\n"
"    참고: 왼쪽의 별표 기둥은 단지 스타일을 위한 것입니다 - \n"
"    언어적으로 요구되는 사항은 아닙니다.\n"
"    */"

#: src/hello/comment.md:39
msgid ""
"// Block comments make it easy to toggle code on/off by adding\n"
"    // or removing just one slash:\n"
msgstr ""
"// 블록 주석은 슬래시 하나를 추가하거나 제거하여\n"
"    // 코드를 켜고 끄기 쉽게 만들어 줍니다:\n"

#: src/hello/comment.md:42
msgid ""
"/* <- Add a '/' here to uncomment the entire block below\n"
"\n"
"    println!(\"Now\");\n"
"    println!(\"everything\");\n"
"    println!(\"executes!\");\n"
"    // Line comments inside remain unaffected\n"
"\n"
"    // */"
msgstr ""
"/* <- 여기에 '/'를 추가하면 아래 블록 전체의 주석이 해제됩니다\n"
"\n"
"    println!(\"이제\");\n"
"    println!(\"모든 것이\");\n"
"    println!(\"실행됩니다!\");\n"
"    // 내부의 라인 주석은 영향을 받지 않습니다\n"
"\n"
"    // */"

#: src/hello/comment.md:51
msgid "// Block comments can also be used within expressions:\n"
msgstr "// 블록 주석은 표현식 내에서도 사용될 수 있습니다:\n"

#: src/hello/comment.md:52
msgid "/* 90 + */"
msgstr "/* 90 + */"

#: src/hello/comment.md:53
msgid "\"Is `x` 10 or 100? x = {}\""
msgstr "\"`x`는 10인가요 100인가요? x = {}\""

#: src/hello/comment.md:57 src/hello/print.md:103
#: src/hello/print/print_debug.md:75 src/hello/print/print_display.md:128
#: src/hello/print/print_display/testcase_list.md:62 src/hello/print/fmt.md:94
#: src/primitives.md:64 src/custom_types/enum.md:100
#: src/custom_types/enum/enum_use.md:45 src/custom_types/enum/c_like.md:33
#: src/custom_types/enum/testcase_linked_list.md:78
#: src/custom_types/constants.md:35 src/types/alias.md:30
#: src/flow_control/for.md:121 src/flow_control/match/destructuring.md:17
#: src/flow_control/match/destructuring/destructure_tuple.md:25
#: src/flow_control/match/destructuring/destructure_slice.md:46
#: src/flow_control/match/destructuring/destructure_enum.md:48
#: src/flow_control/match/destructuring/destructure_pointers.md:63
#: src/flow_control/match/destructuring/destructure_structures.md:45
#: src/flow_control/match/guard.md:43 src/flow_control/match/binding.md:63
#: src/flow_control/if_let.md:118 src/flow_control/let_else.md:55
#: src/flow_control/while_let.md:56 src/fn/closures/capture.md:110
#: src/fn/closures/input_parameters.md:84 src/fn/closures/anonymity.md:47
#: src/fn/closures/input_functions.md:32
#: src/fn/closures/output_parameters.md:49
#: src/fn/closures/closure_examples/iter_any.md:51
#: src/fn/closures/closure_examples/iter_find.md:71
#: src/mod/struct_visibility.md:53 src/attribute/cfg.md:39 src/generics.md:59
#: src/generics/gen_fn.md:54 src/generics/impl.md:48
#: src/generics/gen_trait.md:39 src/generics/bounds.md:73
#: src/generics/bounds/testcase_empty.md:37 src/generics/multi_bounds.md:32
#: src/generics/where.md:49 src/generics/new_types.md:54
#: src/generics/assoc_items.md:10 src/generics/assoc_items/the_problem.md:62
#: src/generics/phantom.md:56 src/generics/phantom/testcase_units.md:75
#: src/scope/raii.md:92 src/scope/move/partial_move.md:57
#: src/scope/borrow/mut.md:56 src/scope/lifetime/explicit.md:68
#: src/scope/lifetime/fn.md:58 src/scope/lifetime/methods.md:24
#: src/scope/lifetime/struct.md:41 src/scope/lifetime/trait.md:28
#: src/scope/lifetime/lifetime_bounds.md:46
#: src/scope/lifetime/static_lifetime.md:133 src/scope/lifetime/elision.md:39
#: src/trait/derive.md:65 src/trait/supertraits.md:40
#: src/trait/disambiguating.md:60 src/error/option_unwrap/map.md:79
#: src/error/option_unwrap/and_then.md:73
#: src/error/option_unwrap/defaults.md:115 src/error/result/result_alias.md:41
#: src/error/multiple_error_types/boxing_errors.md:57
#: src/error/multiple_error_types/reenter_question_mark.md:74
#: src/error/multiple_error_types/wrap_error.md:91 src/std.md:12
#: src/std/rc.md:55 src/std_misc.md:12
#: src/std_misc/threads/testcase_mapreduce.md:127 src/std_misc/path.md:52
#: src/std_misc/fs.md:149 src/meta/doc.md:109 src/meta/playground.md:49
msgid "See also:"
msgstr "참고:"

#: src/hello/comment.md:59
msgid "[Library documentation](../meta/doc.md)"
msgstr "[라이브러리 문서](../meta/doc.md)"

#: src/hello/print.md:3
msgid ""
"Printing is handled by a series of [`macros`](../macros.md) defined in "
"[`std::fmt`](https://doc.rust-lang.org/std/fmt/) some of which are:"
msgstr ""
"출력은 [`std::fmt`](https://doc.rust-lang.org/std/fmt/)에 정의된 일련의 [`매크로`](../macros.md)들에 의해 처리되며, 그 중 몇 가지는 다음과 같습니다:"

#: src/hello/print.md:6
msgid "`format!`: write formatted text to [`String`](../std/str.md)"
msgstr "`format!`: 형식화된 텍스트를 [`String`](../std/str.md)에 씁니다."

#: src/hello/print.md:7
msgid ""
"`print!`: same as `format!` but the text is printed to the console "
"(io::stdout)."
msgstr ""
"`print!`: `format!`과 같지만 텍스트가 콘솔(io::stdout)에 출력됩니다."

#: src/hello/print.md:9
msgid "`println!`: same as `print!` but a newline is appended."
msgstr "`println!`: `print!`와 같지만 줄바꿈 문자가 추가됩니다."

#: src/hello/print.md:10
msgid ""
"`eprint!`: same as `print!` but the text is printed to the standard error "
"(io::stderr)."
msgstr ""
"`eprint!`: `print!`와 같지만 텍스트가 표준 에러(io::stderr)로 출력됩니다."

#: src/hello/print.md:12
msgid "`eprintln!`: same as `eprint!` but a newline is appended."
msgstr "`eprintln!`: `eprint!`와 같지만 줄바꿈 문자가 추가됩니다."

#: src/hello/print.md:14
msgid ""
"All parse text in the same fashion. As a plus, Rust checks formatting "
"correctness at compile time."
msgstr ""
"모두 같은 방식으로 텍스트를 파싱합니다. 추가로, Rust는 컴파일 타임에 형식화의 올바름을 검사합니다."

#: src/hello/print.md:19
msgid ""
"// In general, the `{}` will be automatically replaced with any\n"
"    // arguments. These will be stringified.\n"
msgstr ""
"// 일반적으로 `{}`는 어떤 인자로든 자동으로 교체됩니다.\n"
"    // 이들은 문자열화될 것입니다.\n"

#: src/hello/print.md:21
msgid "\"{} days\""
msgstr "\"{}일\""

#: src/hello/print.md:23
msgid ""
"// Positional arguments can be used. Specifying an integer inside `{}`\n"
"    // determines which additional argument will be replaced. Arguments "
"start\n"
"    // at 0 immediately after the format string.\n"
msgstr ""
"// 위치 인자를 사용할 수 있습니다. `{}` 안에 정수를 지정하면\n"
"    // 어떤 추가 인자가 교체될지 결정합니다. 인자는 형식 문자열\n"
"    // 바로 뒤에서 0부터 시작합니다.\n"

#: src/hello/print.md:26
msgid "\"{0}, this is {1}. {1}, this is {0}\""
msgstr "\"{0}, 여기는 {1}입니다. {1}, 여기는 {0}입니다.\""

#: src/hello/print.md:26 src/scope/move/partial_move.md:31
msgid "\"Alice\""
msgstr "\"앨리스\""

#: src/hello/print.md:26 src/flow_control/for.md:65 src/flow_control/for.md:85
#: src/flow_control/for.md:104
msgid "\"Bob\""
msgstr "\"밥\""

#: src/hello/print.md:28
msgid "// As can named arguments.\n"
msgstr "// 이름을 지정한 인자(named arguments)도 사용할 수 있습니다.\n"

#: src/hello/print.md:29
msgid "\"{subject} {verb} {object}\""
msgstr "\"{subject} {verb} {object}\""

#: src/hello/print.md:30
msgid "\"the lazy dog\""
msgstr "\"게으른 개\""

#: src/hello/print.md:31
msgid "\"the quick brown fox\""
msgstr "\"빠른 갈색 여우\""

#: src/hello/print.md:32
msgid "\"jumps over\""
msgstr "\"넘어 뛰어넘다\""

#: src/hello/print.md:34
msgid ""
"// Different formatting can be invoked by specifying the format character\n"
"    // after a `:`.\n"
msgstr ""
"// `:` 뒤에 형식 문자를 지정하여 다양한 형식화를 수행할 수 있습니다.\n"

#: src/hello/print.md:36
msgid "\"Base 10:               {}\""
msgstr "\"10진수:               {}\""

#: src/hello/print.md:36
msgid "// 69420\n"
msgstr "// 69420\n"

#: src/hello/print.md:37
msgid "\"Base 2 (binary):       {:b}\""
msgstr "\"2진수:                {:b}\""

#: src/hello/print.md:37
msgid "// 10000111100101100\n"
msgstr "// 10000111100101100\n"

#: src/hello/print.md:38
msgid "\"Base 8 (octal):        {:o}\""
msgstr "\"8진수:                {:o}\""

#: src/hello/print.md:38
msgid "// 207454\n"
msgstr "// 207454\n"

#: src/hello/print.md:39
msgid "\"Base 16 (hexadecimal): {:x}\""
msgstr "\"16진수:               {:x}\""

#: src/hello/print.md:39
msgid "// 10f2c\n"
msgstr "// 10f2c\n"

#: src/hello/print.md:41
msgid ""
"// You can right-justify text with a specified width. This will\n"
"    // output \"    1\". (Four white spaces and a \"1\", for a total width "
"of 5.)\n"
msgstr ""
"// 지정된 너비로 텍스트를 오른쪽 정렬할 수 있습니다. 이 예시는\n"
"    // \"    1\"을 출력할 것입니다. (공백 4개와 \"1\" 하나로 총 너비 5가 됩니다.)\n"

#: src/hello/print.md:43
msgid "\"{number:>5}\""
msgstr "\"{number:>5}\""

#: src/hello/print.md:45
msgid "// You can pad numbers with extra zeroes,\n"
msgstr "// 숫자를 0으로 채울 수도 있습니다,\n"

#: src/hello/print.md:46
msgid "\"{number:0>5}\""
msgstr "\"{number:0>5}\""

#: src/hello/print.md:46
msgid ""
"// 00001\n"
"    // and left-adjust by flipping the sign. This will output \"10000\".\n"
msgstr ""
"// 00001\n"
"    // 그리고 부호를 뒤집어 왼쪽 정렬할 수 있습니다. 이것은 \"10000\"을 출력합니다.\n"

#: src/hello/print.md:48
msgid "\"{number:0<5}\""
msgstr "\"{number:0<5}\""

#: src/hello/print.md:48
msgid "// 10000\n"
msgstr "// 10000\n"

#: src/hello/print.md:50
msgid ""
"// You can use named arguments in the format specifier by appending a `$`.\n"
msgstr "// 형식 지정자(format specifier)에 `$`를 붙여 명명된 인자를 사용할 수 있습니다.\n"

#: src/hello/print.md:51
msgid "\"{number:0>width$}\""
msgstr "\"{number:0>width$}\""

#: src/hello/print.md:53
msgid ""
"// Rust even checks to make sure the correct number of arguments are used.\n"
msgstr "// Rust는 올바른 개수의 인자가 사용되었는지도 확인합니다.\n"

#: src/hello/print.md:54
msgid "\"My name is {0}, {1} {0}\""
msgstr "\"제 이름은 {0}, {1} {0}입니다.\""

#: src/hello/print.md:54
msgid "\"Bond\""
msgstr "\"본드\""

#: src/hello/print.md:55
msgid "// FIXME ^ Add the missing argument: \"James\"\n"
msgstr "// FIXME ^ 누락된 인자를 추가하세요: \"제임스\"\n"

#: src/hello/print.md:57
msgid ""
"// Only types that implement fmt::Display can be formatted with `{}`. User-\n"
"    // defined types do not implement fmt::Display by default.\n"
msgstr ""
"// fmt::Display를 구현하는 타입만 `{}`로 형식화할 수 있습니다. 사용자\n"
"    // 정의 타입은 기본적으로 fmt::Display를 구현하지 않습니다.\n"

#: src/hello/print.md:60
msgid "// disable `dead_code` which warn against unused module\n"
msgstr "// 사용되지 않는 모듈에 대한 경고인 `dead_code`를 비활성화합니다\n"

#: src/hello/print.md:63
msgid ""
"// This will not compile because `Structure` does not implement\n"
"    // fmt::Display.\n"
"    // println!(\"This struct `{}` won't print...\", Structure(3));\n"
"    // TODO ^ Try uncommenting this line\n"
msgstr ""
"// `Structure`가 fmt::Display를 구현하지 않으므로 컴파일되지 않습니다.\n"
"    // println!(\"이 구조체 `{}`는 출력되지 않습니다...\", Structure(3));\n"
"    // TODO ^ 이 줄의 주석을 해제해 보세요\n"

#: src/hello/print.md:68
msgid ""
"// For Rust 1.58 and above, you can directly capture the argument from a\n"
"    // surrounding variable. Just like the above, this will output\n"
"    // \"    1\", 4 white spaces and a \"1\".\n"
msgstr ""
"// Rust 1.58 이상에서는 주변 변수에서 직접 인자를 캡처할 수 있습니다.\n"
"    // 위와 마찬가지로, 이것은 \"    1\"(공백 4개와 \"1\")을 출력합니다.\n"

#: src/hello/print.md:73
msgid "\"{number:>width$}\""
msgstr "\"{number:>width$}\""

#: src/hello/print.md:77
msgid ""
"[`std::fmt`](https://doc.rust-lang.org/std/fmt/) contains many [`traits`]"
"(https://doc.rust-lang.org/std/fmt/#formatting-traits) which govern the "
"display of text. The base form of two important ones are listed below:"
msgstr ""
"[`std::fmt`](https://doc.rust-lang.org/std/fmt/)에는 텍스트 표시를 제어하는 많은 [`트레이트`](https://doc.rust-lang.org/std/fmt/#formatting-traits)가 포함되어 있습니다. 그 중 중요한 두 가지의 기본 형태는 다음과 같습니다:"

#: src/hello/print.md:80
msgid ""
"`fmt::Debug`: Uses the `{:?}` marker. Format text for debugging purposes."
msgstr "`fmt::Debug`: `{:?}` 마커를 사용합니다. 디버깅 목적으로 텍스트 형식을 지정합니다."

#: src/hello/print.md:81
msgid ""
"`fmt::Display`: Uses the `{}` marker. Format text in a more elegant, user "
"friendly fashion."
msgstr "`fmt::Display`: `{}` 마커를 사용합니다. 보다 우아하고 사용자 친화적인 방식으로 텍스트 형식을 지정합니다."

#: src/hello/print.md:84
msgid ""
"Here, we used `fmt::Display` because the std library provides "
""
msgstr ""
"여기서는 표준 라이브러리가 이러한 타입들에 대한 구현을 제공하기 때문에 `fmt::Display`를 사용했습니다. 커스텀 타입에 대해 텍스트를 출력하려면 더 많은 단계가 필요합니다."
implementations for these types. To print text for custom types, more steps "
"are required."
msgstr ""

#: src/hello/print.md:87
msgid ""
"Implementing the `fmt::Display` trait automatically implements the "
"[`ToString`](https://doc.rust-lang.org/std/string/trait.ToString.html) trait "
"which allows us to [convert](../conversion/string.md) the type to [`String`]"
"(../std/str.md)."
msgstr ""

#: src/hello/print.md:90
msgid ""
"In _line 43_, `#[allow(dead_code)]` is an [attribute](../attribute.md) which "
"only applies to the module after it."
msgstr ""

#: src/hello/print.md:92
msgid "Activities"
msgstr ""

#: src/hello/print.md:94
msgid ""
"Fix the issue in the above code (see FIXME) so that it runs without error."
msgstr ""

#: src/hello/print.md:96
msgid ""
"Try uncommenting the line that attempts to format the `Structure` struct "
"(see TODO)"
msgstr ""

#: src/hello/print.md:98
msgid ""
"Add a `println!` macro call that prints: `Pi is roughly 3.142` by "
"controlling the number of decimal places shown. For the purposes of this "
"exercise, use `let pi = 3.141592` as an estimate for pi. (Hint: you may need "
"to check the [`std::fmt`](https://doc.rust-lang.org/std/fmt/) documentation "
"for setting the number of decimals to display)"
msgstr ""

#: src/hello/print.md:105
msgid ""
"[`std::fmt`](https://doc.rust-lang.org/std/fmt/), [`macros`](../macros.md), "
"[`struct`](../custom_types/structs.md), [`traits`](https://doc.rust-lang.org/"
"std/fmt/#formatting-traits), and [`dead_code`](../attribute/unused.md)"
msgstr ""

#: src/hello/print/print_debug.md:3
msgid ""
"All types which want to use `std::fmt` formatting `traits` require an "
"implementation to be printable. Automatic implementations are only provided "
"for types such as in the `std` library. All others _must_ be manually "
"implemented somehow."
msgstr ""

#: src/hello/print/print_debug.md:8
msgid ""
"The `fmt::Debug` `trait` makes this very straightforward. _All_ types can "
"`derive` (automatically create) the `fmt::Debug` implementation. This is not "
"true for `fmt::Display` which must be manually implemented."
msgstr ""

#: src/hello/print/print_debug.md:13
msgid ""
"// This structure cannot be printed either with `fmt::Display` or\n"
"// with `fmt::Debug`.\n"
msgstr ""

#: src/hello/print/print_debug.md:16
msgid ""
"// The `derive` attribute automatically creates the implementation\n"
"// required to make this `struct` printable with `fmt::Debug`.\n"
msgstr ""

#: src/hello/print/print_debug.md:23
msgid "All `std` library types are automatically printable with `{:?}` too:"
msgstr ""

#: src/hello/print/print_debug.md:26
msgid ""
"// Derive the `fmt::Debug` implementation for `Structure`. `Structure`\n"
"// is a structure which contains a single `i32`.\n"
msgstr ""

#: src/hello/print/print_debug.md:30
msgid ""
"// Put a `Structure` inside of the structure `Deep`. Make it printable\n"
"// also.\n"
msgstr ""
"// `Deep` 구조체 안에 `Structure`를 넣으세요. 그리고 역시 출력 가능하게 만드세요.\n"

#: src/hello/print/print_debug.md:37
msgid "// Printing with `{:?}` is similar to with `{}`.\n"
msgstr "// `{:?}`를 이용한 출력은 `{}`와 유사합니다.\n"

#: src/hello/print/print_debug.md:38
msgid "\"{:?} months in a year.\""
msgstr "\"1년은 {:?}개월입니다.\""

#: src/hello/print/print_debug.md:39
msgid "\"{1:?} {0:?} is the {actor:?} name.\""
msgstr "\"{1:?} {0:?}은 {actor:?}의 이름입니다.\""

#: src/hello/print/print_debug.md:40
msgid "\"Slater\""
msgstr "\"슬레이터\""

#: src/hello/print/print_debug.md:41
msgid "\"Christian\""
msgstr "\"크리스찬\""

#: src/hello/print/print_debug.md:42
msgid "\"actor's\""
msgstr "\"배우의\""

#: src/hello/print/print_debug.md:44
msgid "// `Structure` is printable!\n"
msgstr "// `Structure`는 출력 가능합니다!\n"

#: src/hello/print/print_debug.md:45 src/hello/print/print_debug.md:49
msgid "\"Now {:?} will print!\""
msgstr "\"이제 {:?}가 출력될 것입니다!\""

#: src/hello/print/print_debug.md:47
msgid ""
"// The problem with `derive` is there is no control over how\n"
"    // the results look. What if I want this to just show a `7`?\n"
msgstr ""
"// `derive`의 문제점은 결과가 어떻게 보일지 제어할 수 없다는 것입니다.\n"
"    // 만약 이것을 단지 `7`로 보여주고 싶다면 어떡하죠?\n"

#: src/hello/print/print_debug.md:53
msgid ""
"So `fmt::Debug` definitely makes this printable but sacrifices some "
"elegance. Rust also provides \"pretty printing\" with `{:#?}`."
msgstr ""
"따라서 `fmt::Debug`는 확실히 출력을 가능하게 하지만 우아함을 어느 정도 희생합니다. Rust는 `{:#?}`를 사용한 \"예쁘게 출력하기(pretty printing)\"도 제공합니다."

#: src/hello/print/print_debug.md:64 src/custom_types/structs.md:42
msgid "\"Peter\""
msgstr "\"피터\""

#: src/hello/print/print_debug.md:68
msgid "// Pretty print\n"
msgstr "// 예쁘게 출력하기\n"

#: src/hello/print/print_debug.md:69
msgid "\"{:#?}\""
msgstr "\"{:#?}\""

#: src/hello/print/print_debug.md:73
msgid "One can manually implement `fmt::Display` to control the display."
msgstr "`fmt::Display`를 수동으로 구현하여 출력을 제어할 수 있습니다."

#: src/hello/print/print_debug.md:77
msgid ""
"[`attributes`](https://doc.rust-lang.org/reference/attributes.html), "
"[`derive`](../../trait/derive.md), [`std::fmt`](https://doc.rust-lang.org/"
"std/fmt/), and [`struct`](../../custom_types/structs.md)"
msgstr ""
"[`속성`](https://doc.rust-lang.org/reference/attributes.html), [`derive`](../../trait/derive.md), [`std::fmt`](https://doc.rust-lang.org/std/fmt/), 그리고 [`구조체`](../../custom_types/structs.md)"

#: src/hello/print/print_display.md:3
msgid ""
"`fmt::Debug` hardly looks compact and clean, so it is often advantageous to "
"customize the output appearance. This is done by manually implementing "
"[`fmt::Display`](https://doc.rust-lang.org/std/fmt/), which uses the `{}` "
"print marker. Implementing it looks like this:"
msgstr ""
"`fmt::Debug`는 콤팩트하고 깔끔해 보이지 않으므로, 출력 모양을 커스터마이징하는 것이 종종 유리합니다. 이는 `{}` 출력 마커를 사용하는 [`fmt::Display`](https://doc.rust-lang.org/std/fmt/)를 수동으로 구현함으로써 수행됩니다. 구현은 다음과 같습니다:"

#: src/hello/print/print_display.md:9
msgid "// Import (via `use`) the `fmt` module to make it available.\n"
msgstr "// `fmt` 모듈을 (`use`를 통해) 가져와서 사용할 수 있게 합니다.\n"

#: src/hello/print/print_display.md:11
msgid ""
"// Define a structure for which `fmt::Display` will be implemented. This is\n"
"// a tuple struct named `Structure` that contains an `i32`.\n"
msgstr ""
"// `fmt::Display`를 구현할 구조체를 정의합니다. 이것은\n"
"// `i32`를 포함하는 `Structure`라는 이름의 튜플 구조체입니다.\n"

#: src/hello/print/print_display.md:15
msgid ""
"// To use the `{}` marker, the trait `fmt::Display` must be implemented\n"
"// manually for the type.\n"
msgstr ""
"// `{}` 마커를 사용하려면, `fmt::Display` 트레이트가 해당 타입에 대해\n"
"// 수동으로 구현되어야 합니다.\n"

#: src/hello/print/print_display.md:19
msgid "// This trait requires `fmt` with this exact signature.\n"
msgstr "// 이 트레이트는 정확히 이 시그니처를 가진 `fmt`를 요구합니다.\n"

#: src/hello/print/print_display.md:21
msgid ""
"// Write strictly the first element into the supplied output\n"
"        // stream: `f`. Returns `fmt::Result` which indicates whether the\n"
"        // operation succeeded or failed. Note that `write!` uses syntax "
"which\n"
"        // is very similar to `println!`.\n"
msgstr ""
"// 제공된 출력 스트림 `f`에 첫 번째 요소를 씁니다.\n"
"        // 작업의 성공 또는 실패 여부를 나타내는 `fmt::Result`를 반환합니다.\n"
"        // `write!`는 `println!`과 매우 유사한 구문을 사용한다는 점에 유의하세요.\n"

#: src/hello/print/print_display.md:25
#: src/hello/print/print_display/testcase_list.md:13
#: src/hello/print/print_display/testcase_list.md:39
#: src/hello/print/print_display/testcase_list.md:49 src/hello/print/fmt.md:53
#: src/custom_types/enum/testcase_linked_list.md:74 src/conversion/string.md:25
#: src/flow_control/loop.md:26 src/flow_control/while.md:21
#: src/flow_control/for.md:23 src/flow_control/for.md:43 src/fn.md:40
#: src/fn/closures/capture.md:96 src/fn/closures/capture.md:97
#: src/fn/closures/anonymity.md:41 src/generics/bounds.md:12
#: src/macros/repeat.md:24 src/macros/repeat.md:25 src/macros/repeat.md:26
#: src/error/result.md:73 src/std/str.md:92 src/std/str.md:102
#: src/std/str.md:106 src/std/str.md:111 src/std/result.md:72
#: src/std/result/question_mark.md:57 src/std/result/question_mark.md:65
#: src/std_misc/file/read_lines.md:60 src/std_misc/arg/matching.md:9
#: src/std_misc/arg/matching.md:13
msgid "\"{}\""
msgstr "\"{}\""

#: src/hello/print/print_display.md:30
msgid ""
"`fmt::Display` may be cleaner than `fmt::Debug` but this presents a problem "
"for the `std` library. How should ambiguous types be displayed? For example, "
"if the `std` library implemented a single style for all `Vec<T>`, what style "
"should it be? Would it be either of these two?"
msgstr ""
"`fmt::Display`가 `fmt::Debug`보다 깔끔할 수 있지만, 이는 `std` 라이브러리에 문제를 제기합니다. 모호한 타입들은 어떻게 표시되어야 할까요? 예를 들어, `std` 라이브러리가 모든 `Vec<T>`에 대해 단일 스타일을 구현했다면, 어떤 스타일이어야 할까요? 다음 두 가지 중 하나일까요?"

#: src/hello/print/print_display.md:35
msgid "`Vec<path>`: `/:/etc:/home/username:/bin` (split on `:`)"
msgstr "`Vec<path>`: `/:/etc:/home/username:/bin` (`:`로 구분)"

#: src/hello/print/print_display.md:36
msgid "`Vec<number>`: `1,2,3` (split on `,`)"
msgstr "`Vec<number>`: `1,2,3` (`,`로 구분)"

#: src/hello/print/print_display.md:38
msgid ""
"No, because there is no ideal style for all types and the `std` library "
"doesn't presume to dictate one. `fmt::Display` is not implemented for "
"`Vec<T>` or for any other generic containers. `fmt::Debug` must then be used "
"for these generic cases."
msgstr ""
"아니요, 모든 타입에 이상적인 스타일은 없으며 `std` 라이브러리가 하나를 독단적으로 정하지 않기 때문입니다. `fmt::Display`는 `Vec<T>`나 다른 제네릭 컨테이너에 대해 구현되어 있지 않습니다. 따라서 이러한 제네릭 케이스에는 `fmt::Debug`를 사용해야 합니다."

#: src/hello/print/print_display.md:43
msgid ""
"This is not a problem though because for any new _container_ type which is "
"_not_ generic, `fmt::Display` can be implemented."
msgstr ""
"하지만 제네릭이 _아닌_ 새로운 _컨테이너_ 타입에 대해서는 `fmt::Display`를 구현할 수 있으므로 이는 문제가 되지 않습니다."

#: src/hello/print/print_display.md:47
msgid "// Import `fmt`\n"
msgstr "// `fmt` 가져오기\n"

#: src/hello/print/print_display.md:48
msgid ""
"// A structure holding two numbers. `Debug` will be derived so the results "
"can\n"
"// be contrasted with `Display`.\n"
msgstr ""
"// 두 숫자를 보유하는 구조체입니다. `Display`와 대조해 볼 수 있도록\n"
"// `Debug`를 유도(derive)할 것입니다.\n"

#: src/hello/print/print_display.md:53
msgid "// Implement `Display` for `MinMax`.\n"
msgstr "// `MinMax`에 대해 `Display`를 구현합니다.\n"

#: src/hello/print/print_display.md:57
msgid "// Use `self.number` to refer to each positional data point.\n"
msgstr "// 각 위치별 데이터 지점을 참조하기 위해 `self.number`를 사용합니다.\n"

#: src/hello/print/print_display.md:58
msgid "\"({}, {})\""
msgstr "\"({}, {})\""

#: src/hello/print/print_display.md:61
msgid "// Define a structure where the fields are nameable for comparison.\n"
msgstr "// 비교를 위해 필드에 이름을 붙일 수 있는 구조체를 정의합니다.\n"

#: src/hello/print/print_display.md:68
msgid "// Similarly, implement `Display` for `Point2D`.\n"
msgstr "// 마찬가지로, `Point2D`에 대해 `Display`를 구현합니다.\n"

#: src/hello/print/print_display.md:72
msgid "// Customize so only `x` and `y` are denoted.\n"
msgstr "// `x`와 `y`만 표시되도록 커스터마이징합니다.\n"

#: src/hello/print/print_display.md:73
msgid "\"x: {}, y: {}\""
msgstr "\"x: {}, y: {}\""

#: src/hello/print/print_display.md:80
msgid "\"Compare structures:\""
msgstr "\"구조체 비교:\""

#: src/hello/print/print_display.md:81 src/hello/print/print_display.md:94
msgid "\"Display: {}\""
msgstr "\"디스플레이: {}\""

#: src/hello/print/print_display.md:82 src/hello/print/print_display.md:95
msgid "\"Debug: {:?}\""
msgstr "\"디버그: {:?}\""

#: src/hello/print/print_display.md:87
msgid "\"The big range is {big} and the small is {small}\""
msgstr "\"큰 범위는 {big}이고 작은 범위는 {small}입니다.\""

#: src/hello/print/print_display.md:93
msgid "\"Compare points:\""
msgstr "\"좌표 비교:\""

#: src/hello/print/print_display.md:97
msgid ""
"// Error. Both `Debug` and `Display` were implemented, but `{:b}`\n"
"    // requires `fmt::Binary` to be implemented. This will not work.\n"
"    // println!(\"What does Point2D look like in binary: {:b}?\", point);\n"
msgstr ""
"// 에러. `Debug`와 `Display`는 모두 구현되었지만, `{:b}`는\n"
"    // `fmt::Binary` 구현을 요구합니다. 이것은 작동하지 않을 것입니다.\n"
"    // println!(\"Point2D의 2진수 형태는 무엇일까요: {:b}?\", point);\n"

#: src/hello/print/print_display.md:103
msgid ""
"So, `fmt::Display` has been implemented but `fmt::Binary` has not, and "
"therefore cannot be used. `std::fmt` has many such [`traits`](https://"
"doc.rust-lang.org/std/fmt/#formatting-traits) and each requires its own "
"implementation. This is detailed further in [`std::fmt`](https://doc.rust-"
"lang.org/std/fmt/)."
msgstr ""
"따라서, `fmt::Display`는 구현되었지만 `fmt::Binary`는 구현되지 않았으므로 사용할 수 없습니다. `std::fmt`에는 이와 같은 많은 [`트레이트`](https://doc.rust-lang.org/std/fmt/#formatting-traits)가 있으며 각각은 자체적인 구현을 요구합니다. 이에 대한 자세한 내용은 [`std::fmt`](https://doc.rust-lang.org/std/fmt/)에 나와 있습니다."

#: src/hello/print/print_display.md:109
msgid ""
"After checking the output of the above example, use the `Point2D` struct as "
"a guide to add a `Complex` struct to the example. When printed in the same "
"way, the output should be:"
msgstr ""
"위 예제의 출력을 확인한 후, `Point2D` 구조체를 가이드로 삼아 예제에 `Complex` 구조체를 추가해 보세요. 같은 방식으로 출력했을 때의 결과는 다음과 같아야 합니다:"

#: src/hello/print/print_display.md:121
msgid "Bonus: Add a space before the `+`/`-` signs."
msgstr "보너스: `+`/`-` 기호 앞에 공백을 추가하세요."

#: src/hello/print/print_display.md:123
msgid "Hints in case you get stuck:"
msgstr "막혔을 때를 위한 힌트:"

#: src/hello/print/print_display.md:125
msgid ""
"Check the documentation for [`Sign/#/0`](https://doc.rust-lang.org/std/fmt/"
"#sign0) in `std::fmt`."
msgstr ""
"`std::fmt`에서 [`Sign/#/0`](https://doc.rust-lang.org/std/fmt/#sign0)에 대한 문서를 확인하세요."

#: src/hello/print/print_display.md:126
msgid ""
"Bonus: Check [`if`\\-`else`](../../flow_control/if_else.md) branching and "
"the [`abs`](https://doc.rust-lang.org/std/primitive.f64.html#method.abs) "
"function."
msgstr ""
"보너스: [`if`\\-`else`](../../flow_control/if_else.md) 분기와 [`abs`](https://doc.rust-lang.org/std/primitive.f64.html#method.abs) 함수를 확인하세요."

#: src/hello/print/print_display.md:130
msgid ""
"[`derive`](../../trait/derive.md), [`std::fmt`](https://doc.rust-lang.org/"
"std/fmt/), [`macros`](../../macros.md), [`struct`](../../custom_types/"
"structs.md), [`trait`](https://doc.rust-lang.org/std/fmt/#formatting-"
"traits), and [`use`](../../mod/use.md)"
msgstr ""
"[`derive`](../../trait/derive.md), [`std::fmt`](https://doc.rust-lang.org/std/fmt/), [`매크로`](../../macros.md), [`구조체`](../../custom_types/structs.md), [`트레이트`](https://doc.rust-lang.org/std/fmt/#formatting-traits), 그리고 [`use`](../../mod/use.md)"

#: src/hello/print/print_display/testcase_list.md:3
msgid ""
"Implementing `fmt::Display` for a structure where the elements must each be "
"handled sequentially is tricky. The problem is that each `write!` generates "
"a `fmt::Result`. Proper handling of this requires dealing with _all_ the "
"results. Rust provides the `?` operator for exactly this purpose."
msgstr ""
"각 요소를 순차적으로 처리해야 하는 구조체에 대해 `fmt::Display`를 구현하는 것은 까다롭습니다. 문제는 각 `write!`가 `fmt::Result`를 생성한다는 것입니다. 이를 적절히 처리하려면 _모든_ 결과를 다뤄야 합니다. Rust는 정확히 이 목적을 위해 `?` 연산자를 제공합니다."

#: src/hello/print/print_display/testcase_list.md:8
msgid "Using `?` on `write!` looks like this:"
msgstr "`write!`에 `?`를 사용하는 것은 다음과 같습니다:"

#: src/hello/print/print_display/testcase_list.md:11
msgid ""
"// Try `write!` to see if it errors. If it errors, return\n"
"// the error. Otherwise continue.\n"
msgstr ""
"// `write!`가 에러를 발생시키는지 확인합니다. 에러가 발생하면\n"
"// 에러를 반환합니다. 그렇지 않으면 계속 진행합니다.\n"

#: src/hello/print/print_display/testcase_list.md:16
msgid ""
"With `?` available, implementing `fmt::Display` for a `Vec` is "
"straightforward:"
msgstr "`?`가 사용 가능해지면 `Vec`에 대한 `fmt::Display` 구현은 간단해집니다:"

#: src/hello/print/print_display/testcase_list.md:20
msgid "// Import the `fmt` module.\n"
msgstr "// `fmt` 모듈을 가져옵니다.\n"

#: src/hello/print/print_display/testcase_list.md:21
msgid "// Define a structure named `List` containing a `Vec`.\n"
msgstr "// `Vec`을 포함하는 `List`라는 이름의 구조체를 정의합니다.\n"

#: src/hello/print/print_display/testcase_list.md:27
msgid ""
"// Extract the value using tuple indexing,\n"
"        // and create a reference to `vec`.\n"
msgstr ""
"// 튜플 인덱싱을 사용하여 값을 추출하고,\n"
"        // `vec`에 대한 참조를 생성합니다.\n"

#: src/hello/print/print_display/testcase_list.md:31
msgid "\"[\""
msgstr "\"[\""

#: src/hello/print/print_display/testcase_list.md:33
msgid ""
"// Iterate over `v` in `vec` while enumerating the iteration\n"
"        // index in `index`.\n"
msgstr "// `vec`의 `v`를 순회하면서 반복 인덱스를 `index`에 열거합니다.\n"

#: src/hello/print/print_display/testcase_list.md:36
msgid ""
"// For every element except the first, add a comma.\n"
"            // Use the ? operator to return on errors.\n"
msgstr ""
"// 첫 번째를 제외한 모든 요소에 콤마를 추가합니다.\n"
"            // 에러 시 반환하기 위해 ? 연산자를 사용합니다.\n"

#: src/hello/print/print_display/testcase_list.md:38 src/std/str.md:36
msgid "\", \""
msgstr "\", \""

#: src/hello/print/print_display/testcase_list.md:42
msgid "// Close the opened bracket and return a fmt::Result value.\n"
msgstr "// 열려 있는 대괄호를 닫고 `fmt::Result` 값을 반환합니다.\n"

#: src/hello/print/print_display/testcase_list.md:43
msgid "\"]\""
msgstr "\"]\""

#: src/hello/print/print_display/testcase_list.md:55
msgid ""
"Try changing the program so that the index of each element in the vector is "
"also printed. The new output should look like this:"
msgstr "벡터의 각 요소의 인덱스도 출력되도록 프로그램을 변경해 보세요. 새로운 출력은 다음과 같아야 합니다:"

#: src/hello/print/print_display/testcase_list.md:64
msgid ""
"[`for`](../../../flow_control/for.md), [`ref`](../../../scope/borrow/"
"ref.md), [`Result`](../../../std/result.md), [`struct`](../../../"
"custom_types/structs.md), [`?`](../../../std/result/question_mark.md), and "
"[`vec!`](../../../std/vec.md)"
msgstr ""
"[`for`](../../../flow_control/for.md), [`ref`](../../../scope/borrow/ref.md), [`Result`](../../../std/result.md), [`구조체`](../../../custom_types/structs.md), [`?`](../../../std/result/question_mark.md), 그리고 [`vec!`](../../../std/vec.md)"

#: src/hello/print/fmt.md:3
msgid "We've seen that formatting is specified via a _format string_:"
msgstr "형식화는 _형식 문자열_을 통해 지정되는 것을 보았습니다:"

#: src/hello/print/fmt.md:5
msgid "`format!(\"{}\", foo)` -> `\"3735928559\"`"
msgstr "`format!(\"{}\", foo)` -> `\"3735928559\"`"

#: src/hello/print/fmt.md:6
msgid ""
"`format!(\"0x{:X}\", foo)` -> [`\"0xDEADBEEF\"`](https://en.wikipedia.org/"
"wiki/Deadbeef#Magic_debug_values)"
msgstr "`format!(\"0x{:X}\", foo)` -> [`\"0xDEADBEEF\"`](https://en.wikipedia.org/wiki/Deadbeef#Magic_debug_values)"

#: src/hello/print/fmt.md:7
msgid "`format!(\"0o{:o}\", foo)` -> `\"0o33653337357\"`"
msgstr "`format!(\"0o{:o}\", foo)` -> `\"0o33653337357\"`"

#: src/hello/print/fmt.md:9
msgid ""
"The same variable (`foo`) can be formatted differently depending on which "
"_argument type_ is used: `X` vs `o` vs _unspecified_."
msgstr "동일한 변수(`foo`)라도 `X`, `o` 또는 _지정되지 않음_과 같이 어떤 _인자 타입_이 사용되느냐에 따라 다르게 형식화될 수 있습니다."

#: src/hello/print/fmt.md:12
msgid ""
"This formatting functionality is implemented via traits, and there is one "
"trait for each argument type. The most common formatting trait is `Display`, "
"which handles cases where the argument type is left unspecified: `{}` for "
"instance."
msgstr ""
"이 형식화 기능은 트레이트를 통해 구현되며, 각 인자 타입에 대해 하나의 트레이트가 존재합니다. 가장 일반적인 형식화 트레이트는 `Display`이며, 인자 타입이 지정되지 않은 경우(예: `{}`)를 처리합니다."

#: src/hello/print/fmt.md:21
msgid "// Latitude\n"
msgstr "// 위도\n"

#: src/hello/print/fmt.md:23
msgid "// Longitude\n"
msgstr "// 경도\n"

#: src/hello/print/fmt.md:28
msgid ""
"// `f` is a buffer, and this method must write the formatted string into "
"it.\n"
msgstr "// `f`는 버퍼이며, 이 메서드는 버퍼에 형식화된 문자열을 써야 합니다.\n"

#: src/hello/print/fmt.md:30
msgid "'N'"
msgstr "'북'"

#: src/hello/print/fmt.md:30
msgid "'S'"
msgstr "'남'"

#: src/hello/print/fmt.md:31
msgid "'E'"
msgstr "'동'"

#: src/hello/print/fmt.md:31
msgid "'W'"
msgstr "'서'"

#: src/hello/print/fmt.md:33
msgid ""
"// `write!` is like `format!`, but it will write the formatted string\n"
"        // into a buffer (the first argument).\n"
msgstr ""
"// `write!`는 `format!`과 비슷하지만, 형식화된 문자열을\n"
"        // 버퍼(첫 번째 인자)에 씁니다.\n"

#: src/hello/print/fmt.md:35
msgid "\"{}: {:.3}°{} {:.3}°{}\""
msgstr "\"{}: {:.3}°{} {:.3}°{}\""

#: src/hello/print/fmt.md:49
msgid "\"Dublin\""
msgstr "\"더블린\""

#: src/hello/print/fmt.md:50
msgid "\"Oslo\""
msgstr "\"오슬로\""

#: src/hello/print/fmt.md:51
msgid "\"Vancouver\""
msgstr "\"밴쿠버\""

#: src/hello/print/fmt.md:60
msgid ""
"// Switch this to use {} once you've added an implementation\n"
"        // for fmt::Display.\n"
msgstr ""
"// fmt::Display 구현을 추가한 후에는 {}를 사용하도록 변경하세요.\n"

#: src/hello/print/fmt.md:62 src/primitives/tuples.md:60
#: src/custom_types/structs.md:47 src/types/inference.md:23
#: src/conversion/string.md:76 src/generics/bounds.md:49
#: src/generics/where.md:38 src/std/str.md:137 src/std/result.md:59
#: src/std/result.md:61 src/std/result.md:63 src/std/arc.md:26
#: src/std_misc/channels.md:53
msgid "\"{:?}\""
msgstr "\"{:?}\""

#: src/hello/print/fmt.md:67
msgid ""
"You can view a [full list of formatting traits](https://doc.rust-lang.org/"
"std/fmt/#formatting-traits) and their argument types in the [`std::fmt`]"
"(https://doc.rust-lang.org/std/fmt/) documentation."
msgstr ""
"[`std::fmt`](https://doc.rust-lang.org/std/fmt/) 문서에서 [형식화 트레이트 전체 목록](https://doc.rust-lang.org/std/fmt/#formatting-traits)과 해당 인자 타입을 확인할 수 있습니다."

#: src/hello/print/fmt.md:72
msgid ""
"Add an implementation of the `fmt::Display` trait for the `Color` struct "
"above so that the output displays as:"
msgstr "위의 `Color` 구조체에 `fmt::Display` 트레이트 구현을 추가하여 다음과 같이 출력되도록 하세요:"

#: src/hello/print/fmt.md:81
msgid "Two hints if you get stuck:"
msgstr "막혔을 때를 위한 두 가지 힌트:"

#: src/hello/print/fmt.md:83
msgid ""
"You [may need to list each color more than once](https://doc.rust-lang.org/"
"std/fmt/#named-parameters)."
msgstr "[각 색상을 두 번 이상 나열해야 할 수도 있습니다](https://doc.rust-lang.org/std/fmt/#named-parameters)."

#: src/hello/print/fmt.md:84
msgid ""
"You can [pad with zeros to a width of 2](https://doc.rust-lang.org/std/fmt/"
"#width) with `:0>2`. For hexadecimals, you can use `:02X`."
msgstr "`:0>2`를 사용하여 [0을 채워 너비를 2로 맞출](https://doc.rust-lang.org/std/fmt/#width) 수 있습니다. 16진수의 경우 `:02X`를 사용할 수 있습니다."

#: src/hello/print/fmt.md:87
msgid "Bonus:"
msgstr "보너스:"

#: src/hello/print/fmt.md:89
msgid ""
"If you would like to experiment with [type casting](../../types/cast.md) in "
"advance, the formula for [calculating a color in the RGB color space]"
"(https://www.rapidtables.com/web/color/RGB_Color.html#rgb-format) is `RGB = "
"(R * 65_536) + (G * 256) + B`, where `R is RED, G is GREEN, and B is BLUE`. "
"An unsigned 8-bit integer (`u8`) can only hold numbers up to 255. To cast "
"`u8` to `u32`, you can write `variable_name as u32`."
msgstr "[타입 변환(type casting)](../../types/cast.md)을 미리 실험해보고 싶다면, [RGB 색 공간에서 색상을 계산하는 공식](https://www.rapidtables.com/web/color/RGB_Color.html#rgb-format)은 `RGB = (R * 65_536) + (G * 256) + B`이며, 여기서 `R은 RED, G는 GREEN, B는 BLUE`입니다. 부호 없는 8비트 정수(`u8`)는 255까지의 숫자만 담을 수 있습니다. `u8`을 `u32`로 변환하려면 `variable_name as u32`와 같이 쓸 수 있습니다."

#: src/hello/print/fmt.md:96
msgid "[`std::fmt`](https://doc.rust-lang.org/std/fmt/)"
msgstr "[`std::fmt`](https://doc.rust-lang.org/std/fmt/)"

#: src/primitives.md:3
msgid ""
"Rust provides access to a wide variety of `primitives`. A sample includes:"
msgstr "Rust는 다양한 `기본 자료형(primitives)`에 대한 접근을 제공합니다. 샘플은 다음과 같습니다:"

#: src/primitives.md:5
msgid "Scalar Types"
msgstr "스칼라 타입"

#: src/primitives.md:7
msgid ""
"Signed integers: `i8`, `i16`, `i32`, `i64`, `i128` and `isize` (pointer size)"
msgstr "부호 있는 정수: `i8`, `i16`, `i32`, `i64`, `i128` 및 `isize` (포인터 크기)"

#: src/primitives.md:8
msgid ""
"Unsigned integers: `u8`, `u16`, `u32`, `u64`, `u128` and `usize` (pointer "
"size)"
msgstr "부호 없는 정수: `u8`, `u16`, `u32`, `u64`, `u128` 및 `usize` (포인터 크기)"

#: src/primitives.md:10
msgid "Floating point: `f32`, `f64`"
msgstr "부동 소수점: `f32`, `f64`"

#: src/primitives.md:11
msgid "`char` Unicode scalar values like `'a'`, `'α'` and `'∞'` (4 bytes each)"
msgstr "`char` 유니코드 스칼라 값: `'a'`, `'α'`, `'∞'` 등 (각 4바이트)"

#: src/primitives.md:12
msgid "`bool` either `true` or `false`"
msgstr "`bool`: `true` 또는 `false`"

#: src/primitives.md:13
msgid "The unit type `()`, whose only possible value is an empty tuple: `()`"
msgstr "유닛 타입 `()`: 가능한 유일한 값은 빈 튜플 `()`입니다."

#: src/primitives.md:15
msgid ""
"Despite the value of a unit type being a tuple, it is not considered a "
"compound type because it does not contain multiple values."
msgstr "유닛 타입의 값이 튜플임에도 불구하고, 여러 값을 포함하지 않기 때문에 복합 타입(compound type)으로 간주되지 않습니다."

#: src/primitives.md:18
msgid "Compound Types"
msgstr "복합 타입"

#: src/primitives.md:20
msgid "Arrays like `[1, 2, 3]`"
msgstr "`[1, 2, 3]`과 같은 배열"

#: src/primitives.md:21
msgid "Tuples like `(1, true)`"
msgstr "`(1, true)`와 같은 튜플"

#: src/primitives.md:23
msgid ""
"Variables can always be _type annotated_. Numbers may additionally be "
"annotated via a _suffix_ or _by default_. Integers default to `i32` and "
"floats to `f64`. Note that Rust can also infer types from context."
msgstr "변수는 항상 _타입 어노테이션_이 가능합니다. 숫자는 추가적으로 _접미사(suffix)_를 통하거나 _기본값_으로 어노테이션될 수 있습니다. 정수 기본값은 `i32`이고 부동 소수점 기본값은 `f64`입니다. 또한 Rust는 문맥으로부터 타입을 추론할 수도 있습니다."

#: src/primitives.md:29
msgid "// Variables can be type annotated.\n"
msgstr "// 변수는 타입 어노테이션이 가능합니다.\n"

#: src/primitives.md:32
msgid "// Regular annotation\n"
msgstr "// 일반적인 어노테이션\n"

#: src/primitives.md:33
msgid "// Suffix annotation\n"
msgstr "// 접미사 어노테이션\n"

#: src/primitives.md:35
msgid "// Or a default will be used.\n"
msgstr ""

#: src/primitives.md:36
msgid "// `f64`\n"
msgstr ""

#: src/primitives.md:37
msgid "// `i32`\n"
msgstr ""

#: src/primitives.md:39
msgid "// A type can also be inferred from context.\n"
msgstr ""

#: src/primitives.md:40
msgid "// Type i64 is inferred from another line.\n"
msgstr ""

#: src/primitives.md:43
msgid "// A mutable variable's value can be changed.\n"
msgstr ""

#: src/primitives.md:44
msgid "// Mutable `i32`\n"
msgstr ""

#: src/primitives.md:47
msgid "// Error! The type of a variable can't be changed.\n"
msgstr ""

#: src/primitives.md:50
msgid "// Variables can be overwritten with shadowing.\n"
msgstr ""

#: src/primitives.md:53
msgid "/* Compound types - Array and Tuple */"
msgstr ""

#: src/primitives.md:55
msgid "// Array signature consists of Type T and length as [T; length].\n"
msgstr ""

#: src/primitives.md:58
msgid ""
"// Tuple is a collection of values of different types\n"
"    // and is constructed using parentheses ().\n"
msgstr ""

#: src/primitives.md:66
msgid ""
"[the `std` library](https://doc.rust-lang.org/std/), [`mut`]"
"(variable_bindings/mut.md), [`inference`](types/inference.md), and "
"[`shadowing`](variable_bindings/scope.md)"
msgstr ""

#: src/primitives/literals.md:3
msgid ""
"Integers `1`, floats `1.2`, characters `'a'`, strings `\"abc\"`, booleans "
"`true` and the unit type `()` can be expressed using literals."
msgstr ""

#: src/primitives/literals.md:6
msgid ""
"Integers can, alternatively, be expressed using hexadecimal, octal or binary "
"notation using these prefixes respectively: `0x`, `0o` or `0b`."
msgstr ""

#: src/primitives/literals.md:9
msgid ""
"Underscores can be inserted in numeric literals to improve readability, e.g. "
"`1_000` is the same as `1000`, and `0.000_001` is the same as `0.000001`."
msgstr ""

#: src/primitives/literals.md:12
msgid ""
"Rust also supports scientific [E-notation](https://en.wikipedia.org/wiki/"
"Scientific_notation#E_notation), e.g. `1e6`, `7.6e-4`. The associated type "
"is `f64`."
msgstr ""

#: src/primitives/literals.md:15
msgid ""
"We need to tell the compiler the type of the literals we use. For now, we'll "
"use the `u32` suffix to indicate that the literal is an unsigned 32-bit "
"integer, and the `i32` suffix to indicate that it's a signed 32-bit integer."
msgstr ""

#: src/primitives/literals.md:19
msgid ""
"The operators available and their precedence [in Rust](https://doc.rust-"
"lang.org/reference/expressions.html#expression-precedence) are similar to "
"other [C-like languages](https://en.wikipedia.org/wiki/"
"Operator_precedence#Programming_languages)."
msgstr ""

#: src/primitives/literals.md:24
msgid "// Integer addition\n"
msgstr ""

#: src/primitives/literals.md:25
msgid "\"1 + 2 = {}\""
msgstr "\"1 + 2 = {}\""

#: src/primitives/literals.md:27
msgid "// Integer subtraction\n"
msgstr "// 정수 뺄셈\n"

#: src/primitives/literals.md:28
msgid "\"1 - 2 = {}\""
msgstr "\"1 - 2 = {}\""

#: src/primitives/literals.md:29
msgid ""
"// TODO ^ Try changing `1i32` to `1u32` to see why the type is important\n"
msgstr "// TODO ^ `1i32`를 `1u32`로 변경하여 타입이 중요한 이유를 확인해 보세요\n"

#: src/primitives/literals.md:31
msgid "// Scientific notation\n"
msgstr "// 과학적 표기법\n"

#: src/primitives/literals.md:32
msgid "\"1e4 is {}, -2.5e-3 is {}\""
msgstr "\"1e4는 {}, -2.5e-3은 {}입니다\""

#: src/primitives/literals.md:34
msgid "// Short-circuiting boolean logic\n"
msgstr "// 단락(Short-circuiting) 불리언 로직\n"

#: src/primitives/literals.md:35
msgid "\"true AND false is {}\""
msgstr "\"true AND false는 {}입니다\""

#: src/primitives/literals.md:36
msgid "\"true OR false is {}\""
msgstr "\"true OR false는 {}입니다\""

#: src/primitives/literals.md:37
msgid "\"NOT true is {}\""
msgstr "\"NOT true는 {}입니다\""

#: src/primitives/literals.md:39
msgid "// Bitwise operations\n"
msgstr "// 비트 연산\n"

#: src/primitives/literals.md:40
msgid "\"0011 AND 0101 is {:04b}\""
msgstr "\"0011 AND 0101은 {:04b}입니다\""

#: src/primitives/literals.md:41
msgid "\"0011 OR 0101 is {:04b}\""
msgstr "\"0011 OR 0101은 {:04b}입니다\""

#: src/primitives/literals.md:42
msgid "\"0011 XOR 0101 is {:04b}\""
msgstr "\"0011 XOR 0101은 {:04b}입니다\""

#: src/primitives/literals.md:43
msgid "\"1 << 5 is {}\""
msgstr "\"1 << 5는 {}입니다\""

#: src/primitives/literals.md:44
msgid "\"0x80 >> 2 is 0x{:x}\""
msgstr "\"0x80 >> 2는 0x{:x}입니다\""

#: src/primitives/literals.md:46
msgid "// Use underscores to improve readability!\n"
msgstr "// 가독성을 높이기 위해 밑줄을 사용하세요!\n"

#: src/primitives/literals.md:47
msgid "\"One million is written as {}\""
msgstr "\"백만은 {}로 씁니다\""

#: src/primitives/tuples.md:3
msgid ""
"A tuple is a collection of values of different types. Tuples are constructed "
"using parentheses `()`, and each tuple itself is a value with type signature "
"`(T1, T2, ...)`, where `T1`, `T2` are the types of its members. Functions "
"can use tuples to return multiple values, as tuples can hold any number of "
"values."
msgstr ""
"튜플은 서로 다른 타입의 값들의 모음입니다. 튜플은 괄호 `()`를 사용하여 생성되며, 각 튜플 자체는 `(T1, T2, ...)` 형태의 타입 시그니처를 가진 값입니다. 여기서 `T1`, `T2`는 튜플 멤버의 타입입니다. 튜플은 여러 값을 담을 수 있으므로 함수에서 여러 값을 반환하는 데 사용할 수 있습니다."

#: src/primitives/tuples.md:9
msgid "// Tuples can be used as function arguments and as return values.\n"
msgstr "// 튜플은 함수의 인자와 반환값으로 사용될 수 있습니다.\n"

#: src/primitives/tuples.md:11
msgid "// `let` can be used to bind the members of a tuple to variables.\n"
msgstr "// `let`을 사용하여 튜플의 멤버를 변수에 바인딩할 수 있습니다.\n"

#: src/primitives/tuples.md:16
msgid "// The following struct is for the activity.\n"
msgstr "// 다음 구조체는 실습을 위한 것입니다.\n"

#: src/primitives/tuples.md:22
msgid "// A tuple with a bunch of different types.\n"
msgstr "// 여러 다른 타입을 가진 튜플입니다.\n"

#: src/primitives/tuples.md:26 src/generics.md:50 src/generics.md:55
#: src/generics/gen_fn.md:47
msgid "'a'"
msgstr "'a'"

#: src/primitives/tuples.md:28
msgid "// Values can be extracted from the tuple using tuple indexing.\n"
msgstr "// 튜플 인덱싱을 사용하여 튜플에서 값을 추출할 수 있습니다.\n"

#: src/primitives/tuples.md:29
msgid "\"Long tuple first value: {}\""
msgstr "\"긴 튜플의 첫 번째 값: {}\""

#: src/primitives/tuples.md:30
msgid "\"Long tuple second value: {}\""
msgstr "\"긴 튜플의 두 번째 값: {}\""

#: src/primitives/tuples.md:32
msgid "// Tuples can be tuple members.\n"
msgstr "// 튜플은 튜플의 멤버가 될 수 있습니다.\n"

#: src/primitives/tuples.md:35
msgid "// Tuples are printable.\n"
msgstr "// 튜플은 출력 가능합니다.\n"

#: src/primitives/tuples.md:36
msgid "\"tuple of tuples: {:?}\""
msgstr "\"튜플의 튜플: {:?}\""

#: src/primitives/tuples.md:38
msgid ""
"// But long Tuples (more than 12 elements) cannot be printed.\n"
"    //let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);\n"
"    //println!(\"Too long tuple: {:?}\", too_long_tuple);\n"
"    // TODO ^ Uncomment the above 2 lines to see the compiler error\n"
msgstr ""
"// 하지만 긴 튜플(요소 12개 초과)은 출력할 수 없습니다.\n"
"    //let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);\n"
"    //println!(\"Too long tuple: {:?}\", too_long_tuple);\n"
"    // TODO ^ 위의 두 줄의 주석을 해제하여 컴파일 에러를 확인해 보세요\n"

#: src/primitives/tuples.md:44
msgid "\"Pair is {:?}\""
msgstr "\"페어는 {:?}입니다\""

#: src/primitives/tuples.md:46
msgid "\"The reversed pair is {:?}\""
msgstr "\"반전된 페어는 {:?}입니다\""

#: src/primitives/tuples.md:48
msgid ""
"// To create one element tuples, the comma is required to tell them apart\n"
"    // from a literal surrounded by parentheses.\n"
msgstr ""
"// 요소가 하나인 튜플을 만들려면, 괄호로 둘러싸인 리터럴과\n"
"    // 구분하기 위해 콤마가 필요합니다.\n"

#: src/primitives/tuples.md:50
msgid "\"One element tuple: {:?}\""
msgstr "\"요소가 하나인 튜플: {:?}\""

#: src/primitives/tuples.md:51
msgid "\"Just an integer: {:?}\""
msgstr "\"그냥 정수: {:?}\""

#: src/primitives/tuples.md:53
msgid "// Tuples can be destructured to create bindings.\n"
msgstr "// 튜플은 구조 분해(destructure)하여 바인딩을 생성할 수 있습니다.\n"

#: src/primitives/tuples.md:54 src/conversion/from_into.md:17
#: src/fn/closures/input_parameters.md:52 src/std_misc/fs.md:51
msgid "\"hello\""
msgstr "\"안녕\""

#: src/primitives/tuples.md:57
msgid "\"{:?}, {:?}, {:?}, {:?}\""
msgstr "\"{:?}, {:?}, {:?}, {:?}\""

#: src/primitives/tuples.md:66
msgid ""
"_Recap_: Add the `fmt::Display` trait to the `Matrix` struct in the above "
"example, so that if you switch from printing the debug format `{:?}` to the "
"display format `{}`, you see the following output:"
msgstr ""
"_요약_: 위 예제의 `Matrix` 구조체에 `fmt::Display` 트레이트를 추가하여, 디버그 형식 `{:?}`에서 디스플레이 형식 `{}`로 출력을 전환했을 때 다음과 같은 출력이 나오도록 하세요:"

#: src/primitives/tuples.md:75
msgid ""
"You may want to refer back to the example for [print display](../hello/print/"
"print_display.md)."
msgstr ""
"[표시 출력](../hello/print/print_display.md)에 대한 예제를 다시 참조하고 싶을 수도 있습니다."

#: src/primitives/tuples.md:76
msgid ""
"Add a `transpose` function using the `reverse` function as a template, which "
"accepts a matrix as an argument, and returns a matrix in which two elements "
"have been swapped. For example:"
msgstr ""
"`reverse` 함수를 템플릿으로 사용하여 `transpose` 함수를 추가하세요. 이 함수는 행렬을 인자로 받아 두 요소가 바뀐 행렬을 반환합니다. 예를 들어:"

#: src/primitives/tuples.md:81
msgid "\"Matrix:\\n{}\""
msgstr "\"행렬:\\n{}\""

#: src/primitives/tuples.md:82
msgid "\"Transpose:\\n{}\""
msgstr "\"전치(Transpose):\\n{}\""

#: src/primitives/tuples.md:85
msgid "Results in the output:"
msgstr "출력 결과:"

#: src/primitives/array.md:3
msgid ""
"An array is a collection of objects of the same type `T`, stored in "
"contiguous memory. Arrays are created using brackets `[]`, and their length, "
"which is known at compile time, is part of their type signature `[T; "
"length]`."
msgstr "배열은 연속된 메모리에 저장된 동일한 타입 `T`를 가진 객체들의 모음입니다. 배열은 대괄호 `[]`를 사용하여 생성되며, 컴파일 타임에 알려진 배열의 길이는 타입 시그니처 `[T; length]`의 일부가 됩니다."

#: src/primitives/array.md:7
msgid ""
"Slices are similar to arrays, but their length is not known at compile time. "
"Instead, a slice is a two-word object; the first word is a pointer to the "
"data, the second word is the length of the slice. The word size is the same "
"as usize, determined by the processor architecture, e.g. 64 bits on an "
"x86-64. Slices can be used to borrow a section of an array and have the type "
"signature `&[T]`."
msgstr "슬라이스는 배열과 유사하지만, 컴파일 타임에 그 길이를 알 수 없습니다. 대신, 슬라이스는 두 개의 워드(word)로 구성된 객체입니다. 첫 번째 워드는 데이터에 대한 포인터이고, 두 번째 워드는 슬라이스의 길이입니다. 워드 크기는 프로세서 아키텍처에 의해 결정되는 usize와 같으며, 예를 들어 x86-64에서는 64비트입니다. 슬라이스는 배열의 일부분을 빌려오는 데 사용될 수 있으며 `&[T]`라는 타입 시그니처를 가집니다."

#: src/primitives/array.md:15
msgid "// This function borrows a slice.\n"
msgstr "// 이 함수는 슬라이스를 빌려옵니다.\n"

#: src/primitives/array.md:18
msgid "\"First element of the slice: {}\""
msgstr "\"슬라이스의 첫 번째 요소: {}\""

#: src/primitives/array.md:19
msgid "\"The slice has {} elements\""
msgstr "\"슬라이스는 {}개의 요소를 가지고 있습니다\""

#: src/primitives/array.md:23
msgid "// Fixed-size array (type signature is superfluous).\n"
msgstr "// 고정 크기 배열 (타입 시그니처는 생략 가능합니다).\n"

#: src/primitives/array.md:26
msgid "// All elements can be initialized to the same value.\n"
msgstr "// 모든 요소를 동일한 값으로 초기화할 수 있습니다.\n"

#: src/primitives/array.md:29
msgid "// Indexing starts at 0.\n"
msgstr "// 인덱싱은 0부터 시작합니다.\n"

#: src/primitives/array.md:30
msgid "\"First element of the array: {}\""
msgstr "\"배열의 첫 번째 요소: {}\""

#: src/primitives/array.md:31
msgid "\"Second element of the array: {}\""
msgstr "\"배열의 두 번째 요소: {}\""

#: src/primitives/array.md:33
msgid "// `len` returns the count of elements in the array.\n"
msgstr "// `len`은 배열의 요소 개수를 반환합니다.\n"

#: src/primitives/array.md:34
msgid "\"Number of elements in array: {}\""
msgstr "\"배열의 요소 개수: {}\""

#: src/primitives/array.md:36
msgid "// Arrays are stack allocated.\n"
msgstr "// 배열은 스택에 할당됩니다.\n"

#: src/primitives/array.md:37
msgid "\"Array occupies {} bytes\""
msgstr "\"배열의 점유 메모리: {} 바이트\""

#: src/primitives/array.md:39
msgid "// Arrays can be automatically borrowed as slices.\n"
msgstr "// 배열은 자동으로 슬라이스로 빌려올 수 있습니다.\n"

#: src/primitives/array.md:40
msgid "\"Borrow the whole array as a slice.\""
msgstr "\"배열 전체를 슬라이스로 빌려옵니다.\""

#: src/primitives/array.md:43
msgid ""
"// Slices can point to a section of an array.\n"
"    // They are of the form [starting_index..ending_index].\n"
"    // `starting_index` is the first position in the slice.\n"
"    // `ending_index` is one more than the last position in the slice.\n"
msgstr ""
"// 슬라이스는 배열의 한 섹션을 가리킬 수 있습니다.\n"
"    // [시작_인덱스..종료_인덱스] 형태입니다.\n"
"    // `시작_인덱스`는 슬라이스의 첫 번째 위치입니다.\n"
"    // `종료_인덱스`는 슬라이스의 마지막 위치보다 하나 더 큰 값입니다.\n"

#: src/primitives/array.md:47
msgid "\"Borrow a section of the array as a slice.\""
msgstr "\"배열의 한 섹션을 슬라이스로 빌려옵니다.\""

#: src/primitives/array.md:50
msgid "// Example of empty slice `&[]`:\n"
msgstr "// 빈 슬라이스 `&[]`의 예시:\n"

#: src/primitives/array.md:53
msgid "// Same but more verbose\n"
msgstr "// 동일하지만 더 장황한 표현\n"

#: src/primitives/array.md:55
msgid ""
"// Arrays can be safely accessed using `.get`, which returns an\n"
"    // `Option`. This can be matched as shown below, or used with\n"
"    // `.expect()` if you would like the program to exit with a nice\n"
"    // message instead of happily continue.\n"
msgstr ""
"// 배열은 `.get`을 사용하여 안전하게 접근할 수 있으며, 이는 `Option`을 반환합니다.\n"
"    // 이는 아래와 같이 매치(match)될 수 있으며, 프로그램을 계속 진행하는 대신\n"
"    // 친절한 메시지와 함께 종료하고 싶다면 `.expect()`와 함께 사용될 수 있습니다.\n"

#: src/primitives/array.md:59
msgid "// Oops, one element too far!\n"
msgstr "// 이런, 범위를 하나 벗어났네요!\n"

#: src/primitives/array.md:61
msgid "\"{}: {}\""
msgstr "\"{}: {}\""

#: src/primitives/array.md:62
msgid "\"Slow down! {} is too far!\""
msgstr "\"진정하세요! {}는 너무 멀리 갔습니다!\""

#: src/primitives/array.md:66
msgid ""
"// Out of bound indexing on array with constant value causes compile time "
"error.\n"
"    //println!(\"{}\", xs[5]);\n"
"    // Out of bound indexing on slice causes runtime error.\n"
"    //println!(\"{}\", xs[..][5]);\n"
msgstr ""
"// 상수 값을 사용한 배열의 범위를 벗어난 인덱싱은 컴파일 타임 에러를 발생시킵니다.\n"
"    //println!(\"{}\", xs[5]);\n"
"    // 슬라이스에서 범위를 벗어난 인덱싱은 런타임 에러를 발생시킵니다.\n"
"    //println!(\"{}\", xs[..][5]);\n"

#: src/custom_types.md:3
msgid "Rust custom data types are formed mainly through the two keywords:"
msgstr "Rust의 사용자 정의 데이터 타입은 주로 다음 두 키워드를 통해 형성됩니다:"

#: src/custom_types.md:5
msgid "`struct`: define a structure"
msgstr "`struct`: 구조체를 정의합니다"

#: src/custom_types.md:6
msgid "`enum`: define an enumeration"
msgstr "`enum`: 열거형을 정의합니다"

#: src/custom_types.md:8
msgid "Constants can also be created via the `const` and `static` keywords."
msgstr "상수는 `const`와 `static` 키워드를 통해 생성할 수 있습니다."

#: src/custom_types/structs.md:3
msgid ""
"There are three types of structures (\"structs\") that can be created using "
"the `struct` keyword:"
msgstr "`struct` 키워드를 사용하여 생성할 수 있는 구조체(\"structs\")에는 세 가지 유형이 있습니다:"

#: src/custom_types/structs.md:6
msgid "Tuple structs, which are, basically, named tuples."
msgstr "기본적으로 이름이 붙은 튜플인 튜플 구조체."

#: src/custom_types/structs.md:7
msgid ""
"The classic [C structs](https://en.wikipedia.org/wiki/"
"Struct_(C_programming_language))"
msgstr "전통적인 [C 구조체](https://en.wikipedia.org/wiki/Struct_(C_programming_language))"

#: src/custom_types/structs.md:8
msgid "Unit structs, which are field-less, are useful for generics."
msgstr "필드가 없는 유닛 구조체로, 제네릭에 유용합니다."

#: src/custom_types/structs.md:11 src/custom_types/enum/enum_use.md:6
#: src/custom_types/enum/c_like.md:6
msgid "// An attribute to hide warnings for unused code.\n"
msgstr "// 사용되지 않는 코드에 대한 경고를 숨기기 위한 속성입니다.\n"

#: src/custom_types/structs.md:19
msgid "// A unit struct\n"
msgstr "// 유닛 구조체\n"

#: src/custom_types/structs.md:22
msgid "// A tuple struct\n"
msgstr "// 튜플 구조체\n"

#: src/custom_types/structs.md:25
msgid "// A struct with two fields\n"
msgstr "// 두 개의 필드를 가진 구조체\n"

#: src/custom_types/structs.md:31
msgid "// Structs can be reused as fields of another struct\n"
msgstr "// 구조체는 다른 구조체의 필드로 재사용될 수 있습니다.\n"

#: src/custom_types/structs.md:34
msgid ""
"// A rectangle can be specified by where the top left and bottom right\n"
"    // corners are in space.\n"
msgstr "// 사각형은 공간상에서 왼쪽 위와 오른쪽 아래 모서리의 위치로 지정될 수 있습니다.\n"

#: src/custom_types/structs.md:41
msgid "// Create struct with field init shorthand\n"
msgstr "// 필드 초기화 축약형(field init shorthand)으로 구조체를 생성합니다.\n"

#: src/custom_types/structs.md:46
msgid "// Print debug struct\n"
msgstr "// 디버그용 구조체 출력\n"

#: src/custom_types/structs.md:49
msgid "// Instantiate a `Point`\n"
msgstr "// `Point` 인스턴스 생성\n"

#: src/custom_types/structs.md:53
msgid "// Access the fields of the point\n"
msgstr "// 좌표의 필드에 접근\n"

#: src/custom_types/structs.md:54
msgid "\"point coordinates: ({}, {})\""
msgstr "\"좌표 좌표: ({}, {})\""

#: src/custom_types/structs.md:56
msgid ""
"// Make a new point by using struct update syntax to use the fields of our\n"
"    // other one\n"
msgstr ""
"// 구조체 업데이트 구문을 사용하여 다른 포인트의 필드를 활용해\n"
"    // 새로운 포인트를 만듭니다.\n"

#: src/custom_types/structs.md:60
msgid ""
"// `bottom_right.y` will be the same as `another_point.y` because we used "
"that field\n"
"    // from `another_point`\n"
msgstr ""
"// `another_point`의 필드를 사용했으므로 `bottom_right.y`는 `another_point.y`와 동일합니다.\n"

#: src/custom_types/structs.md:62
msgid "\"second point: ({}, {})\""
msgstr "\"두 번째 좌표: ({}, {})\""

#: src/custom_types/structs.md:64
msgid "// Destructure the point using a `let` binding\n"
msgstr "// `let` 바인딩을 사용하여 좌표를 구조 분해합니다.\n"

#: src/custom_types/structs.md:68
msgid "// struct instantiation is an expression too\n"
msgstr "// 구조체 인스턴스 생성은 표현식이기도 합니다.\n"

#: src/custom_types/structs.md:73
msgid "// Instantiate a unit struct\n"
msgstr "// 유닛 구조체 인스턴스 생성\n"

#: src/custom_types/structs.md:76
msgid "// Instantiate a tuple struct\n"
msgstr "// 튜플 구조체 인스턴스 생성\n"

#: src/custom_types/structs.md:79
msgid "// Access the fields of a tuple struct\n"
msgstr "// 튜플 구조체의 필드에 접근\n"

#: src/custom_types/structs.md:80 src/custom_types/structs.md:85
msgid "\"pair contains {:?} and {:?}\""
msgstr "\"페어는 {:?}와 {:?}를 포함합니다\""

#: src/custom_types/structs.md:82
msgid "// Destructure a tuple struct\n"
msgstr "// 튜플 구조체 구조 분해\n"

#: src/custom_types/structs.md:91
msgid ""
"Add a function `rect_area` which calculates the area of a `Rectangle` (try "
"using nested destructuring)."
msgstr "`Rectangle`의 넓이를 계산하는 `rect_area` 함수를 추가하세요. (중첩된 구조 분해를 사용해 보세요)."

#: src/custom_types/structs.md:93
msgid ""
"Add a function `square` which takes a `Point` and a `f32` as arguments, and "
"returns a `Rectangle` with its top left corner on the point, and a width and "
"height corresponding to the `f32`."
msgstr "`Point`와 `f32`를 인자로 받아, 해당 포인트를 왼쪽 위 모서리로 하고 `f32`에 해당하는 너비와 높이를 가진 `Rectangle`을 반환하는 `square` 함수를 추가하세요."

#: src/custom_types/structs.md:97
msgid "See also"
msgstr "참고"

#: src/custom_types/structs.md:99
msgid ""
"[`attributes`](../attribute.md), [raw identifiers](../compatibility/"
"raw_identifiers.md) and [destructuring](../flow_control/match/"
"destructuring.md)"
msgstr ""
"[`속성`](../attribute.md), [raw 식별자](../compatibility/raw_identifiers.md) 및 [구조 분해](../flow_control/match/destructuring.md)"

#: src/custom_types/enum.md:3
msgid ""
"The `enum` keyword allows the creation of a type which may be one of a few "
"different variants. Any variant which is valid as a `struct` is also valid "
"in an `enum`."
msgstr "`enum` 키워드는 몇 가지 다른 변체 중 하나일 수 있는 타입을 생성할 수 있게 합니다. `struct`로 유효한 모든 변체는 `enum`에서도 유효합니다."

#: src/custom_types/enum.md:8
msgid ""
"// Create an `enum` to classify a web event. Note how both\n"
"// names and type information together specify the variant:\n"
"// `PageLoad != PageUnload` and `KeyPress(char) != Paste(String)`.\n"
"// Each is different and independent.\n"
msgstr ""
"// 웹 이벤트를 분류하기 위한 `enum`을 생성합니다. 이름과 타입 정보가\n"
"// 함께 변체를 지정하는 방식에 주목하세요:\n"
"// `PageLoad != PageUnload` 이고 `KeyPress(char) != Paste(String)` 입니다.\n"
"// 각각은 서로 다르고 독립적입니다.\n"

#: src/custom_types/enum.md:13
msgid "// An `enum` variant may either be `unit-like`,\n"
msgstr "// `enum` 변체는 유닛 형태(unit-like)일 수도 있고,\n"

#: src/custom_types/enum.md:16
msgid "// like tuple structs,\n"
msgstr "// 튜플 구조체 형태일 수도 있으며,\n"

#: src/custom_types/enum.md:19
msgid "// or c-like structures.\n"
msgstr "// 또는 C 구조체 형태일 수도 있습니다.\n"

#: src/custom_types/enum.md:22
msgid ""
"// A function which takes a `WebEvent` enum as an argument and\n"
"// returns nothing.\n"
msgstr ""
"// `WebEvent` 열거형을 인자로 받고 아무것도 반환하지 않는 함수입니다.\n"

#: src/custom_types/enum.md:27
msgid "\"page loaded\""
msgstr "\"페이지 로드됨\""

#: src/custom_types/enum.md:28
msgid "\"page unloaded\""
msgstr "\"페이지 언로드됨\""

#: src/custom_types/enum.md:29
msgid "// Destructure `c` from inside the `enum` variant.\n"
msgstr "// `enum` 변체 내부에서 `c`를 구조 분해합니다.\n"

#: src/custom_types/enum.md:30
msgid "\"pressed '{}'.\""
msgstr "\"'{}' 키가 눌렸습니다.\""

#: src/custom_types/enum.md:31
msgid "\"pasted \\\"{}\\\".\""
msgstr "\"\\\"{}\\\"가 붙여넣기 되었습니다.\""

#: src/custom_types/enum.md:32
msgid "// Destructure `Click` into `x` and `y`.\n"
msgstr "// `Click`을 `x`와 `y`로 구조 분해합니다.\n"

#: src/custom_types/enum.md:34
msgid "\"clicked at x={}, y={}.\""
msgstr "\"x={}, y={} 지점이 클릭되었습니다.\""

#: src/custom_types/enum.md:40
msgid "'x'"
msgstr "'x'"

#: src/custom_types/enum.md:41
msgid "// `to_owned()` creates an owned `String` from a string slice.\n"
msgstr "// `to_owned()`는 문자열 슬라이스로부터 소유권이 있는 `String`을 생성합니다.\n"

#: src/custom_types/enum.md:42
msgid "\"my text\""
msgstr "\"나의 텍스트\""

#: src/custom_types/enum.md:56
msgid "Type aliases"
msgstr "타입 별칭"

#: src/custom_types/enum.md:58
msgid ""
"If you use a type alias, you can refer to each enum variant via its alias. "
"This might be useful if the enum's name is too long or too generic, and you "
"want to rename it."
msgstr ""
"타입 별칭을 사용하면, 별칭을 통해 각 열거형 변체를 참조할 수 있습니다. 이는 열거형의 이름이 너무 길거나 너무 일반적이어서 이름을 바꾸고 싶을 때 유용할 수 있습니다."

#: src/custom_types/enum.md:67
msgid "// Creates a type alias\n"
msgstr "// 타입 별칭을 생성합니다\n"

#: src/custom_types/enum.md:72
msgid ""
"// We can refer to each variant via its alias, not its long and "
"inconvenient\n"
"    // name.\n"
msgstr "// 길고 불편한 이름 대신 별칭을 통해 각 변체를 참조할 수 있습니다.\n"

#: src/custom_types/enum.md:78
msgid ""
"The most common place you'll see this is in `impl` blocks using the `Self` "
"alias."
msgstr "이를 가장 흔히 볼 수 있는 곳은 `Self` 별칭을 사용하는 `impl` 블록 내부입니다."

#: src/custom_types/enum.md:96
msgid ""
"To learn more about enums and type aliases, you can read the [stabilization "
"report](https://github.com/rust-lang/rust/pull/61682/"
"#issuecomment-502472847) from when this feature was stabilized into Rust."
msgstr "열거형과 타입 별칭에 대해 더 자세히 알아보려면, 이 기능이 Rust에서 안정화되었을 때의 [안정화 보고서](https://github.com/rust-lang/rust/pull/61682/#issuecomment-502472847)를 읽어보세요."

#: src/custom_types/enum.md:102
msgid ""
"[`match`](../flow_control/match.md), [`fn`](../fn.md), and [`String`](../std/"
"str.md), [\"Type alias enum variants\" RFC](https://rust-lang.github.io/rfcs/"
"2338-type-alias-enum-variants.html)"
msgstr "[`match`](../flow_control/match.md), [`fn`](../fn.md), 그리고 [`String`](../std/str.md), [\"타입 별칭 열거형 변체\" RFC](https://rust-lang.github.io/rfcs/2338-type-alias-enum-variants.html)"

#: src/custom_types/enum/enum_use.md:3
msgid ""
"The `use` declaration can be used to avoid typing the full module path to "
"access a name:"
msgstr "`use` 선언을 사용하면 이름을 사용하기 위해 전체 모듈 경로를 입력하는 것을 피할 수 있습니다:"

#: src/custom_types/enum/enum_use.md:20
msgid ""
"// Explicitly `use` each name so they are available without\n"
"    // manual scoping.\n"
msgstr ""
"// 각 이름을 명시적으로 `use`하여 수동으로 스코프를 지정하지 않고도\n"
"    // 사용할 수 있게 합니다.\n"

#: src/custom_types/enum/enum_use.md:23
msgid "// Automatically `use` each name inside `Role`.\n"
msgstr "// `Role` 내부의 각 이름을 자동으로 `use`합니다.\n"

#: src/custom_types/enum/enum_use.md:26
msgid "// Equivalent to `Stage::Beginner`.\n"
msgstr "// `Stage::Beginner`와 동일합니다.\n"

#: src/custom_types/enum/enum_use.md:28
msgid "// Equivalent to `Role::Student`.\n"
msgstr "// `Role::Student`와 동일합니다.\n"

#: src/custom_types/enum/enum_use.md:32
msgid "// Note the lack of scoping because of the explicit `use` above.\n"
msgstr "// 위의 명시적 `use` 덕분에 스코프 지정이 필요 없음에 주목하세요.\n"

#: src/custom_types/enum/enum_use.md:33
msgid "\"Beginners are starting their learning journey!\""
msgstr "\"초보자들이 학습 여정을 시작합니다!\""

#: src/custom_types/enum/enum_use.md:34
msgid "\"Advanced learners are mastering their subjects...\""
msgstr "\"상급 학습자들이 주제를 마스터하고 있습니다...\""

#: src/custom_types/enum/enum_use.md:38
msgid "// Note again the lack of scoping.\n"
msgstr "// 다시 한번 스코프 지정이 없음에 주목하세요.\n"

#: src/custom_types/enum/enum_use.md:39
msgid "\"Students are acquiring knowledge!\""
msgstr "\"학생들이 지식을 습득하고 있습니다!\""

#: src/custom_types/enum/enum_use.md:40
msgid "\"Teachers are spreading knowledge!\""
msgstr "\"교사들이 지식을 전파하고 있습니다!\""

#: src/custom_types/enum/enum_use.md:47
msgid "[`match`](../../flow_control/match.md) and [`use`](../../mod/use.md)"
msgstr "[`match`](../../flow_control/match.md)와 [`use`](../../mod/use.md)"

#: src/custom_types/enum/c_like.md:3
msgid "`enum` can also be used as C-like enums."
msgstr "`enum`은 C 스타일의 열거형으로도 사용될 수 있습니다."

#: src/custom_types/enum/c_like.md:8
msgid "// enum with implicit discriminator (starts at 0)\n"
msgstr "// 암시적 식별자(0부터 시작)를 가진 열거형\n"

#: src/custom_types/enum/c_like.md:15
msgid "// enum with explicit discriminator\n"
msgstr "// 명시적 식별자를 가진 열거형\n"

#: src/custom_types/enum/c_like.md:24
msgid "// `enums` can be cast as integers.\n"
msgstr "// `enum`은 정수로 형변환(cast)될 수 있습니다.\n"

#: src/custom_types/enum/c_like.md:25
msgid "\"zero is {}\""
msgstr "\"0은 {}입니다\""

#: src/custom_types/enum/c_like.md:26
msgid "\"one is {}\""
msgstr "\"1은 {}입니다\""

#: src/custom_types/enum/c_like.md:28
msgid "\"roses are #{:06x}\""
msgstr "\"장미는 #{:06x}색입니다\""

#: src/custom_types/enum/c_like.md:29
msgid "\"violets are #{:06x}\""
msgstr "\"제비꽃은 #{:06x}색입니다\""

#: src/custom_types/enum/c_like.md:35
msgid "[casting](../../types/cast.md)"
msgstr "[형변환](../../types/cast.md)"

#: src/custom_types/enum/testcase_linked_list.md:3
msgid "A common way to implement a linked-list is via `enums`:"
msgstr "연결 리스트를 구현하는 일반적인 방법은 `enums`를 사용하는 것입니다:"

#: src/custom_types/enum/testcase_linked_list.md:9
msgid ""
"// Cons: Tuple struct that wraps an element and a pointer to the next node\n"
msgstr "// Cons: 요소와 다음 노드에 대한 포인터를 감싸는 튜플 구조체\n"

#: src/custom_types/enum/testcase_linked_list.md:11
msgid "// Nil: A node that signifies the end of the linked list\n"
msgstr "// Nil: 연결 리스트의 끝을 나타내는 노드\n"

#: src/custom_types/enum/testcase_linked_list.md:14
msgid "// Methods can be attached to an enum\n"
msgstr "// 열거형에 메서드를 붙일 수 있습니다\n"

#: src/custom_types/enum/testcase_linked_list.md:17
msgid "// Create an empty list\n"
msgstr "// 빈 리스트를 생성합니다\n"

#: src/custom_types/enum/testcase_linked_list.md:19
msgid "// `Nil` has type `List`\n"
msgstr "// `Nil`은 `List` 타입을 가집니다\n"

#: src/custom_types/enum/testcase_linked_list.md:23
msgid ""
"// Consume a list, and return the same list with a new element at its front\n"
msgstr ""
"// 리스트를 소비하고, 그 앞에 새로운 요소가 추가된 동일한 리스트를 반환합니다\n"

#: src/custom_types/enum/testcase_linked_list.md:25
msgid "// `Cons` also has type List\n"
msgstr "// `Cons` 역시 `List` 타입을 가집니다\n"

#: src/custom_types/enum/testcase_linked_list.md:29
msgid "// Return the length of the list\n"
msgstr "// 리스트의 길이를 반환합니다\n"

#: src/custom_types/enum/testcase_linked_list.md:31
msgid ""
"// `self` has to be matched, because the behavior of this method\n"
"        // depends on the variant of `self`\n"
"        // `self` has type `&List`, and `*self` has type `List`, matching on "
"a\n"
"        // concrete type `T` is preferred over a match on a reference `&T`\n"
"        // after Rust 2018 you can use self here and tail (with no ref) "
"below as well,\n"
"        // rust will infer &s and ref tail.\n"
"        // See https://doc.rust-lang.org/edition-guide/rust-2018/ownership-"
"and-lifetimes/default-match-bindings.html\n"
msgstr ""
"// 메서드의 동작이 `self`의 변체에 따라 달라지므로 `self`에 대해 매치(match)를 수행해야 합니다.\n"
"        // `self`는 `&List` 타입이고, `*self`는 `List` 타입입니다. 구체적인 타입 `T`에 대한 매칭이\n"
"        // 참조 `&T`에 대한 매칭보다 선호됩니다.\n"
"        // Rust 2018 이후에는 여기서 self를 사용하고 아래에서 tail(ref 없이)을 사용할 수도 있습니다.\n"
"        // Rust가 &s와 ref tail을 추론할 것입니다.\n"
"        // 참고: https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/default-match-bindings.html\n"

#: src/custom_types/enum/testcase_linked_list.md:39
msgid ""
"// Can't take ownership of the tail, because `self` is borrowed;\n"
"            // instead take a reference to the tail\n"
"            // And it's a non-tail recursive call which may cause stack "
"overflow for long lists.\n"
msgstr ""
"// `self`가 빌려온 상태이므로 꼬리(tail)의 소유권을 가질 수 없습니다.\n"
"            // 대신 꼬리에 대한 참조를 가져옵니다.\n"
"            // 그리고 이것은 꼬리 재귀가 아닌 호출이므로 긴 리스트의 경우 스택 오버플로우가 발생할 수 있습니다.\n"

#: src/custom_types/enum/testcase_linked_list.md:43
msgid "// Base Case: An empty list has zero length\n"
msgstr "// 기저 사례(Base Case): 빈 리스트의 길이는 0입니다\n"

#: src/custom_types/enum/testcase_linked_list.md:48
msgid "// Return representation of the list as a (heap allocated) string\n"
msgstr "// 리스트를 (힙에 할당된) 문자열 표현으로 반환합니다\n"

#: src/custom_types/enum/testcase_linked_list.md:52
msgid ""
"// `format!` is similar to `print!`, but returns a heap\n"
"                // allocated string instead of printing to the console\n"
msgstr ""
"// `format!`은 `print!`와 유사하지만, 콘솔에 출력하는 대신\n"
"                // 힙에 할당된 문자열을 반환합니다\n"

#: src/custom_types/enum/testcase_linked_list.md:54 src/generics/impl.md:44
msgid "\"{}, {}\""
msgstr "\"{}, {}\""

#: src/custom_types/enum/testcase_linked_list.md:57
msgid "\"Nil\""
msgstr "\"Nil\""

#: src/custom_types/enum/testcase_linked_list.md:64
msgid "// Create an empty linked list\n"
msgstr "// 빈 연결 리스트를 생성합니다\n"

#: src/custom_types/enum/testcase_linked_list.md:67
msgid "// Prepend some elements\n"
msgstr "// 몇 가지 요소를 앞에 추가합니다\n"

#: src/custom_types/enum/testcase_linked_list.md:72
msgid "// Show the final state of the list\n"
msgstr "// 리스트의 최종 상태를 보여줍니다\n"

#: src/custom_types/enum/testcase_linked_list.md:73
msgid "\"linked list has length: {}\""
msgstr "\"연결 리스트의 길이는 {}입니다\""

#: src/custom_types/enum/testcase_linked_list.md:80
msgid "[`Box`](../../std/box.md) and [methods](../../fn/methods.md)"
msgstr "[`Box`](../../std/box.md)와 [메서드](../../fn/methods.md)"

#: src/custom_types/constants.md:3
msgid ""
"Rust has two different types of constants which can be declared in any scope "
"including global. Both require explicit type annotation:"
msgstr "Rust에는 전역 범위를 포함한 모든 범위에서 선언할 수 있는 두 가지 유형의 상수가 있습니다. 둘 다 명시적인 타입 어노테이션이 필요합니다:"

#: src/custom_types/constants.md:6
msgid "`const`: An unchangeable value (the common case)."
msgstr "`const`: 변경할 수 없는 값 (일반적인 경우)."

#: src/custom_types/constants.md:7
msgid ""
"`static`: A possibly mutable variable with [`'static`](../scope/lifetime/"
"static_lifetime.md) lifetime. The static lifetime is inferred and does not "
"have to be specified. Accessing or modifying a mutable static variable is "
"[`unsafe`](../unsafe.md)."
msgstr "`static`: [`'static`](../scope/lifetime/static_lifetime.md) 라이프타임을 가진, 가변적일 수 있는 변수입니다. static 라이프타임은 추론되므로 명시할 필요는 없습니다. 가변적인 static 변수에 접근하거나 수정하는 것은 [`unsafe`](../unsafe.md)합니다."

#: src/custom_types/constants.md:12
msgid "// Globals are declared outside all other scopes.\n"
msgstr "// 전역 변수는 다른 모든 범위의 바깥에 선언됩니다.\n"

#: src/custom_types/constants.md:13
msgid "\"Rust\""
msgstr "\"러스트\""

#: src/custom_types/constants.md:17
msgid "// Access constant in some function\n"
msgstr "// 어떤 함수 내에서 상수에 접근\n"

#: src/custom_types/constants.md:24
msgid "// Access constant in the main thread\n"
msgstr "// 메인 스레드에서 상수에 접근\n"

#: src/custom_types/constants.md:25
msgid "\"This is {}\""
msgstr "\"이것은 {}입니다\""

#: src/custom_types/constants.md:26
msgid "\"The threshold is {}\""
msgstr "\"임계값은 {}입니다\""

#: src/custom_types/constants.md:27
msgid "\"{} is {}\""
msgstr "\"{}은(는) {}입니다\""

#: src/custom_types/constants.md:27
msgid "\"big\""
msgstr "\"큰\""

#: src/custom_types/constants.md:27
msgid "\"small\""
msgstr "\"작은\""

#: src/custom_types/constants.md:29
msgid "// Error! Cannot modify a `const`.\n"
msgstr "// 에러! `const`는 수정할 수 없습니다.\n"

#: src/custom_types/constants.md:31 src/variable_bindings/scope.md:22
#: src/variable_bindings/declare.md:27 src/variable_bindings/freeze.md:16
#: src/types/cast.md:19 src/types/cast.md:28 src/flow_control/for.md:95
#: src/scope/borrow.md:41 src/scope/borrow/mut.md:52 src/std/vec.md:32
#: src/std/vec.md:45 src/std/hash/hashset.md:48
msgid "// FIXME ^ Comment out this line\n"
msgstr "// FIXME ^ 이 줄을 주석 처리하세요\n"

#: src/custom_types/constants.md:37
msgid ""
"[The `const`/`static` RFC](https://github.com/rust-lang/rfcs/blob/master/"
"text/0246-const-vs-static.md), [`'static` lifetime](../scope/lifetime/"
"static_lifetime.md)"
msgstr "[`const`/`static` RFC](https://github.com/rust-lang/rfcs/blob/master/text/0246-const-vs-static.md), [`'static` 라이프타임](../scope/lifetime/static_lifetime.md)"

#: src/variable_bindings.md:3
msgid ""
"Rust provides type safety via static typing. Variable bindings can be type "
"annotated when declared. However, in most cases, the compiler will be able "
"to infer the type of the variable from the context, heavily reducing the "
"annotation burden."
msgstr "Rust는 정적 타이핑을 통해 타입 안전성을 제공합니다. 변수 바인딩은 선언 시 타입 어노테이션을 할 수 있습니다. 하지만 대부분의 경우, 컴파일러는 문맥으로부터 변수의 타입을 추론할 수 있어 어노테이션의 부담을 크게 줄여줍니다."

msgid "Values (like literals) can be bound to variables, using the `let` binding."
msgstr "값(리터럴 등)은 `let` 바인딩을 사용하여 변수에 바인딩될 수 있습니다."

#: src/variable_bindings.md:16
msgid "// copy `an_integer` into `copied_integer`\n"
msgstr "// `an_integer`를 `copied_integer`로 복사합니다\n"

#: src/variable_bindings.md:19
msgid "\"An integer: {:?}\"
msgstr "\"정수: {:?}\""
msgstr ""

#: src/variable_bindings.md:20
msgid "\"A boolean: {:?}\""
msgstr "\"불리언: {:?}\""

#: src/variable_bindings.md:21
msgid "\"Meet the unit value: {:?}\""
msgstr "\"유닛 값을 만나보세요: {:?}\""

#: src/variable_bindings.md:23
msgid ""
"// The compiler warns about unused variable bindings; these warnings can\n"
"    // be silenced by prefixing the variable name with an underscore\n"
msgstr ""
"// 컴파일러는 사용되지 않는 변수 바인딩에 대해 경고를 보냅니다. 이러한 경고는\n"
"    // 변수 이름 앞에 밑줄을 붙여서 비활성화할 수 있습니다.\n"

#: src/variable_bindings.md:28
msgid ""
"// FIXME ^ Prefix with an underscore to suppress the warning\n"
"    // Please note that warnings may not be shown in a browser\n"
msgstr ""
"// FIXME ^ 경고를 억제하기 위해 밑줄을 접두사로 붙이세요\n"
"    // 브라우저에서는 경고가 표시되지 않을 수 있음에 유의하세요\n"

#: src/variable_bindings/mut.md:3
msgid ""
"Variable bindings are immutable by default, but this can be overridden using "
"the `mut` modifier."
msgstr "변수 바인딩은 기본적으로 불변(immutable)이지만, `mut` 수식어를 사용하여 이를 재정의할 수 있습니다."

#: src/variable_bindings/mut.md:11
msgid "\"Before mutation: {}\""
msgstr "\"변경 전: {}\""

#: src/variable_bindings/mut.md:13
msgid "// Ok\n"
msgstr "// 좋습니다\n"

#: src/variable_bindings/mut.md:16
msgid "\"After mutation: {}\""
msgstr "\"변경 후: {}\""

#: src/variable_bindings/mut.md:18
msgid "// Error! Cannot assign a new value to an immutable variable\n"
msgstr "// 에러! 불변 변수에는 새로운 값을 할당할 수 없습니다\n"

#: src/variable_bindings/mut.md:23
msgid "The compiler will throw a detailed diagnostic about mutability errors."
msgstr "컴파일러는 가변성 에러에 대해 상세한 진단을 제공할 것입니다."

#: src/variable_bindings/scope.md:3
msgid ""
"Variable bindings have a scope, and are constrained to live in a _block_. A "
"block is a collection of statements enclosed by braces `{}`."
msgstr "변수 바인딩은 스코프(범위)를 가지며, _블록_ 내에 거주하도록 제한됩니다. 블록은 중괄호 `{}`로 둘러싸인 문장들의 모음입니다."

#: src/variable_bindings/scope.md:8
msgid "// This binding lives in the main function\n"
msgstr "// 이 바인딩은 메인 함수에 거주합니다\n"

#: src/variable_bindings/scope.md:11
msgid "// This is a block, and has a smaller scope than the main function\n"
msgstr "// 이것은 블록이며, 메인 함수보다 더 작은 스코프를 가집니다\n"

#: src/variable_bindings/scope.md:13
msgid "// This binding only exists in this block\n"
msgstr "// 이 바인딩은 이 블록 내에만 존재합니다\n"

#: src/variable_bindings/scope.md:16
msgid "\"inner short: {}\""
msgstr "\"내부 short: {}\""

#: src/variable_bindings/scope.md:18
msgid "// End of the block\n"
msgstr "// 블록의 끝\n"

#: src/variable_bindings/scope.md:20
msgid "// Error! `short_lived_binding` doesn't exist in this scope\n"
msgstr "// 에러! `short_lived_binding`은 이 스코프에 존재하지 않습니다\n"

#: src/variable_bindings/scope.md:21
msgid "\"outer short: {}\""
msgstr "\"외부 short: {}\""

#: src/variable_bindings/scope.md:24
msgid "\"outer long: {}\""
msgstr "\"외부 long: {}\""

#: src/variable_bindings/scope.md:28
msgid ""
"Also, [variable shadowing](https://en.wikipedia.org/wiki/Variable_shadowing) "
"is allowed."
msgstr "또한, [변수 섀도잉](https://en.wikipedia.org/wiki/Variable_shadowing)이 허용됩니다."

#: src/variable_bindings/scope.md:35
msgid "\"before being shadowed: {}\""
msgstr "\"섀도잉 전: {}\""

#: src/variable_bindings/scope.md:37
msgid "// This binding *shadows* the outer one\n"
msgstr "// 이 바인딩은 외부 바인딩을 *섀도잉*합니다\n"

#: src/variable_bindings/scope.md:38
msgid "\"abc\""
msgstr "\"abc\""

#: src/variable_bindings/scope.md:40
msgid "\"shadowed in inner block: {}\""
msgstr "\"내부 블록에서 섀도잉됨: {}\""

#: src/variable_bindings/scope.md:42
msgid "\"outside inner block: {}\""
msgstr "\"내부 블록 밖: {}\""

#: src/variable_bindings/scope.md:44
msgid "// This binding *shadows* the previous binding\n"
msgstr "// 이 바인딩은 이전 바인딩을 *섀도잉*합니다\n"

#: src/variable_bindings/scope.md:46
msgid "\"shadowed in outer block: {}\""
msgstr "\"외부 블록에서 섀도잉됨: {}\""

#: src/variable_bindings/declare.md:3
msgid ""
"It is possible to declare variable bindings first and initialize them later, "
"but all variable bindings must be initialized before they are used: the "
"compiler forbids use of uninitialized variable bindings, as it would lead to "
"undefined behavior."
msgstr "변수 바인딩을 먼저 선언하고 나중에 초기화하는 것이 가능하지만, 모든 변수 바인딩은 사용되기 전에 초기화되어야 합니다. 컴파일러는 정의되지 않은 동작을 초래할 수 있는 초기화되지 않은 변수 바인딩의 사용을 금지합니다."

#: src/variable_bindings/declare.md:5
msgid ""
"It is not common to declare a variable binding and initialize it later in "
"the function. It is more difficult for a reader to find the initialization "
"when initialization is separated from declaration. It is common to declare "
"and initialize a variable binding near where the variable will be used."
msgstr "변수 바인딩을 선언하고 나중에 함수 내에서 초기화하는 것은 일반적이지 않습니다. 선언과 초기화가 분리되어 있으면 독자가 초기화 지점을 찾기 더 어렵기 때문입니다. 변수가 사용될 위치 근처에서 선언과 초기화를 함께 하는 것이 일반적입니다."

#: src/variable_bindings/declare.md:11
msgid "// Declare a variable binding\n"
msgstr "// 변수 바인딩 선언\n"

#: src/variable_bindings/declare.md:17
msgid "// Initialize the binding\n"
msgstr "// 바인딩 초기화\n"

#: src/variable_bindings/declare.md:21
msgid "\"a binding: {}\""
msgstr "\"바인딩 a: {}\""

#: src/variable_bindings/declare.md:25
msgid "// Error! Use of uninitialized binding\n"
msgstr "// 에러! 초기화되지 않은 바인딩 사용\n"

#: src/variable_bindings/declare.md:26 src/variable_bindings/declare.md:31
msgid "\"another binding: {}\""
msgstr "\"또 다른 바인딩: {}\""

#: src/variable_bindings/freeze.md:3
msgid ""
"When data is bound by the same name immutably, it also _freezes_. _Frozen_ "
"data can't be modified until the immutable binding goes out of scope:"
msgstr "데이터가 동일한 이름으로 불변하게 바인딩되면, 해당 데이터는 _동결(freeze)_됩니다. _동결된_ 데이터는 불변 바인딩이 스코프를 벗어날 때까지 수정할 수 없습니다."

#: src/variable_bindings/freeze.md:11
msgid "// Shadowing by immutable `_mutable_integer`\n"
msgstr "// 불변 `_mutable_integer`에 의한 섀도잉\n"

#: src/variable_bindings/freeze.md:14
msgid "// Error! `_mutable_integer` is frozen in this scope\n"
msgstr "// 에러! `_mutable_integer`는 이 스코프에서 동결되었습니다\n"

#: src/variable_bindings/freeze.md:18
msgid "// `_mutable_integer` goes out of scope\n"
msgstr "// `_mutable_integer`가 스코프를 벗어납니다\n"

#: src/variable_bindings/freeze.md:21
msgid "// Ok! `_mutable_integer` is not frozen in this scope\n"
msgstr "// 좋습니다! `_mutable_integer`는 이 스코프에서 동결되지 않았습니다\n"

#: src/types.md:3
msgid ""
"Rust provides several mechanisms to change or define the type of primitive "
"and user defined types. The following sections cover:"
msgstr "Rust는 기본 타입과 사용자 정의 타입의 타입을 변경하거나 정의하기 위한 여러 메커니즘을 제공합니다. 다음 섹션에서는 다음을 다룹니다:"

#: src/types.md:6
msgid "[Casting](types/cast.md) between primitive types"
msgstr "기본 타입 간의 [형변환(Casting)](types/cast.md)"

#: src/types.md:7
msgid "Specifying the desired type of [literals](types/literals.md)"
msgstr ""

#: src/types.md:8
msgid "Using [type inference](types/inference.md)"
msgstr "[타입 추론(type inference)](types/inference.md) 사용"

#: src/types.md:9
msgid "[Aliasing](types/alias.md) types"
msgstr "타입 [별칭(Aliasing)](types/alias.md)"

#: src/types/cast.md:3
msgid ""
"Rust provides no implicit type conversion (coercion) between primitive "
"types. But, explicit type conversion (casting) can be performed using the "
"`as` keyword."
msgstr "Rust는 기본 타입 간의 암시적 타입 변환(강제)을 제공하지 않습니다. 하지만 `as` 키워드를 사용하여 명시적 타입 변환(캐스팅)을 수행할 수 있습니다."

#: src/types/cast.md:6
msgid ""
"Rules for converting between integral types follow C conventions generally, "
"except in cases where C has undefined behavior. The behavior of all casts "
"between integral types is well defined in Rust."
msgstr "정수 타입 간의 변환 규칙은 일반적으로 C 언어의 관례를 따르지만, C에서 정의되지 않은 동작(undefined behavior)이 발생하는 경우는 예외입니다. Rust에서 정수 타입 간의 모든 캐스팅 동작은 잘 정의되어 있습니다."

#: src/types/cast.md:11
msgid "// Suppress all errors from casts which overflow.\n"
msgstr "// 오버플로우가 발생하는 캐스팅으로 인한 모든 에러를 억제합니다.\n"

#: src/types/cast.md:17
msgid "// Error! No implicit conversion\n"
msgstr "// 에러! 암시적 변환 없음\n"

#: src/types/cast.md:21
msgid "// Explicit conversion\n"
msgstr "// 명시적 변환\n"

#: src/types/cast.md:25
msgid ""
"// Error! There are limitations in conversion rules.\n"
"    // A float cannot be directly converted to a char.\n"
msgstr ""
"// 에러! 변환 규칙에 제한이 있습니다.\n"
"    // 부동 소수점은 문자로 직접 변환할 수 없습니다.\n"

#: src/types/cast.md:30
msgid "\"Casting: {} -> {} -> {}\""
msgstr "\"형변환: {} -> {} -> {}\""

#: src/types/cast.md:32
msgid ""
"// when casting any value to an unsigned type, T,\n"
"    // T::MAX + 1 is added or subtracted until the value\n"
"    // fits into the new type ONLY when the #![allow(overflowing_literals)]\n"
"    // lint is specified like above. Otherwise there will be a compiler "
"error.\n"
msgstr ""
"// 값을 부호 없는 타입 T로 캐스팅할 때, #![allow(overflowing_literals)]\n"
"    // 린트가 위와 같이 지정된 경우에만 값이 새로운 타입에 맞을 때까지\n"
"    // T::MAX + 1을 더하거나 뺍니다. 그렇지 않으면 컴파일 에러가 발생합니다.\n"

#: src/types/cast.md:37
msgid "// 1000 already fits in a u16\n"
msgstr "// 1000은 이미 u16에 들어맞습니다\n"

#: src/types/cast.md:38
msgid "\"1000 as a u16 is: {}\""
msgstr "\"1000을 u16으로 변환하면: {}\""

#: src/types/cast.md:40
msgid ""
"// 1000 - 256 - 256 - 256 = 232\n"
"    // Under the hood, the first 8 least significant bits (LSB) are kept,\n"
"    // while the rest towards the most significant bit (MSB) get truncated.\n"
msgstr ""
"// 1000 - 256 - 256 - 256 = 232\n"
"    // 내부적으로는 첫 8개의 최하위 비트(LSB)는 유지되고,\n"
"    // 최상위 비트(MSB) 쪽의 나머지 비트들은 잘려 나갑니다.\n"

#: src/types/cast.md:43 src/types/cast.md:62
msgid "\"1000 as a u8 is : {}\""
msgstr "\"1000을 u8로 변환하면 : {}\""

#: src/types/cast.md:44
msgid "// -1 + 256 = 255\n"
msgstr "// -1 + 256 = 255\n"

#: src/types/cast.md:45
msgid "\"  -1 as a u8 is : {}\""
msgstr "\"  -1을 u8로 변환하면 : {}\""

#: src/types/cast.md:47
msgid "// For positive numbers, this is the same as the modulus\n"
msgstr "// 양수의 경우, 이는 나머지 연산(modulus)과 동일합니다\n"

#: src/types/cast.md:48
msgid "\"1000 mod 256 is : {}\""
msgstr "\"1000 mod 256은 : {}\""

#: src/types/cast.md:50
msgid ""
"// When casting to a signed type, the (bitwise) result is the same as\n"
"    // first casting to the corresponding unsigned type. If the most "
"significant\n"
"    // bit of that value is 1, then the value is negative.\n"
msgstr ""
"// 부호 있는 타입으로 캐스팅할 때, (비트 단위) 결과는 먼저\n"
"    // 대응하는 부호 없는 타입으로 캐스팅하는 것과 같습니다. 만약 그 값의\n"
"    // 최상위 비트가 1이면, 그 값은 음수입니다.\n"

#: src/types/cast.md:54
msgid "// Unless it already fits, of course.\n"
msgstr "// 물론 이미 들어맞는 경우는 제외합니다.\n"

#: src/types/cast.md:55
msgid "\" 128 as a i16 is: {}\""
msgstr "\" 128을 i16으로 변환하면: {}\""

#: src/types/cast.md:57
msgid ""
"// In boundary case 128 value in 8-bit two's complement representation is "
"-128\n"
msgstr "// 경계 케이스의 경우, 8비트 2의 보수 표현에서 128이라는 값은 -128입니다.\n"

#: src/types/cast.md:58
msgid "\" 128 as a i8 is : {}\""
msgstr "\" 128을 i8로 변환하면 : {}\""

#: src/types/cast.md:60
msgid ""
"// repeating the example above\n"
"    // 1000 as u8 -> 232\n"
msgstr ""
"// 위 예제를 반복합니다\n"
"    // 1000을 u8로 변환 -> 232\n"

#: src/types/cast.md:63
msgid ""
"// and the value of 232 in 8-bit two's complement representation is -24\n"
msgstr "// 그리고 8비트 2의 보수 표현에서 232라는 값은 -24입니다.\n"

#: src/types/cast.md:64
msgid "\" 232 as a i8 is : {}\""
msgstr "\" 232를 i8로 변환하면 : {}\""

#: src/types/cast.md:66
msgid ""
"// Since Rust 1.45, the `as` keyword performs a *saturating cast*\n"
"    // when casting from float to int. If the floating point value exceeds\n"
"    // the upper bound or is less than the lower bound, the returned value\n"
"    // will be equal to the bound crossed.\n"
msgstr ""
"// Rust 1.45부터, 부동 소수점을 정수로 캐스팅할 때 `as` 키워드는\n"
"    // *포화 캐스팅(saturating cast)*을 수행합니다. 부동 소수점 값이\n"
"    // 상한을 초과하거나 하한보다 작으면, 반환되는 값은 해당 경계값이 됩니다.\n"

#: src/types/cast.md:71
msgid "// 300.0 as u8 is 255\n"
msgstr "// 300.0을 u8로 변환하면 255입니다\n"

#: src/types/cast.md:72 src/types/cast.md:83
msgid "\" 300.0 as u8 is : {}\""
msgstr "\" 300.0을 u8로 변환하면 : {}\""

#: src/types/cast.md:73
msgid "// -100.0 as u8 is 0\n"
msgstr "// -100.0을 u8로 변환하면 0입니다\n"

#: src/types/cast.md:74 src/types/cast.md:85
msgid "\"-100.0 as u8 is : {}\""
msgstr "\"-100.0을 u8로 변환하면 : {}\""

#: src/types/cast.md:75 src/types/cast.md:86
msgid "// nan as u8 is 0\n"
msgstr "// nan을 u8로 변환하면 0입니다\n"

#: src/types/cast.md:76 src/types/cast.md:87
msgid "\"   nan as u8 is : {}\""
msgstr "\"   nan을 u8로 변환하면 : {}\""

#: src/types/cast.md:78
msgid ""
"// This behavior incurs a small runtime cost and can be avoided\n"
"    // with unsafe methods, however the results might overflow and\n"
"    // return **unsound values**. Use these methods wisely:\n"
msgstr ""
"// 이러한 동작은 약간의 런타임 비용을 발생시키며, unsafe 메서드를 사용하여\n"
"    // 피할 수 있습니다. 하지만 결과가 오버플로우되어 **불건전한 값(unsound values)**을\n"
"    // 반환할 수 있습니다. 이러한 메서드들은 현명하게 사용하세요:\n"

#: src/types/cast.md:82
msgid "// 300.0 as u8 is 44\n"
msgstr "// 300.0을 u8로 변환하면 44입니다\n"

#: src/types/cast.md:84
msgid "// -100.0 as u8 is 156\n"
msgstr "// -100.0을 u8로 변환하면 156입니다\n"

#: src/types/literals.md:3
msgid ""
"Numeric literals can be type annotated by adding the type as a suffix. As an "
"example, to specify that the literal `42` should have the type `i32`, write "
"`42i32`."
msgstr "숫자 리터럴은 타입 이름을 접미사로 추가하여 타입 어노테이션을 할 수 있습니다. 예를 들어, 리터럴 `42`가 `i32` 타입을 가져야 함을 지정하려면 `42i32`라고 씁니다."

#: src/types/literals.md:6
msgid ""
"The type of unsuffixed numeric literals will depend on how they are used. If "
"no constraint exists, the compiler will use `i32` for integers, and `f64` "
"for floating-point numbers."
msgstr "접미사가 없는 숫자 리터럴의 타입은 어떻게 사용되느냐에 따라 달라집니다. 아무런 제약이 없다면 컴파일러는 정수에 대해서는 `i32`를, 부동 소수점 숫자에 대해서는 `f64`를 사용합니다."

#: src/types/literals.md:12
msgid "// Suffixed literals, their types are known at initialization\n"
msgstr "// 접미사가 붙은 리터럴은 초기화 시 그 타입을 알 수 있습니다.\n"

#: src/types/literals.md:17
msgid "// Unsuffixed literals, their types depend on how they are used\n"
msgstr "// 접미사가 없는 리터럴의 타입은 어떻게 사용되느냐에 따라 달라집니다.\n"

#: src/types/literals.md:21
msgid "// `size_of_val` returns the size of a variable in bytes\n"
msgstr "// `size_of_val`은 변수의 크기를 바이트 단위로 반환합니다.\n"

#: src/types/literals.md:22
msgid "\"size of `x` in bytes: {}\""
msgstr "`x`의 바이트 크기: {}"

#: src/types/literals.md:23
msgid "\"size of `y` in bytes: {}\""
msgstr "`y`의 바이트 크기: {}"

#: src/types/literals.md:24
msgid "\"size of `z` in bytes: {}\""
msgstr "`z`의 바이트 크기: {}"

#: src/types/literals.md:25
msgid "\"size of `i` in bytes: {}\""
msgstr "`i`의 바이트 크기: {}"

#: src/types/literals.md:26
msgid "\"size of `f` in bytes: {}\""
msgstr "`f`의 바이트 크기: {}"

#: src/types/literals.md:30
msgid ""
"There are some concepts used in the previous code that haven't been "
"explained yet, here's a brief explanation for the impatient readers:"
msgstr "앞선 코드에서 아직 설명되지 않은 몇 가지 개념이 사용되었습니다. 성급한 독자들을 위한 간단한 설명은 다음과 같습니다:"

#: src/types/literals.md:33
msgid ""
"`std::mem::size_of_val` is a function, but called with its _full path_. Code "
"can be split in logical units called _modules_. In this case, the "
"`size_of_val` function is defined in the `mem` module, and the `mem` module "
"is defined in the `std` _crate_. For more details, see [modules](../mod.md) "
"and [crates](../crates.md)."
msgstr "`std::mem::size_of_val`은 함수이지만, _전체 경로(full path)_를 사용하여 호출되었습니다. 코드는 _모듈_이라고 불리는 논리적 단위로 나뉠 수 있습니다. 이 경우, `size_of_val` 함수는 `mem` 모듈에 정의되어 있고, `mem` 모듈은 `std` _크레이트_에 정의되어 있습니다. 자세한 내용은 [모듈](../mod.md) 및 [크레이트](../crates.md)를 참조하세요."

#: src/types/inference.md:3
msgid ""
"The type inference engine is pretty smart. It does more than looking at the "
"type of the value expression during an initialization. It also looks at how "
"the variable is used afterwards to infer its type. Here's an advanced "
"example of type inference:"
msgstr "타입 추론 엔진은 꽤 똑똑합니다. 초기화 중에 값 표현식의 타입을 살펴보는 것 이상의 일을 합니다. 또한 변수가 이후에 어떻게 사용되는지를 보고 타입을 추론합니다. 다음은 타입 추론의 심화 예시입니다:"

#: src/types/inference.md:10
msgid ""
"// Because of the annotation, the compiler knows that `elem` has type u8.\n"
msgstr "// 어노테이션 덕분에 컴파일러는 `elem`이 u8 타입임을 압니다.\n"

#: src/types/inference.md:13
msgid "// Create an empty vector (a growable array).\n"
msgstr "// 빈 벡터(가변 크기 배열)를 생성합니다.\n"

#: src/types/inference.md:15
msgid ""
"// At this point the compiler doesn't know the exact type of `vec`, it\n"
"    // just knows that it's a vector of something (`Vec<_>`).\n"
msgstr ""
"// 이 시점에서 컴파일러는 `vec`의 정확한 타입을 알지 못하며,\n"
"    // 단지 무언가의 벡터(`Vec<_>`)라는 것만 압니다.\n"

#: src/types/inference.md:18
msgid "// Insert `elem` in the vector.\n"
msgstr "// 벡터에 `elem`을 삽입합니다.\n"

#: src/types/inference.md:20
msgid ""
"// Aha! Now the compiler knows that `vec` is a vector of `u8`s (`Vec<u8>`)\n"
"    // TODO ^ Try commenting out the `vec.push(elem)` line\n"
msgstr ""
"// 아하! 이제 컴파일러는 `vec`이 `u8`들의 벡터(`Vec<u8>`)임을 압니다.\n"
"    // TODO ^ `vec.push(elem)` 줄을 주석 처리해 보세요\n"

#: src/types/inference.md:27
msgid ""
"No type annotation of variables was needed, the compiler is happy and so is "
"the programmer!"
msgstr "변수의 타입 어노테이션이 필요하지 않았습니다. 컴파일러도 만족하고 프로그래머도 행복합니다!"

#: src/types/alias.md:3
msgid ""
"The `type` statement can be used to give a new name to an existing type. "
"Types must have `UpperCamelCase` names, or the compiler will raise a "
"warning. The exception to this rule are the primitive types: `usize`, `f32`, "
"etc."
msgstr "`type` 문을 사용하면 기존 타입에 새로운 이름을 부여할 수 있습니다. 타입 이름은 `UpperCamelCase`여야 하며, 그렇지 않으면 컴파일러가 경고를 보냅니다. 이 규칙의 예외는 기본 타입인 `usize`, `f32` 등입니다."

#: src/types/alias.md:8
msgid "// `NanoSecond`, `Inch`, and `U64` are new names for `u64`.\n"
msgstr "// `NanoSecond`, `Inch`, `U64`는 `u64`를 가리키는 새로운 이름입니다.\n"

#: src/types/alias.md:14
msgid "// `NanoSecond` = `Inch` = `U64` = `u64`.\n"
msgstr "// `NanoSecond` = `Inch` = `U64` = `u64`입니다.\n"

#: src/types/alias.md:18
msgid ""
"// Note that type aliases *don't* provide any extra type safety, because\n"
"    // aliases are *not* new types\n"
msgstr ""
"// 타입 별칭은 새로운 타입이 아니기 때문에, 추가적인 타입 안전성을\n"
"    // 제공하지 않는다는 점에 유의하세요.\n"

#: src/types/alias.md:20
msgid "\"{} nanoseconds + {} inches = {} unit?\""
msgstr "\"{} 나노초 + {} 인치 = {} 유닛?\""

#: src/types/alias.md:27
msgid ""
"The main use of aliases is to reduce boilerplate; for example the "
"`io::Result<T>` type is an alias for the `Result<T, io::Error>` type."
msgstr "별칭의 주요 용도는 보일러플레이트(boilerplate)를 줄이는 것입니다. 예를 들어 `io::Result<T>` 타입은 `Result<T, io::Error>` 타입의 별칭입니다."

#: src/types/alias.md:32
msgid "[Attributes](../attribute.md)"
msgstr "[속성](../attribute.md)"

#: src/conversion.md:3
msgid ""
"Primitive types can be converted to each other through [casting](types/"
"cast.md)."
msgstr "기본 타입들은 [캐스팅(casting)](types/cast.md)을 통해 서로 변환될 수 있습니다."

#: src/conversion.md:5
msgid ""
"Rust addresses conversion between custom types (i.e., `struct` and `enum`) "
"by the use of [traits](trait.md). The generic conversions will use the "
"[`From`](https://doc.rust-lang.org/std/convert/trait.From.html) and [`Into`]"
"(https://doc.rust-lang.org/std/convert/trait.Into.html) traits. However "
"there are more specific ones for the more common cases, in particular when "
"converting to and from `String`s."
msgstr "Rust는 [트레이트(traits)](trait.md)를 사용하여 사용자 정의 타입(예: `struct`, `enum`) 간의 변환을 처리합니다. 범용 변환에는 [`From`](https://doc.rust-lang.org/std/convert/trait.From.html)과 [`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) 트레이트를 사용합니다. 하지만 더 흔한 경우, 특히 `String`과의 상호 변환을 위한 더 구체적인 트레이트들이 존재합니다."

#: src/conversion/from_into.md:3
msgid ""
"The [`From`](https://doc.rust-lang.org/std/convert/trait.From.html) and "
"[`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) traits are "
"inherently linked, and this is actually part of its implementation. If you "
"are able to convert type A from type B, then it should be easy to believe "
"that we should be able to convert type B to type A."
msgstr "[`From`](https://doc.rust-lang.org/std/convert/trait.From.html)과 [`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) 트레이트는 본질적으로 연결되어 있으며, 이는 실제로 구현의 일부입니다. 만약 타입 B로부터 타입 A를 만들 수 있다면(`From`), 타입 B를 타입 A로 변환할 수 있다(`Into`)는 것을 쉽게 알 수 있습니다."

#: src/conversion/from_into.md:7
msgid "`From`"
msgstr "`From`"

#: src/conversion/from_into.md:9
msgid ""
"The [`From`](https://doc.rust-lang.org/std/convert/trait.From.html) trait "
"allows for a type to define how to create itself from another type, hence "
"providing a very simple mechanism for converting between several types. "
"There are numerous implementations of this trait within the standard library "
"for conversion of primitive and common types."
msgstr "[`From`](https://doc.rust-lang.org/std/convert/trait.From.html) 트레이트는 한 타입이 다른 타입으로부터 자신을 생성하는 방법을 정의할 수 있게 하여, 여러 타입 간의 변환을 위한 매우 단순한 메커니즘을 제공합니다. 표준 라이브러리에는 기본 타입 및 일반적인 타입의 변환을 위해 이 트레이트가 수없이 많이 구현되어 있습니다."

#: src/conversion/from_into.md:14
msgid "For example we can easily convert a `str` into a `String`"
msgstr "예를 들어, `str`을 `String`으로 쉽게 변환할 수 있습니다."

#: src/conversion/from_into.md:21
msgid "We can do something similar for defining a conversion for our own type."
msgstr "우리는 자신의 타입에 대한 변환을 정의하기 위해 유사한 작업을 수행할 수 있습니다."

#: src/conversion/from_into.md:39 src/conversion/from_into.md:68
#: src/conversion/from_into.md:98
msgid "\"My number is {:?}\""
msgstr "\"제 숫자는 {:?}입니다\""

#: src/conversion/from_into.md:43
msgid "`Into`"
msgstr "`Into`"

#: src/conversion/from_into.md:45
msgid ""
"The [`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) trait is "
"simply the reciprocal of the `From` trait. It defines how to convert a type "
"into another type."
msgstr "[`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) 트레이트는 단순히 `From` 트레이트의 반대입니다. 이는 한 타입을 다른 타입으로 변환하는 방법을 정의합니다."

#: src/conversion/from_into.md:48
msgid ""
"Calling `into()` typically requires us to specify the result type as the "
"compiler is unable to determine this most of the time."
msgstr "`into()`를 호출할 때는 일반적으로 결과 타입을 지정해야 합니다. 대부분의 경우 컴파일러가 이를 결정할 수 없기 때문입니다."

#: src/conversion/from_into.md:66
msgid "// Try removing the type annotation\n"
msgstr "// 타입 어노테이션을 제거해 보세요\n"

#: src/conversion/from_into.md:72
msgid "`From` and `Into` are interchangeable"
msgstr "`From`과 `Into`는 상호 교환 가능합니다"

#: src/conversion/from_into.md:74
msgid ""
"`From` and `Into` are designed to be complementary. We do not need to "
"provide an implementation for both traits. If you have implemented the "
"`From` trait for your type, `Into` will call it when necessary. Note, "
"however, that the converse is not true: implementing `Into` for your type "
"will not automatically provide it with an implementation of `From`."
msgstr "`From`과 `Into`는 상호 보완적으로 설계되었습니다. 두 트레이트 모두에 대해 구현을 제공할 필요는 없습니다. 만약 자신의 타입에 대해 `From` 트레이트를 구현했다면, `Into`는 필요할 때 이를 호출할 것입니다. 하지만 그 반대는 성립하지 않음에 유의하세요. 즉, 자신의 타입에 대해 `Into`를 구현한다고 해서 `From` 구현이 자동으로 제공되지는 않습니다."

#: src/conversion/from_into.md:86
msgid "// Define `From`\n"
msgstr "// `From` 정의\n"

#: src/conversion/from_into.md:96
msgid "// use `Into`\n"
msgstr "// `Into` 사용\n"

#: src/conversion/try_from_try_into.md:3
msgid ""
"Similar to [`From` and `Into`](from_into.html), [`TryFrom`](https://doc.rust-"
"lang.org/std/convert/trait.TryFrom.html) and [`TryInto`](https://doc.rust-"
"lang.org/std/convert/trait.TryInto.html) are generic traits for converting "
"between types. Unlike `From`/`Into`, the `TryFrom`/`TryInto` traits are used "
"for fallible conversions, and as such, return [`Result`](https://doc.rust-"
"lang.org/std/result/enum.Result.html)s."
msgstr "[`From`과 `Into`](from_into.html)와 유사하게, [`TryFrom`](https://doc.rust-lang.org/std/convert/trait.TryFrom.html)과 [`TryInto`](https://doc.rust-lang.org/std/convert/trait.TryInto.html)는 타입 간 변환을 위한 제네릭 트레이트입니다. `From`/`Into`와 달리, `TryFrom`/`TryInto` 트레이트는 실패할 가능성이 있는 변환에 사용되며, 따라서 [`Result`](https://doc.rust-lang.org/std/result/enum.Result.html)를 반환합니다."

#: src/conversion/try_from_try_into.md:33
msgid "// TryFrom\n"
msgstr "// TryFrom\n"

#: src/conversion/try_from_try_into.md:38
msgid "// TryInto\n"
msgstr "// TryInto\n"

#: src/conversion/string.md:1
msgid "To and from Strings"
msgstr "문자열 상호 변환"

#: src/conversion/string.md:3
msgid "Converting to String"
msgstr "문자열로 변환하기"

#: src/conversion/string.md:5
msgid ""
"To convert any type to a `String` is as simple as implementing the "
"[`ToString`](https://doc.rust-lang.org/std/string/trait.ToString.html) trait "
"for the type. Rather than doing so directly, you should implement the "
"[`fmt::Display`](https://doc.rust-lang.org/std/fmt/trait.Display.html) trait "
"which automatically provides [`ToString`](https://doc.rust-lang.org/std/"
"string/trait.ToString.html) and also allows printing the type as discussed "
"in the section on [`print!`](../hello/print.md)."
msgstr "어떤 타입을 `String`으로 변환하는 것은 해당 타입에 대해 [`ToString`](https://doc.rust-lang.org/std/string/trait.ToString.html) 트레이트를 구현하는 것만큼 간단합니다. 직접 구현하기보다는 [`fmt::Display`](https://doc.rust-lang.org/std/fmt/trait.Display.html) 트레이트를 구현하는 것이 좋습니다. 이는 자동으로 [`ToString`](https://doc.rust-lang.org/std/string/trait.ToString.html)을 제공할 뿐만 아니라, [`print!`](../hello/print.md) 섹션에서 다룬 것처럼 해당 타입을 출력할 수 있게 해줍니다."

#: src/conversion/string.md:19
msgid "\"Circle of radius {}\""
msgstr "\"반지름이 {}인 원\""

#: src/conversion/string.md:29
msgid "Parsing a String"
msgstr "문자열 파싱하기"

#: src/conversion/string.md:31
msgid ""
"It's useful to convert strings into many types, but one of the more common "
"string operations is to convert them from string to number. The idiomatic "
"approach to this is to use the [`parse`](https://doc.rust-lang.org/std/"
"primitive.str.html#method.parse) function and either to arrange for type "
"inference or to specify the type to parse using the 'turbofish' syntax. Both "
"alternatives are shown in the following example."
msgstr "문자열을 여러 타입으로 변환하는 것은 유용하지만, 가장 흔한 작업 중 하나는 문자열을 숫자로 변환하는 것입니다. 이에 대한 관용적인 방법은 [`parse`](https://doc.rust-lang.org/std/primitive.str.html#method.parse) 함수를 사용하는 것이며, 타입 추론을 이용하거나 'turbofish' 구문을 사용하여 파싱할 타입을 지정할 수 있습니다. 다음 예제에 두 가지 방식이 모두 나와 있습니다."

#: src/conversion/string.md:37
msgid ""
"This will convert the string into the type specified as long as the "
"[`FromStr`](https://doc.rust-lang.org/std/str/trait.FromStr.html) trait is "
"implemented for that type. This is implemented for numerous types within the "
"standard library."
msgstr "해당 타입에 대해 [`FromStr`](https://doc.rust-lang.org/std/str/trait.FromStr.html) 트레이트가 구현되어 있다면 문자열을 지정된 타입으로 변환합니다. 표준 라이브러리의 수많은 타입에 대해 이 트레이트가 구현되어 있습니다."

#: src/conversion/string.md:43 src/std_misc/process/wait.md:10
msgid "\"5\""
msgstr "\"5\""

#: src/conversion/string.md:44 src/error/result.md:33 src/error/result.md:68
#: src/error/result/result_map.md:42 src/error/result/result_map.md:75
#: src/error/result/result_alias.md:36 src/error/result/early_returns.md:36
#: src/error/result/enter_question_mark.md:34
#: src/error/result/enter_question_mark.md:67
msgid "\"10\""
msgstr ""

#: src/conversion/string.md:47
msgid "\"Sum: {:?}\""
msgstr "\"합계: {:?}\""

#: src/conversion/string.md:51
msgid ""
"To obtain this functionality on a user defined type simply implement the "
"[`FromStr`](https://doc.rust-lang.org/std/str/trait.FromStr.html) trait for "
"that type."
msgstr "사용자 정의 타입에서 이 기능을 사용하려면 해당 타입에 대해 [`FromStr`](https://doc.rust-lang.org/std/str/trait.FromStr.html) 트레이트를 구현하기만 하면 됩니다."

#: src/conversion/string.md:74
msgid "\"    3 \""
msgstr "\"    3 \""

#: src/expression.md:3
msgid "A Rust program is (mostly) made up of a series of statements:"
msgstr "Rust 프로그램은 (대부분) 일련의 문장(statements)으로 구성됩니다:"

#: src/expression.md:7
msgid ""
"// statement\n"
"    // statement\n"
"    // statement\n"
msgstr ""
"// 문장\n"
"    // 문장\n"
"    // 문장\n"

#: src/expression.md:13
msgid ""
"There are a few kinds of statements in Rust. The most common two are "
"declaring a variable binding, and using a `;` with an expression:"
msgstr "Rust에는 몇 가지 종류의 문장이 있습니다. 가장 흔한 두 가지는 변수 바인딩을 선언하는 것과 표현식에 `;`를 사용하는 것입니다:"

#: src/expression.md:18
msgid "// variable binding\n"
msgstr "// 변수 바인딩\n"

#: src/expression.md:21
msgid "// expression;\n"
msgstr "// 표현식;\n"

#: src/expression.md:28
msgid ""
"Blocks are expressions too, so they can be used as values in assignments. "
"The last expression in the block will be assigned to the place expression "
"such as a local variable. However, if the last expression of the block ends "
"with a semicolon, the return value will be `()`."
msgstr "블록도 표현식이므로 할당 시 값으로 사용될 수 있습니다. 블록의 마지막 표현식은 로컬 변수와 같은 장소 표현식(place expression)에 할당됩니다. 하지만 블록의 마지막 표현식이 세미콜론으로 끝나면 반환 값은 `()`가 됩니다."

#: src/expression.md:41
msgid "// This expression will be assigned to `y`\n"
msgstr "// 이 표현식은 `y`에 할당됩니다\n"

#: src/expression.md:46
msgid ""
"// The semicolon suppresses this expression and `()` is assigned to `z`\n"
msgstr "// 세미콜론이 이 표현식을 억제하여 `z`에는 `()`가 할당됩니다\n"

#: src/expression.md:50
msgid "\"x is {:?}\""
msgstr "\"x는 {:?}입니다\""

#: src/expression.md:51
msgid "\"y is {:?}\""
msgstr "\"y는 {:?}입니다\""

#: src/expression.md:52
msgid "\"z is {:?}\""
msgstr "\"z는 {:?}입니다\""

#: src/flow_control.md:3
msgid ""
"An integral part of any programming language are ways to modify control "
"flow: `if`/`else`, `for`, and others. Let's talk about them in Rust."
msgstr "모든 프로그래밍 언어의 필수적인 부분은 제어 흐름을 수정하는 방법입니다: `if`/`else`, `for` 등. Rust에서의 제어 흐름에 대해 이야기해 봅시다."

#: src/flow_control/if_else.md:3
msgid ""
"Branching with `if`\\-`else` is similar to other languages. Unlike many of "
"them, the boolean condition doesn't need to be surrounded by parentheses, "
"and each condition is followed by a block. `if`\\-`else` conditionals are "
"expressions, and, all branches must return the same type."
msgstr "`if`\\-`else`를 사용한 분기는 다른 언어와 유사합니다. 많은 언어와 달리 불리언 조건은 괄호로 둘러쌀 필요가 없으며, 각 조건 뒤에는 블록이 옵니다. `if`\\-`else` 조건문은 표현식이며, 모든 분기는 동일한 타입을 반환해야 합니다."

#: src/flow_control/if_else.md:13
msgid "\"{} is negative\""
msgstr "\"{}은(는) 음수입니다\""

#: src/flow_control/if_else.md:15
msgid "\"{} is positive\""
msgstr "\"{}은(는) 양수입니다\""

#: src/flow_control/if_else.md:17
msgid "\"{} is zero\""
msgstr "\"{}은(는) 0입니다\""

#: src/flow_control/if_else.md:22
msgid "\", and is a small number, increase ten-fold\""
msgstr "\", 그리고 작은 수이므로 10배 증가시킵니다\""

#: src/flow_control/if_else.md:24
msgid "// This expression returns an `i32`.\n"
msgstr "// 이 표현식은 `i32`를 반환합니다.\n"

#: src/flow_control/if_else.md:27
msgid "\", and is a big number, halve the number\""
msgstr "\", 그리고 큰 수이므로 반으로 나눕니다\""

#: src/flow_control/if_else.md:29
msgid "// This expression must return an `i32` as well.\n"
msgstr "// 이 표현식 또한 `i32`를 반환해야 합니다.\n"

#: src/flow_control/if_else.md:31
msgid "// TODO ^ Try suppressing this expression with a semicolon.\n"
msgstr "// TODO ^ 세미콜론을 사용하여 이 표현식을 억제해 보세요.\n"

#: src/flow_control/if_else.md:33
msgid ""
"//   ^ Don't forget to put a semicolon here! All `let` bindings need it.\n"
msgstr "//   ^ 여기에 세미콜론을 넣는 것을 잊지 마세요! 모든 `let` 바인딩에 필요합니다.\n"

#: src/flow_control/if_else.md:35 src/flow_control/match.md:35
msgid "\"{} -> {}\""
msgstr "\"{} -> {}\""

#: src/flow_control/loop.md:3
msgid "Rust provides a `loop` keyword to indicate an infinite loop."
msgstr "Rust는 무한 루프를 나타내기 위해 `loop` 키워드를 제공합니다."

#: src/flow_control/loop.md:5
msgid ""
"The `break` statement can be used to exit a loop at anytime, whereas the "
"`continue` statement can be used to skip the rest of the iteration and start "
"a new one."
msgstr "`break` 문은 언제든지 루프를 종료하는 데 사용할 수 있으며, `continue` 문은 나머지 반복을 건너뛰고 새로운 반복을 시작하는 데 사용될 수 있습니다."

#: src/flow_control/loop.md:13
msgid "\"Let's count until infinity!\""
msgstr "\"무한대까지 세어봅시다!\""

#: src/flow_control/loop.md:15
msgid "// Infinite loop\n"
msgstr "// 무한 루프\n"

#: src/flow_control/loop.md:20
msgid "\"three\""
msgstr "\"3\""

#: src/flow_control/loop.md:22
msgid "// Skip the rest of this iteration\n"
msgstr "// 이번 반복의 나머지를 건너뜁니다\n"

#: src/flow_control/loop.md:29
msgid "\"OK, that's enough\""
msgstr "\"좋아요, 그만하면 됐습니다\""

#: src/flow_control/loop.md:31
msgid "// Exit this loop\n"
msgstr "// 이 루프를 종료합니다\n"

#: src/flow_control/loop/nested.md:3
msgid ""
"It's possible to `break` or `continue` outer loops when dealing with nested "
"loops. In these cases, the loops must be annotated with some `'label`, and "
"the label must be passed to the `break`/`continue` statement."
msgstr "중첩 루프를 다룰 때 외부 루프를 `break`하거나 `continue`하는 것이 가능합니다. 이 경우 루프에는 어떤 `'label`을 붙여야 하며, 해당 레이블은 `break`/`continue` 문에 전달되어야 합니다."

#: src/flow_control/loop/nested.md:12
msgid "\"Entered the outer loop\""
msgstr "\"외부 루프에 진입했습니다\""

#: src/flow_control/loop/nested.md:15
msgid "\"Entered the inner loop\""
msgstr "\"내부 루프에 진입했습니다\""

#: src/flow_control/loop/nested.md:17
msgid ""
"// This would break only the inner loop\n"
"            //break;\n"
msgstr ""
"// 이것은 내부 루프만 종료시킵니다\n"
"            //break;\n"

#: src/flow_control/loop/nested.md:20
msgid "// This breaks the outer loop\n"
msgstr "// 이것은 외부 루프를 종료시킵니다\n"

#: src/flow_control/loop/nested.md:24
msgid "\"This point will never be reached\""
msgstr "\"이 지점에는 결코 도달하지 않습니다\""

#: src/flow_control/loop/nested.md:27
msgid "\"Exited the outer loop\""
msgstr "\"외부 루프에서 나갔습니다\""

#: src/flow_control/loop/return.md:3
msgid ""
"One of the uses of a `loop` is to retry an operation until it succeeds. If "
"the operation returns a value though, you might need to pass it to the rest "
msgstr "성공할 때까지 작업을 재시도하는 것이 `loop`의 용도 중 하나입니다. 만약 작업이 값을 반환한다면, 이를 코드의 나머지 부분으로 전달해야 할 수도 있습니다."
"of the code: put it after the `break`, and it will be returned by the `loop` "
"expression."
msgstr ""

#: src/flow_control/while.md:3
msgid ""
"The `while` keyword can be used to run a loop while a condition is true."
msgstr "`while` 키워드는 조건이 참(true)인 동안 루프를 실행하는 데 사용될 수 있습니다."

#: src/flow_control/while.md:5
msgid ""
"Let's write the infamous [FizzBuzz](https://en.wikipedia.org/wiki/Fizz_buzz) "
"using a `while` loop."
msgstr ""
"악명 높은 [FizzBuzz](https://en.wikipedia.org/wiki/Fizz_buzz)를 `while` 루프를 사용하여 작성해 봅시다."

#: src/flow_control/while.md:9
msgid "// A counter variable\n"
msgstr "// 카운터 변수\n"

#: src/flow_control/while.md:12
msgid "// Loop while `n` is less than 101\n"
msgstr "// `n`이 101보다 작은 동안 루프 실행\n"

#: src/flow_control/while.md:15 src/flow_control/for.md:17
#: src/flow_control/for.md:37 src/fn.md:34
msgid "\"fizzbuzz\""
msgstr ""

#: src/flow_control/while.md:17 src/flow_control/for.md:19
#: src/flow_control/for.md:39 src/fn.md:36
msgid "\"fizz\""
msgstr ""

#: src/flow_control/while.md:19 src/flow_control/for.md:21
#: src/flow_control/for.md:41 src/fn.md:38
msgid "\"buzz\""
msgstr ""

#: src/flow_control/while.md:24
msgid "// Increment counter\n"
msgstr "// 카운터 증가\n"

#: src/flow_control/for.md:1
msgid "for loops"
msgstr "for 루프"

#: src/flow_control/for.md:5
msgid ""
"The `for in` construct can be used to iterate through an `Iterator`. One of "
"the easiest ways to create an iterator is to use the range notation `a..b`. "
"This yields values from `a` (inclusive) to `b` (exclusive) in steps of one."
msgstr ""
"`for in` 구문은 `Iterator`를 통해 반복하는 데 사용될 수 있습니다. 이터레이터를 만드는 가장 쉬운 방법 중 하나는 범위 표기법 `a..b`를 사용하는 것입니다. 이는 `a`(포함)부터 `b`(미포함)까지의 값을 1씩 증가시키며 생성합니다."

#: src/flow_control/for.md:10
msgid "Let's write FizzBuzz using `for` instead of `while`."
msgstr "`while` 대신 `for`를 사용하여 FizzBuzz를 작성해 봅시다."

#: src/flow_control/for.md:14 src/flow_control/for.md:34
msgid "// `n` will take the values: 1, 2, ..., 100 in each iteration\n"
msgstr "// 각 반복에서 `n`은 1, 2, ..., 100의 값을 갖게 됩니다.\n"

#: src/flow_control/for.md:29
msgid ""
"Alternatively, `a..=b` can be used for a range that is inclusive on both "
"ends. The above can be written as:"
msgstr ""
"또는 양쪽 끝을 모두 포함하는 범위에는 `a..=b`를 사용할 수 있습니다. 위의 코드는 다음과 같이 작성될 수 있습니다:"

#: src/flow_control/for.md:49
msgid "for and iterators"
msgstr "for와 이터레이터"

#: src/flow_control/for.md:51
msgid ""
"The `for in` construct is able to interact with an `Iterator` in several "
"ways. As discussed in the section on the [Iterator](../trait/iter.md) trait, "
"by default the `for` loop will apply the `into_iter` function to the "
"collection. However, this is not the only means of converting collections "
"into iterators."
msgstr ""
"`for in` 구문은 여러 방식으로 `Iterator`와 상호작용할 수 있습니다. [Iterator](../trait/iter.md) 트레이트 섹션에서 다룬 것처럼, 기본적으로 `for` 루프는 컬렉션에 `into_iter` 함수를 적용합니다. 하지만 이것이 컬렉션을 이터레이터로 변환하는 유일한 방법은 아닙니다."

#: src/flow_control/for.md:56
msgid ""
"`into_iter`, `iter` and `iter_mut` all handle the conversion of a collection "
"into an iterator in different ways, by providing different views on the data "
"within."
msgstr ""
"`into_iter`, `iter`, `iter_mut`은 모두 내부 데이터에 대해 서로 다른 뷰를 제공함으로써 컬렉션을 이터레이터로 변환하는 작업을 서로 다른 방식으로 처리합니다."

#: src/flow_control/for.md:60
msgid ""
"`iter` - This borrows each element of the collection through each iteration. "
"Thus leaving the collection untouched and available for reuse after the loop."
msgstr ""
"`iter` - 매 반복마다 컬렉션의 각 요소를 빌려옵니다. 따라서 컬렉션은 수정되지 않은 상태로 유지되며 루프 이후에도 재사용할 수 있습니다."

#: src/flow_control/for.md:65 src/flow_control/for.md:85
#: src/flow_control/for.md:104
msgid "\"Frank\""
msgstr "\"프랭크\""

#: src/flow_control/for.md:65 src/flow_control/for.md:69
#: src/flow_control/for.md:85 src/flow_control/for.md:89
#: src/flow_control/for.md:104 src/flow_control/for.md:108
msgid "\"Ferris\""
msgstr "\"페리스\""

#: src/flow_control/for.md:69 src/flow_control/for.md:89
#: src/flow_control/for.md:108
msgid "\"There is a rustacean among us!\""
msgstr "\"우리 중에 러스타시안(rustacean)이 있습니다!\""

#: src/flow_control/for.md:70
msgid "// TODO ^ Try deleting the & and matching just \"Ferris\"\n"
msgstr "// TODO ^ &를 삭제하고 그냥 \"Ferris\"와 매칭해 보세요\n"

#: src/flow_control/for.md:71 src/flow_control/for.md:90
msgid "\"Hello {}\""
msgstr "\"안녕 {}\""

#: src/flow_control/for.md:75 src/flow_control/for.md:94
#: src/flow_control/for.md:113
msgid "\"names: {:?}\""
msgstr "\"이름들: {:?}\""

#: src/flow_control/for.md:79
msgid ""
"`into_iter` - This consumes the collection so that on each iteration the "
"exact data is provided. Once the collection has been consumed it is no "
"longer available for reuse as it has been 'moved' within the loop."
msgstr ""
"`into_iter` - 컬렉션을 소비(consume)하여 각 반복마다 실제 데이터를 제공합니다. 컬렉션이 소비되면 루프 내에서 '이동(moved)'된 것이므로 더 이상 재사용할 수 없습니다."

#: src/flow_control/for.md:99
msgid ""
"`iter_mut` - This mutably borrows each element of the collection, allowing "
"for the collection to be modified in place."
msgstr ""
"`iter_mut` - 컬렉션의 각 요소를 가변적으로 빌려와서, 컬렉션을 제자리에서 수정할 수 있게 합니다."

#: src/flow_control/for.md:109
msgid "\"Hello\""
msgstr "\"안녕\""

#: src/flow_control/for.md:117
msgid ""
"In the above snippets note the type of `match` branch, that is the key "
"difference in the types of iteration. The difference in type then of course "
"implies differing actions that are able to be performed."
msgstr ""
"위의 스니펫에서 `match` 분기의 타입에 주목하세요. 이것이 반복 방식의 핵심적인 차이점입니다. 타입의 차이는 물론 수행할 수 있는 작업의 차이를 의미합니다."

#: src/flow_control/for.md:123
msgid "[Iterator](../trait/iter.md)"
msgstr "[Iterator](../trait/iter.md)"

#: src/flow_control/match.md:3
msgid ""
"Rust provides pattern matching via the `match` keyword, which can be used "
"like a C `switch`. The first matching arm is evaluated and all possible "
"values must be covered."
msgstr ""
"Rust는 `match` 키워드를 통해 패턴 매칭을 제공하며, 이는 C의 `switch`처럼 사용될 수 있습니다. 첫 번째로 매칭되는 팔(arm)이 실행되며, 가능한 모든 값을 다뤄야 합니다."

#: src/flow_control/match.md:10
msgid "// TODO ^ Try different values for `number`\n"
msgstr "// TODO ^ `number`에 다른 값을 넣어보세요\n"

#: src/flow_control/match.md:12
msgid "\"Tell me about {}\""
msgstr "\"{}에 대해 알려주세요\""

#: src/flow_control/match.md:14
msgid "// Match a single value\n"
msgstr "// 단일 값 매칭\n"

#: src/flow_control/match.md:15
msgid "\"One!\""
msgstr "\"1입니다!\""

#: src/flow_control/match.md:16
msgid "// Match several values\n"
msgstr "// 여러 값 매칭\n"

#: src/flow_control/match.md:17
msgid "\"This is a prime\""
msgstr "\"이것은 소수입니다\""

#: src/flow_control/match.md:18
msgid ""
"// TODO ^ Try adding 13 to the list of prime values\n"
"        // Match an inclusive range\n"
msgstr ""
"// TODO ^ 소수 목록에 13을 추가해 보세요\n"
"        // 포함 범위를 매칭\n"

#: src/flow_control/match.md:20
msgid "\"A teen\""
msgstr "\"10대입니다\""

#: src/flow_control/match.md:21
msgid "// Handle the rest of cases\n"
msgstr "// 나머지 경우 처리\n"

#: src/flow_control/match.md:22
msgid "\"Ain't special\""
msgstr "\"특별할 것 없습니다\""

#: src/flow_control/match.md:23
msgid "// TODO ^ Try commenting out this catch-all arm\n"
msgstr "// TODO ^ 이 모든 경우를 처리하는 팔(catch-all arm)을 주석 처리해 보세요\n"

#: src/flow_control/match.md:27
msgid "// Match is an expression too\n"
msgstr "// Match도 표현식입니다\n"

#: src/flow_control/match.md:29
msgid "// The arms of a match must cover all the possible values\n"
msgstr "// match의 팔들은 가능한 모든 값을 다뤄야 합니다\n"

#: src/flow_control/match.md:32
msgid "// TODO ^ Try commenting out one of these arms\n"
msgstr "// TODO ^ 이 팔들 중 하나를 주석 처리해 보세요\n"

#: src/flow_control/match/destructuring.md:3
msgid "A `match` block can destructure items in a variety of ways."
msgstr "`match` 블록은 다양한 방식으로 아이템을 구조 분해(destructure)할 수 있습니다."

#: src/flow_control/match/destructuring.md:5
msgid "[Destructuring Tuples](destructuring/destructure_tuple.md)"
msgstr "[튜플 구조 분해](destructuring/destructure_tuple.md)"

#: src/flow_control/match/destructuring.md:6
msgid "[Destructuring Arrays and Slices](destructuring/destructure_slice.md)"
msgstr "[배열과 슬라이스 구조 분해](destructuring/destructure_slice.md)"

#: src/flow_control/match/destructuring.md:7
msgid "[Destructuring Enums](destructuring/destructure_enum.md)"
msgstr "[열거형 구조 분해](destructuring/destructure_enum.md)"

#: src/flow_control/match/destructuring.md:8
msgid "[Destructuring Pointers](destructuring/destructure_pointers.md)"
msgstr "[포인터 구조 분해](destructuring/destructure_pointers.md)"

#: src/flow_control/match/destructuring.md:9
msgid "[Destructuring Structures](destructuring/destructure_structures.md)"
msgstr "[구조체 구조 분해](destructuring/destructure_structures.md)"

#: src/flow_control/match/destructuring.md:19
msgid ""
"[The Rust Reference for Destructuring](https://doc.rust-lang.org/reference/"
"patterns.html#r-patterns.destructure)"
msgstr "[구조 분해에 관한 Rust 레퍼런스](https://doc.rust-lang.org/reference/patterns.html#r-patterns.destructure)"

#: src/flow_control/match/destructuring/destructure_tuple.md:3
msgid "Tuples can be destructured in a `match` as follows:"
msgstr "튜플은 `match`에서 다음과 같이 구조 분해될 수 있습니다:"

#: src/flow_control/match/destructuring/destructure_tuple.md:8
msgid "// TODO ^ Try different values for `triple`\n"
msgstr "// TODO ^ `triple`에 다른 값을 넣어보세요\n"

#: src/flow_control/match/destructuring/destructure_tuple.md:10
msgid "\"Tell me about {:?}\""
msgstr "\"{:?}에 대해 알려주세요\""

#: src/flow_control/match/destructuring/destructure_tuple.md:11
msgid "// Match can be used to destructure a tuple\n"
msgstr "// match를 사용하여 튜플을 구조 분해할 수 있습니다\n"

#: src/flow_control/match/destructuring/destructure_tuple.md:13
msgid "// Destructure the second and third elements\n"
msgstr "// 두 번째와 세 번째 요소를 구조 분해합니다\n"

#: src/flow_control/match/destructuring/destructure_tuple.md:14
msgid "\"First is `0`, `y` is {:?}, and `z` is {:?}\""
msgstr "\"첫 번째는 `0`이고, `y`는 {:?}, `z`는 {:?}입니다\""

#: src/flow_control/match/destructuring/destructure_tuple.md:15
msgid "\"First is `1` and the rest doesn't matter\""
msgstr "\"첫 번째는 `1`이고 나머지는 상관없습니다\""

#: src/flow_control/match/destructuring/destructure_tuple.md:16
msgid "\"last is `2` and the rest doesn't matter\""
msgstr "\"마지막은 `2`이고 나머지는 상관없습니다\""

#: src/flow_control/match/destructuring/destructure_tuple.md:17
msgid "\"First is `3`, last is `4`, and the rest doesn't matter\""
msgstr "\"첫 번째는 `3`, 마지막은 `4`이며 나머지는 상관없습니다\""

#: src/flow_control/match/destructuring/destructure_tuple.md:18
msgid "// `..` can be used to ignore the rest of the tuple\n"
msgstr "// `..`을 사용하여 튜플의 나머지를 무시할 수 있습니다\n"

#: src/flow_control/match/destructuring/destructure_tuple.md:19
msgid "\"It doesn't matter what they are\""
msgstr "\"그것들이 무엇이든 상관없습니다\""

#: src/flow_control/match/destructuring/destructure_tuple.md:20
msgid "// `_` means don't bind the value to a variable\n"
msgstr "// `_`는 값을 변수에 바인딩하지 않음을 의미합니다\n"

#: src/flow_control/match/destructuring/destructure_tuple.md:27
msgid "[Tuples](../../../primitives/tuples.md)"
msgstr "[튜플](../../../primitives/tuples.md)"

#: src/flow_control/match/destructuring/destructure_slice.md:3
msgid "Like tuples, arrays and slices can be destructured this way:"
msgstr "튜플과 마찬가지로, 배열과 슬라이스도 다음과 같은 방식으로 구조 분해될 수 있습니다:"

#: src/flow_control/match/destructuring/destructure_slice.md:7
msgid "// Try changing the values in the array, or make it a slice!\n"
msgstr "// 배열의 값을 변경하거나 슬라이스로 만들어 보세요!\n"

#: src/flow_control/match/destructuring/destructure_slice.md:11
msgid ""
"// Binds the second and the third elements to the respective variables\n"
msgstr "// 두 번째와 세 번째 요소를 각각의 변수에 바인딩합니다\n"

#: src/flow_control/match/destructuring/destructure_slice.md:13
msgid "\"array[0] = 0, array[1] = {}, array[2] = {}\""
msgstr "\"array[0] = 0, array[1] = {}, array[2] = {}\""

#: src/flow_control/match/destructuring/destructure_slice.md:15
msgid "// Single values can be ignored with _\n"
msgstr "// 단일 값은 _로 무시할 수 있습니다\n"

#: src/flow_control/match/destructuring/destructure_slice.md:17
msgid "\"array[0] = 1, array[2] = {} and array[1] was ignored\""
msgstr "\"array[0] = 1, array[2] = {} 이고 array[1]은 무시되었습니다\""

#: src/flow_control/match/destructuring/destructure_slice.md:21
msgid "// You can also bind some and ignore the rest\n"
msgstr "// 일부만 바인딩하고 나머지는 무시할 수도 있습니다\n"

#: src/flow_control/match/destructuring/destructure_slice.md:23
msgid "\"array[0] = -1, array[1] = {} and all the other ones were ignored\""
msgstr "\"array[0] = -1, array[1] = {} 이고 다른 모든 것들은 무시되었습니다\""

#: src/flow_control/match/destructuring/destructure_slice.md:26
msgid ""
"// The code below would not compile\n"
"        // [-1, second] => ...\n"
msgstr ""
"// 아래 코드는 컴파일되지 않습니다\n"
"        // [-1, second] => ...\n"

#: src/flow_control/match/destructuring/destructure_slice.md:29
msgid ""
"// Or store them in another array/slice (the type depends on\n"
"        // that of the value that is being matched against)\n"
msgstr ""
"// 또는 다른 배열/슬라이스에 저장할 수도 있습니다 (타입은 매칭되는 값의 타입에 따라 달라집니다)\n"

#: src/flow_control/match/destructuring/destructure_slice.md:32
msgid "\"array[0] = 3, array[1] = {} and the other elements were {:?}\""
msgstr "\"array[0] = 3, array[1] = {} 이고 다른 요소들은 {:?}입니다\""

#: src/flow_control/match/destructuring/destructure_slice.md:36
msgid ""
"// Combining these patterns, we can, for example, bind the first and\n"
"        // last values, and store the rest of them in a single array\n"
msgstr ""
"// 이러한 패턴들을 결합하여, 예를 들어 첫 번째와 마지막 값을 바인딩하고 나머지는 하나의 배열에 저장할 수 있습니다\n"

#: src/flow_control/match/destructuring/destructure_slice.md:39
msgid "\"array[0] = {}, middle = {:?}, array[2] = {}\""
msgstr "\"array[0] = {}, middle = {:?}, array[2] = {}\""

#: src/flow_control/match/destructuring/destructure_slice.md:48
msgid ""
"[Arrays and Slices](../../../primitives/array.md) and [Binding](../"
"binding.md) for `@` sigil"
msgstr ""
"[배열과 슬라이스](../../../primitives/array.md) 그리고 `@` 기호를 사용한 [바인딩](../binding.md)"

#: src/flow_control/match/destructuring/destructure_enum.md:3
msgid "An `enum` is destructured similarly:"
msgstr "`enum`도 비슷하게 구조 분해됩니다:"

#: src/flow_control/match/destructuring/destructure_enum.md:6
msgid ""
"// `allow` required to silence warnings because only\n"
"// one variant is used.\n"
msgstr ""
"// 단 하나의 변체만 사용되므로 경고를 억제하기 위해 `allow`가 필요합니다.\n"

#: src/flow_control/match/destructuring/destructure_enum.md:10
msgid "// These 3 are specified solely by their name.\n"
msgstr "// 이 세 가지는 오직 이름으로만 지정됩니다.\n"

#: src/flow_control/match/destructuring/destructure_enum.md:14
msgid "// These likewise tie `u32` tuples to different names: color models.\n"
msgstr ""
"// 이들은 마찬가지로 `u32` 튜플을 서로 다른 이름(컬러 모델)에 연결합니다.\n"

#: src/flow_control/match/destructuring/destructure_enum.md:24
msgid "// TODO ^ Try different variants for `color`\n"
msgstr "// TODO ^ `color`에 다른 변체들을 넣어보세요\n"

#: src/flow_control/match/destructuring/destructure_enum.md:26
msgid "\"What color is it?\""
msgstr "\"이것은 무슨 색인가요?\""

#: src/flow_control/match/destructuring/destructure_enum.md:27
msgid "// An `enum` can be destructured using a `match`.\n"
msgstr "// `match`를 사용하여 `enum`을 구조 분해할 수 있습니다.\n"

#: src/flow_control/match/destructuring/destructure_enum.md:29
msgid "\"The color is Red!\""
msgstr "\"빨간색입니다!\""

#: src/flow_control/match/destructuring/destructure_enum.md:30
msgid "\"The color is Blue!\""
msgstr "\"파란색입니다!\""

#: src/flow_control/match/destructuring/destructure_enum.md:31
msgid "\"The color is Green!\""
msgstr "\"초록색입니다!\""

#: src/flow_control/match/destructuring/destructure_enum.md:33
msgid "\"Red: {}, green: {}, and blue: {}!\""
msgstr "\"빨강: {}, 초록: {}, 파랑: {}!\""

#: src/flow_control/match/destructuring/destructure_enum.md:35
msgid "\"Hue: {}, saturation: {}, value: {}!\""
msgstr "\"색상: {}, 채도: {}, 명도: {}!\""

#: src/flow_control/match/destructuring/destructure_enum.md:37
msgid "\"Hue: {}, saturation: {}, lightness: {}!\""
msgstr "\"색상: {}, 채도: {}, 밝기: {}!\""

#: src/flow_control/match/destructuring/destructure_enum.md:39
msgid "\"Cyan: {}, magenta: {}, yellow: {}!\""
msgstr "\"청록: {}, 자주: {}, 노랑: {}!\""

#: src/flow_control/match/destructuring/destructure_enum.md:41
msgid "\"Cyan: {}, magenta: {}, yellow: {}, key (black): {}!\""
msgstr "\"청록: {}, 자주: {}, 노랑: {}, 검정: {}!\""

#: src/flow_control/match/destructuring/destructure_enum.md:43
msgid "// Don't need another arm because all variants have been examined\n"
msgstr "// 모든 변체를 검사했으므로 다른 팔(arm)은 필요하지 않습니다.\n"

#: src/flow_control/match/destructuring/destructure_enum.md:50
msgid ""
"[`#[allow(...)]`](../../../attribute/unused.md), [color models](https://"
"en.wikipedia.org/wiki/Color_model) and [`enum`](../../../custom_types/"
"enum.md)"
msgstr "[`#[allow(...)]`](../../../attribute/unused.md), [컬러 모델](https://en.wikipedia.org/wiki/Color_model) 및 [`enum`](../../../custom_types/enum.md)"

#: src/flow_control/match/destructuring/destructure_pointers.md:3
msgid ""
"For pointers, a distinction needs to be made between destructuring and "
"dereferencing as they are different concepts which are used differently from "
"languages like C/C++."
msgstr "포인터의 경우, 구조 분해(destructuring)와 역참조(dereferencing)를 구분해야 합니다. 이들은 C/C++와 같은 언어와는 다르게 사용되는 서로 다른 개념이기 때문입니다."

#: src/flow_control/match/destructuring/destructure_pointers.md:7
msgid "Dereferencing uses `*`"
msgstr "역참조는 `*`를 사용합니다"

#: src/flow_control/match/destructuring/destructure_pointers.md:8
msgid "Destructuring uses `&`, `ref`, and `ref mut`"
msgstr "구조 분해는 `&`, `ref`, `ref mut`을 사용합니다"

#: src/flow_control/match/destructuring/destructure_pointers.md:12
msgid ""
"// Assign a reference of type `i32`. The `&` signifies there\n"
"    // is a reference being assigned.\n"
msgstr "// `i32` 타입의 참조를 할당합니다. `&`는 참조가 할당되고 있음을 나타냅니다.\n"

#: src/flow_control/match/destructuring/destructure_pointers.md:17
msgid ""
"// If `reference` is pattern matched against `&val`, it results\n"
"        // in a comparison like:\n"
"        // `&i32`\n"
"        // `&val`\n"
"        // ^ We see that if the matching `&`s are dropped, then the `i32`\n"
"        // should be assigned to `val`.\n"
msgstr ""
"// 만약 `reference`를 `&val`에 대해 패턴 매칭하면, 다음과 같은 비교 결과가 됩니다:\n"
"// `&i32`\n"
"// `&val`\n"
"// ^ 매칭되는 `&`들을 떼어내면, `i32`가 `val`에 할당되어야 함을 알 수 있습니다.\n"

#: src/flow_control/match/destructuring/destructure_pointers.md:23
msgid "\"Got a value via destructuring: {:?}\""
msgstr "\"구조 분해를 통해 값을 얻었습니다: {:?}\""

#: src/flow_control/match/destructuring/destructure_pointers.md:26
msgid "// To avoid the `&`, you dereference before matching.\n"
msgstr "// `&`를 피하려면, 매칭하기 전에 역참조를 수행합니다.\n"

#: src/flow_control/match/destructuring/destructure_pointers.md:28
msgid "\"Got a value via dereferencing: {:?}\""
msgstr "\"역참조를 통해 값을 얻었습니다: {:?}\""

#: src/flow_control/match/destructuring/destructure_pointers.md:31
msgid ""
"// What if you don't start with a reference? `reference` was a `&`\n"
"    // because the right side was already a reference. This is not\n"
"    // a reference because the right side is not one.\n"
msgstr ""
"// 참조로 시작하지 않는다면 어떨까요? `reference`는 오른쪽이 이미\n"
"// 참조였기 때문에 `&`였습니다. 이것은 오른쪽이 참조가 아니기 때문에\n"
"// 참조가 아닙니다.\n"

#: src/flow_control/match/destructuring/destructure_pointers.md:36
msgid ""
"// Rust provides `ref` for exactly this purpose. It modifies the\n"
"    // assignment so that a reference is created for the element; this\n"
"    // reference is assigned.\n"
msgstr ""
"// Rust는 정확히 이 목적을 위해 `ref`를 제공합니다. 이는 할당 방식을\n"
"// 수정하여 요소에 대한 참조가 생성되도록 하며, 이 참조가 할당됩니다.\n"

#: src/flow_control/match/destructuring/destructure_pointers.md:41
msgid ""
"// Accordingly, by defining 2 values without references, references\n"
"    // can be retrieved via `ref` and `ref mut`.\n"
msgstr "// 따라서, 참조가 없는 두 값을 정의함으로써, `ref`와 `ref mut`를 통해 참조를 가져올 수 있습니다.\n"

#: src/flow_control/match/destructuring/destructure_pointers.md:46
msgid "// Use `ref` keyword to create a reference.\n"
msgstr "// 참조를 생성하려면 `ref` 키워드를 사용합니다.\n"

#: src/flow_control/match/destructuring/destructure_pointers.md:48
msgid "\"Got a reference to a value: {:?}\""
msgstr "\"값에 대한 참조를 얻었습니다: {:?}\""

#: src/flow_control/match/destructuring/destructure_pointers.md:51
msgid "// Use `ref mut` similarly.\n"
msgstr "// `ref mut`도 비슷하게 사용합니다.\n"

#: src/flow_control/match/destructuring/destructure_pointers.md:54
msgid ""
"// Got a reference. Gotta dereference it before we can\n"
"            // add anything to it.\n"
msgstr ""
"// 참조를 얻었습니다. 여기에 무언가를 더하기 전에\n"
"// 역참조를 해야 합니다.\n"

#: src/flow_control/match/destructuring/destructure_pointers.md:57
msgid "\"We added 10. `mut_value`: {:?}\""
msgstr "\"10을 더했습니다. `mut_value`: {:?}\""

#: src/flow_control/match/destructuring/destructure_pointers.md:65
msgid "[The ref pattern](../../../scope/borrow/ref.md)"
msgstr "[ref 패턴](../../../scope/borrow/ref.md)"

#: src/flow_control/match/destructuring/destructure_structures.md:3
msgid "Similarly, a `struct` can be destructured as shown:"
msgstr "마찬가지로, `struct`는 다음과 같이 구조 분해될 수 있습니다:"

#: src/flow_control/match/destructuring/destructure_structures.md:12
msgid "// Try changing the values in the struct to see what happens\n"
msgstr "// 구조체의 값을 변경하여 어떤 일이 일어나는지 확인해 보세요\n"

#: src/flow_control/match/destructuring/destructure_structures.md:16
msgid "\"First of x is 1, b = {},  y = {} \""
msgstr "\"x의 첫 번째는 1이고, b = {}, y = {} 입니다\""

#: src/flow_control/match/destructuring/destructure_structures.md:18
msgid ""
"// you can destructure structs and rename the variables,\n"
"        // the order is not important\n"
msgstr "// 구조체를 구조 분해하고 변수 이름을 바꿀 수 있으며, 순서는 중요하지 않습니다\n"

#: src/flow_control/match/destructuring/destructure_structures.md:20
msgid "\"y is 2, i = {:?}\""
msgstr "\"y는 2이고, i = {:?}입니다\""

#: src/flow_control/match/destructuring/destructure_structures.md:22
msgid "// and you can also ignore some variables:\n"
msgstr "// 그리고 일부 변수를 무시할 수도 있습니다:\n"

#: src/flow_control/match/destructuring/destructure_structures.md:23
msgid "\"y = {}, we don't care about x\""
msgstr "\"y = {}이며, x는 신경 쓰지 않습니다\""

#: src/flow_control/match/destructuring/destructure_structures.md:24
msgid ""
"// this will give an error: pattern does not mention field `x`\n"
"        //Foo { y } => println!(\"y = {}\", y),\n"
msgstr ""
"// 이것은 에러를 발생시킵니다: 패턴에 `x` 필드가 언급되지 않았습니다\n"
"//Foo { y } => println!(\"y = {}\", y),\n"

#: src/flow_control/match/destructuring/destructure_structures.md:30
msgid "// You do not need a match block to destructure structs:\n"
msgstr "// 구조체를 구조 분해하기 위해 반드시 match 블록이 필요한 것은 아닙니다:\n"

#: src/flow_control/match/destructuring/destructure_structures.md:32
msgid "\"Outside: x0 = {x0:?}, y0 = {y0}\""
msgstr "\"외부: x0 = {x0:?}, y0 = {y0}\""

#: src/flow_control/match/destructuring/destructure_structures.md:34
msgid "// Destructuring works with nested structs as well:\n"
msgstr "// 구조 분해는 중첩된 구조체에서도 작동합니다:\n"

#: src/flow_control/match/destructuring/destructure_structures.md:41
msgid "\"Nested: nested_x = {nested_x:?}, nested_y = {nested_y:?}\""
msgstr "\"중첩됨: nested_x = {nested_x:?}, nested_y = {nested_y:?}\""

#: src/flow_control/match/destructuring/destructure_structures.md:47
msgid "[Structs](../../../custom_types/structs.md)"
msgstr "[구조체](../../../custom_types/structs.md)"

#: src/flow_control/match/guard.md:3
msgid "A `match` _guard_ can be added to filter the arm."
msgstr "매치 팔(arm)을 필터링하기 위해 `match` _가드(guard)_를 추가할 수 있습니다."

#: src/flow_control/match/guard.md:14
msgid "// ^ TODO try different values for `temperature`\n"
msgstr "// ^ TODO `temperature`에 다른 값을 시도해 보세요\n"

#: src/flow_control/match/guard.md:17
msgid "\"{}C is above 30 Celsius\""
msgstr "\"{}C는 섭씨 30도 초과입니다\""

#: src/flow_control/match/guard.md:18
msgid "// The `if condition` part ^ is a guard\n"
msgstr "// `if 조건` 부분 ^ 이 가드입니다\n"

#: src/flow_control/match/guard.md:19
msgid "\"{}C is equal to or below 30 Celsius\""
msgstr "\"{}C는 섭씨 30도 이하입니다\""

#: src/flow_control/match/guard.md:21
msgid "\"{}F is above 86 Fahrenheit\""
msgstr "\"{}F는 화씨 86도 초과입니다\""

#: src/flow_control/match/guard.md:22
msgid "\"{}F is equal to or below 86 Fahrenheit\""
msgstr "\"{}F는 화씨 86도 이하입니다\""

#: src/flow_control/match/guard.md:27
msgid ""
"Note that the compiler won't take guard conditions into account when "
"checking if all patterns are covered by the match expression."
msgstr "컴파일러는 매치 표현식이 모든 패턴을 다루고 있는지 확인할 때 가드 조건을 고려하지 않는다는 점에 유의하세요."

#: src/flow_control/match/guard.md:35
msgid "\"Zero\""
msgstr "\"0\""

#: src/flow_control/match/guard.md:36
msgid "\"Greater than zero\""
msgstr "\"0보다 큼\""

#: src/flow_control/match/guard.md:37
msgid ""
"// _ => unreachable!(\"Should never happen.\"),\n"
"        // TODO ^ uncomment to fix compilation\n"
msgstr ""
"// _ => unreachable!(\"절대 일어날 수 없는 일입니다.\"),\n"
"// TODO ^ 컴파일을 수정하려면 주석을 해제하세요\n"

#: src/flow_control/match/guard.md:45
msgid ""
"[Tuples](../../primitives/tuples.md) [Enums](../../custom_types/enum.md)"
msgstr "[튜플](../../primitives/tuples.md) [열거형](../../custom_types/enum.md)"

#: src/flow_control/match/binding.md:3
msgid ""
"Indirectly accessing a variable makes it impossible to branch and use that "
"variable without re-binding. `match` provides the `@` sigil for binding "
"values to names:"
msgstr "변수에 간접적으로 접근하면 재바인딩 없이 해당 변수를 분기하고 사용하는 것이 불가능합니다. `match`는 값을 이름에 바인딩하기 위한 `@` 기호를 제공합니다:"

#: src/flow_control/match/binding.md:8
msgid "// A function `age` which returns a `u32`.\n"
msgstr "// `u32`를 반환하는 `age` 함수.\n"

#: src/flow_control/match/binding.md:14
msgid "\"Tell me what type of person you are\""
msgstr "\"당신이 어떤 종류의 사람인지 말해주세요\""

#: src/flow_control/match/binding.md:17
msgid "\"I haven't celebrated my first birthday yet\""
msgstr "\"아직 첫 번째 생일을 맞이하지 않았습니다\""

#: src/flow_control/match/binding.md:18
msgid ""
"// Could `match` 1 ..= 12 directly but then what age\n"
"        // would the child be?\n"
"        // Could `match` n and use an `if` guard, but would\n"
"        // not contribute to exhaustiveness checks.\n"
"        // (Although in this case that would not matter since\n"
"        // a \"catch-all\" pattern is present at the bottom)\n"
"        // Instead, bind to `n` for the sequence of 1 ..= 12.\n"
"        // Now the age can be reported.\n"
msgstr ""
"// 1 ..= 12를 직접 `match`할 수 있지만, 그러면\n"
"// 아이의 나이가 몇 살인지 알 수 있을까요?\n"
"// n을 `match`하고 `if` 가드를 사용할 수 있지만,\n"
"// 이는 철저함(exhaustiveness) 검사에 기여하지 않습니다.\n"
"// (비록 이 경우에는 하단에 \"catch-all\" 패턴이 있어 상관없지만요)\n"
"// 대신, 1 ..= 12 시퀀스에 대해 `n`에 바인딩합니다.\n"
"// 이제 나이를 보고할 수 있습니다.\n"

#: src/flow_control/match/binding.md:26
msgid "\"I'm a child of age {:?}\""
msgstr "\"저는 {:?}살인 어린이입니다\""

#: src/flow_control/match/binding.md:27 src/flow_control/match/binding.md:29
msgid "\"I'm a teen of age {:?}\""
msgstr "\"저는 {:?}살인 청소년입니다\""

#: src/flow_control/match/binding.md:28
msgid "// A similar binding can be done when matching several values.\n"
msgstr "// 여러 값을 매칭할 때도 유사한 바인딩을 수행할 수 있습니다.\n"

#: src/flow_control/match/binding.md:30
msgid "// Nothing bound. Return the result.\n"
msgstr "// 바인딩된 것이 없습니다. 결과를 반환합니다.\n"

#: src/flow_control/match/binding.md:31
msgid "\"I'm an old person of age {:?}\""
msgstr "\"저는 {:?}살인 어르신입니다\""

#: src/flow_control/match/binding.md:36
msgid ""
"You can also use binding to \"destructure\" `enum` variants, such as "
"`Option`:"
msgstr "또한 `Option`과 같은 `enum` 변체를 \"구조 분해\"하기 위해 바인딩을 사용할 수 있습니다:"

#: src/flow_control/match/binding.md:45
msgid ""
"// Got `Some` variant, match if its value, bound to `n`,\n"
"        // is equal to 42.\n"
"        // Could also use `Some(42)` and print `\"The Answer: 42!\"`\n"
"        // but that would require changing `42` in 2 spots should\n"
"        // you ever wish to change it.\n"
"        // Could also use `Some(n) if n == 42` and print `\"The Answer: {n}!"
"\"`\n"
"        // but that would not contribute to exhaustiveness checks.\n"
"        // (Although in this case that would not matter since\n"
"        // the next arm is a \"catch-all\" pattern)\n"
msgstr ""
"// `Some` 변체를 얻었을 때, `n`에 바인딩된 그 값이\n"
"// 42와 같은지 매칭합니다.\n"
"// `Some(42)`를 사용하여 `\"정답: 42!\"`를 출력할 수도 있지만,\n"
"// 그러면 나중에 값을 바꾸고 싶을 때 두 군데를 수정해야 합니다.\n"
"// `Some(n) if n == 42`를 사용하여 `\"정답: {n}!\"`를 출력할 수도 있지만,\n"
"// 이는 철저함 검사에 기여하지 않습니다.\n"
"// (비록 이 경우에는 다음 팔이 \"catch-all\" 패턴이라 상관없지만요)\n"

#: src/flow_control/match/binding.md:54
msgid "\"The Answer: {}!\""
msgstr "\"정답: {}!\""

#: src/flow_control/match/binding.md:55
msgid "// Match any other number.\n"
msgstr "// 다른 모든 숫자 매칭.\n"

#: src/flow_control/match/binding.md:56
msgid "\"Not interesting... {}\""
msgstr "\"흥미롭지 않네요... {}\""

#: src/flow_control/match/binding.md:57
msgid "// Match anything else (`None` variant).\n"
msgstr "// 그 외의 모든 경우(`None` 변체) 매칭.\n"

#: src/flow_control/match/binding.md:65
msgid ""
"[`functions`](../../fn.md), [`enums`](../../custom_types/enum.md) and "
"[`Option`](../../std/option.md)"
msgstr "[`함수`](../../fn.md), [`열거형`](../../custom_types/enum.md) 그리고 [`Option`](../../std/option.md)"

#: src/flow_control/if_let.md:3
msgid ""
"For some use cases, when matching enums, `match` is awkward. For example:"
msgstr "어떤 경우에는 열거형을 매칭할 때 `match`가 어색할 수 있습니다. 예를 들어:"

#: src/flow_control/if_let.md:6 src/flow_control/while_let.md:7
#: src/flow_control/while_let.md:35
msgid "// Make `optional` of type `Option<i32>`\n"
msgstr "// `Option<i32>` 타입의 `optional` 생성\n"

#: src/flow_control/if_let.md:10
msgid "\"This is a really long string and `{:?}`\""
msgstr "\"이것은 정말 긴 문자열이며 `{:?}`입니다\""

#: src/flow_control/if_let.md:12
msgid ""
"// ^ Required because `match` is exhaustive. Doesn't it seem\n"
"    // like wasted space?\n"
msgstr ""
"// ^ `match`는 철저해야(exhaustive) 하기 때문에 필요합니다. 공간 낭비처럼\n"
"// 보이진 않나요?\n"

#: src/flow_control/if_let.md:18
msgid ""
"`if let` is cleaner for this use case and in addition allows various failure "
"options to be specified:"
msgstr "이런 경우 `if let`이 더 깔끔하며, 추가로 다양한 실패 옵션을 지정할 수 있습니다:"

#: src/flow_control/if_let.md:23
msgid "// All have type `Option<i32>`\n"
msgstr "// 모두 `Option<i32>` 타입입니다\n"

#: src/flow_control/if_let.md:28
msgid ""
"// The `if let` construct reads: \"if `let` destructures `number` into\n"
"    // `Some(i)`, evaluate the block (`{}`).\n"
msgstr ""
"// `if let` 구문은 다음과 같이 읽힙니다: \"만약 `let`이 `number`를\n"
"// `Some(i)`로 구조 분해한다면, 블록(`{}`)을 실행하라.\"\n"

#: src/flow_control/if_let.md:31 src/flow_control/if_let.md:36
#: src/flow_control/if_let.md:46
msgid "\"Matched {:?}!\""
msgstr "\"{:?}가 매칭되었습니다!\""

#: src/flow_control/if_let.md:34
msgid "// If you need to specify a failure, use an else:\n"
msgstr "// 실패한 경우를 지정해야 한다면, else를 사용하세요:\n"

#: src/flow_control/if_let.md:38
msgid "// Destructure failed. Change to the failure case.\n"
msgstr "// 구조 분해에 실패했습니다. 실패 사례로 전환합니다.\n"

#: src/flow_control/if_let.md:39 src/flow_control/if_let.md:50
msgid "\"Didn't match a number. Let's go with a letter!\""
msgstr "\"숫자와 매칭되지 않았습니다. 문자로 해봅시다!\""

#: src/flow_control/if_let.md:42
msgid "// Provide an altered failing condition.\n"
msgstr "// 변경된 실패 조건을 제공합니다.\n"

#: src/flow_control/if_let.md:47
msgid ""
"// Destructure failed. Evaluate an `else if` condition to see if the\n"
"    // alternate failure branch should be taken:\n"
msgstr ""
"// 구조 분해에 실패했습니다. 다른 실패 분기를 타야 하는지\n"
"// `else if` 조건을 평가합니다:\n"

#: src/flow_control/if_let.md:52
msgid "// The condition evaluated false. This branch is the default:\n"
msgstr "// 조건이 거짓(false)으로 평가되었습니다. 이 분기가 기본입니다:\n"

#: src/flow_control/if_let.md:53
msgid "\"I don't like letters. Let's go with an emoticon :)!\""
msgstr "\"문자는 별로예요. 이모티콘 :)으로 가봅시다!\""

#: src/flow_control/if_let.md:58
msgid "In the same way, `if let` can be used to match any enum value:"
msgstr "같은 방식으로, `if let`은 모든 열거형 값을 매칭하는 데 사용될 수 있습니다:"

#: src/flow_control/if_let.md:61
msgid "// Our example enum\n"
msgstr "// 예제 열거형\n"

#: src/flow_control/if_let.md:69
msgid "// Create example variables\n"
msgstr "// 예제 변수 생성\n"

#: src/flow_control/if_let.md:74 src/flow_control/if_let.md:110
msgid "// Variable a matches Foo::Bar\n"
msgstr "// 변수 a는 Foo::Bar와 매칭됩니다\n"

#: src/flow_control/if_let.md:76 src/flow_control/if_let.md:113
msgid "\"a is foobar\""
msgstr "\"a는 foobar입니다\""

#: src/flow_control/if_let.md:79
msgid ""
"// Variable b does not match Foo::Bar\n"
"    // So this will print nothing\n"
msgstr ""
"// 변수 b는 Foo::Bar와 매칭되지 않습니다\n"
"// 따라서 아무것도 출력되지 않습니다\n"

#: src/flow_control/if_let.md:82
msgid "\"b is foobar\""
msgstr "\"b는 foobar입니다\""

#: src/flow_control/if_let.md:85
msgid ""
"// Variable c matches Foo::Qux which has a value\n"
"    // Similar to Some() in the previous example\n"
msgstr ""
"// 변수 c는 값을 가진 Foo::Qux와 매칭됩니다\n"
"// 앞선 예제의 Some()과 유사합니다\n"

#: src/flow_control/if_let.md:88
msgid "\"c is {}\""
msgstr "\"c는 {}입니다\""

#: src/flow_control/if_let.md:91
msgid "// Binding also works with `if let`\n"
msgstr "// 바인딩은 `if let`에서도 작동합니다\n"

#: src/flow_control/if_let.md:93
msgid "\"c is one hundred\""
msgstr "\"c는 100입니다\""

#: src/flow_control/if_let.md:98
msgid ""
"Another benefit is that `if let` allows us to match non-parameterized enum "
"variants. This is true even in cases where the enum doesn't implement or "
"derive `PartialEq`. In such cases `if Foo::Bar == a` would fail to compile, "
"because instances of the enum cannot be equated, however `if let` will "
"continue to work."
msgstr "또 다른 장점은 `if let`을 사용하면 파라미터가 없는 열거형 변체도 매칭할 수 있다는 점입니다. 이는 열거형이 `PartialEq`를 구현하거나 유도하지 않는 경우에도 마찬가지입니다. 이러한 경우 `if Foo::Bar == a`는 열거형 인스턴스를 비교할 수 없기 때문에 컴파일에 실패하지만, `if let`은 계속 작동합니다."

#: src/flow_control/if_let.md:100
msgid "Would you like a challenge? Fix the following example to use `if let`:"
msgstr "도전해 보시겠습니까? 다음 예제를 `if let`을 사용하도록 수정해 보세요:"

#: src/flow_control/if_let.md:103
msgid ""
"// This enum purposely neither implements nor derives PartialEq.\n"
"// That is why comparing Foo::Bar == a fails below.\n"
msgstr ""
"// 이 열거형은 의도적으로 PartialEq를 구현하거나 유도(derive)하지 않았습니다.\n"
"// 그래서 아래에서 Foo::Bar == a 를 비교하는 것이 실패합니다.\n"

#: src/flow_control/if_let.md:112
msgid "// ^-- this causes a compile-time error. Use `if let` instead.\n"
msgstr "// ^-- 이것은 컴파일 타임 에러를 발생시킵니다. 대신 `if let`을 사용하세요.\n"

#: src/flow_control/if_let.md:120
msgid ""
"[`enum`](../custom_types/enum.md), [`Option`](../std/option.md), and the "
"[RFC](https://github.com/rust-lang/rfcs/pull/160)"
msgstr "[`enum`](../custom_types/enum.md), [`Option`](../std/option.md), 그리고 [RFC](https://github.com/rust-lang/rfcs/pull/160)"

#: src/flow_control/let_else.md:3
msgid "🛈 stable since: rust 1.65"
msgstr "🛈 안정화 버전: rust 1.65"

#: src/flow_control/let_else.md:5
msgid ""
"🛈 you can target specific edition by compiling like this `rustc --"
"edition=2021 main.rs`"
msgstr "🛈 다음과 같이 컴파일하여 특정 에디션을 타겟팅할 수 있습니다: `rustc --edition=2021 main.rs`"

#: src/flow_control/let_else.md:8
msgid ""
"With `let`\\-`else`, a refutable pattern can match and bind variables in the "
"surrounding scope like a normal `let`, or else diverge (e.g. `break`, "
"`return`, `panic!`) when the pattern doesn't match."
msgstr "`let`\\-`else`를 사용하면, 일반적인 `let`처럼 주변 스코프에서 변수를 매칭하고 바인딩할 수 있으며, 패턴이 매칭되지 않을 경우 분기(예: `break`, `return`, `panic!`)할 수 있습니다."

#: src/flow_control/let_else.md:16 src/flow_control/let_else.md:39
#: src/std/str.md:41
msgid "' '"
msgstr "' '"

#: src/flow_control/let_else.md:18 src/flow_control/let_else.md:42
msgid "\"Can't segment count item pair: '{s}'\""
msgstr "\"카운트 아이템 쌍을 분리할 수 없습니다: '{s}'\""

#: src/flow_control/let_else.md:21 src/flow_control/let_else.md:47
msgid "\"Can't parse integer: '{count_str}'\""
msgstr "\"정수를 파싱할 수 없습니다: '{count_str}'\""

#: src/flow_control/let_else.md:27 src/flow_control/let_else.md:52
msgid "\"3 chairs\""
msgstr "\"3 chairs\""

#: src/flow_control/let_else.md:27 src/flow_control/let_else.md:52
msgid "\"chairs\""
msgstr "\"chairs\""

#: src/flow_control/let_else.md:31
msgid ""
"The scope of name bindings is the main thing that makes this different from "
"`match` or `if let`\\-`else` expressions. You could previously approximate "
"these patterns with an unfortunate bit of repetition and an outer `let`:"
msgstr "이름 바인딩의 스코프는 이것이 `match`나 `if let`\\-`else` 표현식과 다른 주요 점입니다. 이전에는 외부 `let`과 약간의 반복을 통해 이러한 패턴을 흉내 낼 수 있었습니다:"

#: src/flow_control/let_else.md:57
msgid ""
"[option](../std/option.md), [match](./match.md), [if let](./if_let.md) and "
"the [let-else RFC](https://rust-lang.github.io/rfcs/3137-let-else.html)."
msgstr "[option](../std/option.md), [match](./match.md), [if let](./if_let.md) 그리고 [let-else RFC](https://rust-lang.github.io/rfcs/3137-let-else.html)."

#: src/flow_control/while_let.md:3
msgid ""
"Similar to `if let`, `while let` can make awkward `match` sequences more "
"tolerable. Consider the following sequence that increments `i`:"
msgstr "`if let`과 유사하게, `while let`은 어색한 `match` 시퀀스를 더 견딜만하게 만들어 줍니다. `i`를 증가시키는 다음 시퀀스를 고려해 보세요:"

#: src/flow_control/while_let.md:9
msgid "// Repeatedly try this test.\n"
msgstr "// 이 테스트를 반복해서 시도합니다.\n"

#: src/flow_control/while_let.md:13
msgid "// If `optional` destructures, evaluate the block.\n"
msgstr "// 만약 `optional`이 구조 분해된다면, 블록을 평가합니다.\n"

#: src/flow_control/while_let.md:16 src/flow_control/while_let.md:42
msgid "\"Greater than 9, quit!\""
msgstr "\"9보다 큽니다, 종료!\""

#: src/flow_control/while_let.md:19 src/flow_control/while_let.md:45
msgid "\"`i` is `{:?}`. Try again.\""
msgstr "\"`i`는 `{:?}`입니다. 다시 시도하세요.\""

#: src/flow_control/while_let.md:22
msgid "// ^ Requires 3 indentations!\n"
msgstr "// ^ 3단계의 들여쓰기가 필요합니다!\n"

#: src/flow_control/while_let.md:24
msgid "// Quit the loop when the destructure fails:\n"
msgstr "// 구조 분해에 실패하면 루프를 종료합니다:\n"

#: src/flow_control/while_let.md:26
msgid "// ^ Why should this be required? There must be a better way!\n"
msgstr "// ^ 왜 이것이 필요할까요? 분명 더 좋은 방법이 있을 것입니다!\n"

#: src/flow_control/while_let.md:31
msgid "Using `while let` makes this sequence much nicer:"
msgstr "`while let`을 사용하면 이 시퀀스가 훨씬 깔끔해집니다:"

#: src/flow_control/while_let.md:38
msgid ""
"// This reads: \"while `let` destructures `optional` into\n"
"    // `Some(i)`, evaluate the block (`{}`). Else `break`.\n"
msgstr ""
"// 다음과 같이 읽힙니다: \"`let`이 `optional`을 `Some(i)`로\n"
"// 구조 분해하는 동안, 블록(`{}`)을 실행하라. 그 외에는 `break` 하라.\"\n"

#: src/flow_control/while_let.md:48
msgid ""
"// ^ Less rightward drift and doesn't require\n"
"        // explicitly handling the failing case.\n"
msgstr ""
"// ^ 오른쪽으로의 들여쓰기가 줄어들었으며 실패 사례를\n"
"// 명시적으로 처리할 필요가 없습니다.\n"

#: src/flow_control/while_let.md:51
msgid ""
"// ^ `if let` had additional optional `else`/`else if`\n"
"    // clauses. `while let` does not have these.\n"
msgstr ""
"// ^ `if let`에는 추가적인 선택 사항인 `else`/`else if` 절이\n"
"// 있었지만, `while let`에는 이러한 것들이 없습니다.\n"

#: src/flow_control/while_let.md:58
msgid ""
"[`enum`](../custom_types/enum.md), [`Option`](../std/option.md), and the "
"[RFC](https://github.com/rust-lang/rfcs/pull/214)"
msgstr "[`enum`](../custom_types/enum.md), [`Option`](../std/option.md), 그리고 [RFC](https://github.com/rust-lang/rfcs/pull/214)"

#: src/fn.md:3
msgid ""
"Functions are declared using the `fn` keyword. Its arguments are type "
"annotated, just like variables, and, if the function returns a value, the "
"return type must be specified after an arrow `->`."
msgstr "함수는 `fn` 키워드를 사용하여 선언됩니다. 인자는 변수와 마찬가지로 타입 어노테이션이 필요하며, 함수가 값을 반환하는 경우 반환 타입은 화살표 `->` 뒤에 지정해야 합니다."

#: src/fn.md:7
msgid ""
"The final expression in the function will be used as return value. "
"Alternatively, the `return` statement can be used to return a value earlier "
"from within the function, even from inside loops or `if` statements."
msgstr "함수의 마지막 표현식은 반환 값으로 사용됩니다. 또는 `return` 문을 사용하여 루프나 `if` 문 내부를 포함하여 함수 내에서 더 일찍 값을 반환할 수 있습니다."

#: src/fn.md:11
msgid "Let's rewrite FizzBuzz using functions!"
msgstr "함수를 사용하여 FizzBuzz를 다시 작성해 봅시다!"

#: src/fn.md:14
msgid ""
"// Unlike C/C++, there's no restriction on the order of function "
"definitions\n"
msgstr "// C/C++와 달리, 함수 정의 순서에는 제한이 없습니다.\n"

#: src/fn.md:16
msgid "// We can use this function here, and define it somewhere later\n"
msgstr "// 여기서 이 함수를 사용하고, 나중에 어딘가에서 정의할 수 있습니다.\n"

#: src/fn.md:19
msgid "// Function that returns a boolean value\n"
msgstr "// 불리언 값을 반환하는 함수\n"

#: src/fn.md:22
msgid "// Corner case, early return\n"
msgstr "// 예외 케이스, 조기 반환\n"

#: src/fn.md:27
msgid "// This is an expression, the `return` keyword is not necessary here\n"
msgstr "// 이것은 표현식이며, 여기서는 `return` 키워드가 필요하지 않습니다.\n"

#: src/fn.md:30
msgid ""
"// Functions that \"don't\" return a value, actually return the unit type "
"`()`\n"
msgstr "// 값을 반환하지 \"않는\" 함수는 실제로는 유닛 타입 `()`를 반환합니다.\n"

#: src/fn.md:43
msgid ""
"// When a function returns `()`, the return type can be omitted from the\n"
"// signature\n"
msgstr "// 함수가 `()`를 반환할 때, 시그니처에서 반환 타입을 생략할 수 있습니다.\n"

#: src/fn/methods.md:1
msgid "Associated functions & Methods"
msgstr "연관 함수와 메서드"

#: src/fn/methods.md:3
msgid ""
"Some functions are connected to a particular type. These come in two forms: "
"associated functions, and methods. Associated functions are functions that "
"are defined on a type generally, while methods are associated functions that "
msgstr "일부 함수는 특정 타입과 연결되어 있습니다. 이들은 연관 함수와 메서드라는 두 가지 형태로 제공됩니다. 연관 함수는 일반적으로 타입 상에 정의된 함수인 반면, 메서드는 "
"are called on a particular instance of a type."
msgstr ""

#: src/fn/methods.md:13
msgid ""
"// Implementation block, all `Point` associated functions & methods go in "
"here\n"
msgstr "// 구현(Implementation) 블록으로, 모든 `Point` 연관 함수와 메서드가 여기에 들어갑니다.\n"

#: src/fn/methods.md:16
msgid ""
"// This is an \"associated function\" because this function is associated "
"with\n"
"    // a particular type, that is, Point.\n"
"    //\n"
"    // Associated functions don't need to be called with an instance.\n"
"    // These functions are generally used like constructors.\n"
msgstr ""
"// 이것은 이 함수가 특정 타입인 Point와 연관되어 있기 때문에\n"
"// \"연관 함수\"라고 불립니다.\n"
"//\n"
"// 연관 함수는 인스턴스를 통해 호출될 필요가 없습니다.\n"
"// 이러한 함수들은 일반적으로 생성자처럼 사용됩니다.\n"

#: src/fn/methods.md:25
msgid "// Another associated function, taking two arguments:\n"
msgstr "// 두 개의 인자를 받는 또 다른 연관 함수:\n"

#: src/fn/methods.md:37
msgid ""
"// This is a method\n"
"    // `&self` is sugar for `self: &Self`, where `Self` is the type of the\n"
"    // caller object. In this case `Self` = `Rectangle`\n"
msgstr ""
"// 이것은 메서드입니다\n"
"// `&self`는 `self: &Self`의 축약형이며, 여기서 `Self`는\n"
"// 호출 객체의 타입입니다. 이 경우 `Self` = `Rectangle`입니다.\n"

#: src/fn/methods.md:41
msgid "// `self` gives access to the struct fields via the dot operator\n"
msgstr "// `self`는 점(dot) 연산자를 통해 구조체 필드에 대한 접근을 제공합니다.\n"

#: src/fn/methods.md:45
msgid ""
"// `abs` is a `f64` method that returns the absolute value of the\n"
"        // caller\n"
msgstr "// `abs`는 호출자의 절댓값을 반환하는 `f64` 메서드입니다.\n"

#: src/fn/methods.md:57
msgid ""
"// This method requires the caller object to be mutable\n"
"    // `&mut self` desugars to `self: &mut Self`\n"
msgstr ""
"// 이 메서드는 호출 객체가 가변적일 것을 요구합니다\n"
"// `&mut self`는 `self: &mut Self`로 풀어서 쓸 수 있습니다.\n"

#: src/fn/methods.md:67
msgid "// `Pair` owns resources: two heap allocated integers\n"
msgstr "// `Pair`는 리소스를 소유합니다: 힙에 할당된 두 개의 정수\n"

#: src/fn/methods.md:72
msgid ""
"// This method \"consumes\" the resources of the caller object\n"
"    // `self` desugars to `self: Self`\n"
msgstr ""
"// 이 메서드는 호출 객체의 리소스를 \"소비\"합니다\n"
"// `self`는 `self: Self`로 풀어서 쓸 수 있습니다.\n"

#: src/fn/methods.md:75
msgid "// Destructure `self`\n"
msgstr "// `self` 구조 분해\n"

#: src/fn/methods.md:78
msgid "\"Destroying Pair({}, {})\""
msgstr "\"Pair({}, {}) 파괴 중\""

#: src/fn/methods.md:80
msgid "// `first` and `second` go out of scope and get freed\n"
msgstr "// `first`와 `second`는 스코프를 벗어나며 해제됩니다.\n"

#: src/fn/methods.md:86
msgid "// Associated functions are called using double colons\n"
msgstr "// 연관 함수는 이중 콜론을 사용하여 호출됩니다.\n"

#: src/fn/methods.md:91
msgid ""
"// Methods are called using the dot operator\n"
"    // Note that the first argument `&self` is implicitly passed, i.e.\n"
"    // `rectangle.perimeter()` === `Rectangle::perimeter(&rectangle)`\n"
msgstr ""
"// 메서드는 점 연산자를 사용하여 호출됩니다.\n"
"// 첫 번째 인자인 `&self`는 암시적으로 전달됩니다. 즉,\n"
"// `rectangle.perimeter()`는 `Rectangle::perimeter(&rectangle)`와 동일합니다.\n"

#: src/fn/methods.md:94
msgid "\"Rectangle perimeter: {}\""
msgstr "\"사각형 둘레: {}\""

#: src/fn/methods.md:95
msgid "\"Rectangle area: {}\""
msgstr "\"사각형 넓이: {}\""

#: src/fn/methods.md:102
msgid ""
"// Error! `rectangle` is immutable, but this method requires a mutable\n"
"    // object\n"
"    //rectangle.translate(1.0, 0.0);\n"
"    // TODO ^ Try uncommenting this line\n"
msgstr ""
"// 에러! `rectangle`은 불변이지만, 이 메서드는 가변 객체를 요구합니다.\n"
"// rectangle.translate(1.0, 0.0);\n"
"// TODO ^ 이 줄의 주석을 해제해 보세요\n"

#: src/fn/methods.md:107
msgid "// Okay! Mutable objects can call mutable methods\n"
msgstr "// 좋습니다! 가변 객체는 가변 메서드를 호출할 수 있습니다\n"

#: src/fn/methods.md:114
msgid ""
"// Error! Previous `destroy` call \"consumed\" `pair`\n"
"    //pair.destroy();\n"
"    // TODO ^ Try uncommenting this line\n"
msgstr ""
"// 에러! 이전의 `destroy` 호출이 `pair`를 \"소비\"했습니다\n"
"// pair.destroy();\n"
"// TODO ^ 이 줄의 주석을 해제해 보세요\n"

#: src/fn/closures.md:3
msgid ""
"Closures are functions that can capture the enclosing environment. For "
"example, a closure that captures the `x` variable:"
msgstr "클로저는 감싸고 있는 환경을 캡처할 수 있는 함수입니다. 예를 들어, `x` 변수를 캡처하는 클로저는 다음과 같습니다:"

#: src/fn/closures.md:10
msgid ""
"The syntax and capabilities of closures make them very convenient for on the "
"fly usage. Calling a closure is exactly like calling a function. However, "
"both input and return types _can_ be inferred and input variable names "
"_must_ be specified."
msgstr "클로저의 구문과 기능은 즉석에서 사용하기에 매우 편리합니다. 클로저를 호출하는 것은 함수를 호출하는 것과 똑같습니다. 하지만 입력 및 반환 타입은 추론될 수 있으며, 입력 변수 이름은 반드시 지정되어야 합니다."

#: src/fn/closures.md:15
msgid "Other characteristics of closures include:"
msgstr "클로저의 다른 특징들은 다음과 같습니다:"

#: src/fn/closures.md:17
msgid "using `||` instead of `()` around input variables."
msgstr "입력 변수 주위에 `()` 대신 `||`를 사용합니다."

#: src/fn/closures.md:18
msgid ""
"optional body delimitation (`{}`) for a single line expression (mandatory "
"otherwise)."
msgstr "한 줄 표현식의 경우 본문 구분 기호(`{}`)는 선택 사항입니다 (그 외의 경우는 필수)."

#: src/fn/closures.md:19
msgid "the ability to capture the outer environment variables."
msgstr "외부 환경 변수를 캡처하는 능력."

#: src/fn/closures.md:25
msgid ""
"// A regular function can't refer to variables in the enclosing environment\n"
"    //fn function(i: i32) -> i32 { i + outer_var }\n"
"    // TODO: uncomment the line above and see the compiler error. The "
"compiler\n"
"    // suggests that we define a closure instead.\n"
msgstr ""
"// 일반 함수는 자신을 감싸고 있는 환경의 변수를 참조할 수 없습니다\n"
"// fn function(i: i32) -> i32 { i + outer_var }\n"
"// TODO: 위의 줄의 주석을 해제하고 컴파일 에러를 확인해 보세요. 컴파일러는\n"
"// 대신 클로저를 정의할 것을 제안합니다.\n"

#: src/fn/closures.md:30
msgid ""
"// Closures are anonymous, here we are binding them to references.\n"
"    // Annotation is identical to function annotation but is optional\n"
"    // as are the `{}` wrapping the body. These nameless functions\n"
"    // are assigned to appropriately named variables.\n"
msgstr ""
"// 클로저는 익명이며, 여기서는 참조에 바인딩하고 있습니다.\n"
"// 어노테이션은 함수의 어노테이션과 동일하지만 선택 사항이며,\n"
"// 본문을 감싸는 `{}` 역시 선택 사항입니다. 이 이름 없는 함수들은\n"
"// 적절하게 이름 붙여진 변수들에 할당됩니다.\n"

#: src/fn/closures.md:37
msgid "// Call the closures.\n"
msgstr "// 클로저를 호출합니다.\n"

#: src/fn/closures.md:38
msgid "\"closure_annotated: {}\""
msgstr "\"어노테이션된 클로저: {}\""

#: src/fn/closures.md:39
msgid "\"closure_inferred: {}\""
msgstr "\"추론된 클로저: {}\""

#: src/fn/closures.md:40
msgid ""
"// Once closure's type has been inferred, it cannot be inferred again with "
"another type.\n"
"    //println!(\"cannot reuse closure_inferred with another type: {}\", "
"closure_inferred(42i64));\n"
"    // TODO: uncomment the line above and see the compiler error.\n"
msgstr ""
"// 클로저의 타입이 한 번 추론되면, 다른 타입으로 다시 추론될 수 없습니다.\n"
"// println!(\"다른 타입으로 closure_inferred를 재사용할 수 없습니다: {}\", closure_inferred(42i64));\n"
"// TODO: 위의 줄의 주석을 해제하고 컴파일 에러를 확인해 보세요.\n"

#: src/fn/closures.md:44
msgid ""
"// A closure taking no arguments which returns an `i32`.\n"
"    // The return type is inferred.\n"
msgstr ""
"// 인자를 받지 않고 `i32`를 반환하는 클로저입니다.\n"
"// 반환 타입은 추론됩니다.\n"

#: src/fn/closures.md:47
msgid "\"closure returning one: {}\""
msgstr "\"1을 반환하는 클로저: {}\""

#: src/fn/closures/capture.md:3
msgid ""
"Closures are inherently flexible and will do what the functionality requires "
"to make the closure work without annotation. This allows capturing to "
"flexibly adapt to the use case, sometimes moving and sometimes borrowing. "
"Closures can capture variables:"
msgstr "클로저는 본질적으로 유연하며, 어노테이션 없이도 클로저가 작동하는 데 필요한 기능을 수행합니다. 이를 통해 캡처 방식이 사용 사례에 따라 유연하게 적응할 수 있으며, 때로는 이동(move)하고 때로는 빌림(borrow)을 수행합니다. 클로저는 다음과 같은 방식으로 변수를 캡처할 수 있습니다:"

#: src/fn/closures/capture.md:8
msgid "by reference: `&T`"
msgstr "참조에 의한 방식: `&T`"

#: src/fn/closures/capture.md:9
msgid "by mutable reference: `&mut T`"
msgstr "가변 참조에 의한 방식: `&mut T`"

#: src/fn/closures/capture.md:10
msgid "by value: `T`"
msgstr "값에 의한 방식: `T`"

#: src/fn/closures/capture.md:12
msgid ""
"They preferentially capture variables by reference and only go lower when "
"required."
msgstr "클로저는 가급적 참조로 변수를 캡처하며, 필요한 경우에만 더 낮은 수준(이동 등)으로 내려갑니다."

#: src/fn/closures/capture.md:19
msgid "\"green\""
msgstr "\"초록\""

#: src/fn/closures/capture.md:21
msgid ""
"// A closure to print `color` which immediately borrows (`&`) `color` and\n"
"    // stores the borrow and closure in the `print` variable. It will "
"remain\n"
"    // borrowed until `print` is used the last time.\n"
"    //\n"
"    // `println!` only requires arguments by immutable reference so it "
"doesn't\n"
"    // impose anything more restrictive.\n"
msgstr ""
"// `color`를 출력하는 클로저입니다. 이 클로저는 즉시 `color`를 빌리고(`&`)\n"
"// 그 빌림과 클로저를 `print` 변수에 저장합니다. `print`가 마지막으로\n"
"// 사용될 때까지 빌린 상태가 유지됩니다.\n"
"//\n"
"// `println!`은 인자로 불변 참조만 요구하므로 더 이상의 제약을\n"
"// 가하지 않습니다.\n"

#: src/fn/closures/capture.md:27
msgid "\"`color`: {}\""
msgstr "\"`color`: {}\""

#: src/fn/closures/capture.md:29
msgid "// Call the closure using the borrow.\n"
msgstr "// 빌림을 사용하여 클로저를 호출합니다.\n"

#: src/fn/closures/capture.md:32
msgid ""
"// `color` can be borrowed immutably again, because the closure only holds\n"
"    // an immutable reference to `color`.\n"
msgstr ""
"// 클로저가 `color`에 대한 불변 참조만 가지고 있기 때문에,\n"
"// `color`를 다시 불변으로 빌릴 수 있습니다.\n"

#: src/fn/closures/capture.md:37
msgid "// A move or reborrow is allowed after the final use of `print`\n"
msgstr "// `print`를 마지막으로 사용한 후에는 이동(move)이나 다시 빌리는 것이 허용됩니다\n"

#: src/fn/closures/capture.md:42
msgid ""
"// A closure to increment `count` could take either `&mut count` or `count`\n"
"    // but `&mut count` is less restrictive so it takes that. Immediately\n"
"    // borrows `count`.\n"
"    //\n"
"    // A `mut` is required on `inc` because a `&mut` is stored inside. "
"Thus,\n"
"    // calling the closure mutates `count` which requires a `mut`.\n"
msgstr ""
"// `count`를 증가시키는 클로저는 `&mut count`나 `count` 중 하나를 취할 수 있지만,\n"
"// `&mut count`가 덜 제한적이므로 이를 취합니다. 즉시 `count`를 빌립니다.\n"
"//\n"
"// 내부에 `&mut`가 저장되어 있기 때문에 `inc`에 `mut`가 필요합니다. 따라서\n"
"// 클로저를 호출하면 `count`가 수정되며, 이를 위해 `mut`가 필요합니다.\n"

#: src/fn/closures/capture.md:50
msgid "\"`count`: {}\""
msgstr "\"`count`: {}\""

#: src/fn/closures/capture.md:53
msgid "// Call the closure using a mutable borrow.\n"
msgstr "// 가변 빌림을 사용하여 클로저를 호출합니다.\n"

#: src/fn/closures/capture.md:56
msgid ""
"// The closure still mutably borrows `count` because it is called later.\n"
"    // An attempt to reborrow will lead to an error.\n"
"    // let _reborrow = &count;\n"
"    // ^ TODO: try uncommenting this line.\n"
msgstr ""
"// 클로저가 나중에 호출되기 때문에 여전히 `count`를 가변적으로 빌리고 있습니다.\n"
"// 다시 빌리려는 시도는 에러를 발생시킵니다.\n"
"// let _reborrow = &count;\n"
"// ^ TODO: 이 줄의 주석을 해제해 보세요.\n"

#: src/fn/closures/capture.md:62
msgid ""
"// The closure no longer needs to borrow `&mut count`. Therefore, it is\n"
"    // possible to reborrow without an error\n"
msgstr ""
"// 클로저가 더 이상 `&mut count`를 빌릴 필요가 없습니다. 따라서\n"
"// 에러 없이 다시 빌리는 것이 가능합니다.\n"

#: src/fn/closures/capture.md:67
msgid "// A non-copy type.\n"
msgstr "// 복사(copy)되지 않는 타입.\n"

#: src/fn/closures/capture.md:70
msgid ""
"// `mem::drop` requires `T` so this must take by value. A copy type\n"
"    // would copy into the closure leaving the original untouched.\n"
"    // A non-copy must move and so `movable` immediately moves into\n"
"    // the closure.\n"
msgstr ""
"// `mem::drop`은 `T`를 요구하므로 값을 가져와야 합니다. 복사 타입은\n"
"// 원본을 그대로 둔 채 클로저 내부로 복사될 것입니다.\n"
"// 복사되지 않는 타입은 이동(move)해야 하므로 `movable`은 즉시\n"
"// 클로저 내부로 이동됩니다.\n"

#: src/fn/closures/capture.md:75
msgid "\"`movable`: {:?}\""
msgstr "\"`movable`: {:?}\""

#: src/fn/closures/capture.md:79
msgid "// `consume` consumes the variable so this can only be called once.\n"
msgstr "// `consume`은 변수를 소비하므로 한 번만 호출될 수 있습니다.\n"

#: src/fn/closures/capture.md:81
msgid ""
"// consume();\n"
"    // ^ TODO: Try uncommenting this line.\n"
msgstr ""
"// consume();\n"
"// ^ TODO: 이 줄의 주석을 해제해 보세요.\n"

#: src/fn/closures/capture.md:86
msgid ""
"Using `move` before vertical pipes forces closure to take ownership of "
"captured variables:"
msgstr "수직 바(`||`) 앞에 `move`를 사용하면 클로저가 캡처된 변수의 소유권을 강제로 갖게 됩니다:"

#: src/fn/closures/capture.md:91
msgid "// `Vec` has non-copy semantics.\n"
msgstr "// `Vec`은 복사되지 않는 세맨틱을 가집니다.\n"

#: src/fn/closures/capture.md:99
msgid ""
"// println!(\"There're {} elements in vec\", haystack.len());\n"
"    // ^ Uncommenting above line will result in compile-time error\n"
"    // because borrow checker doesn't allow re-using variable after it\n"
"    // has been moved.\n"
msgstr ""
"// println!(\"vec에는 {}개의 요소가 있습니다\", haystack.len());\n"
"// ^ 위의 줄의 주석을 해제하면 컴파일 타임 에러가 발생합니다.\n"
"// 빌림 검사기(borrow checker)가 이동된 후의 변수 재사용을 허용하지 않기 때문입니다.\n"

#: src/fn/closures/capture.md:104
msgid ""
"// Removing `move` from closure's signature will cause closure\n"
"    // to borrow _haystack_ variable immutably, hence _haystack_ is still\n"
"    // available and uncommenting above line will not cause an error.\n"
msgstr ""
"// 클로저의 시그니처에서 `move`를 제거하면 클로저가 `haystack` 변수를\n"
"// 불변으로 빌리게 되므로, `haystack`을 여전히 사용할 수 있고\n"
"// 위의 줄의 주석을 해제해도 에러가 발생하지 않습니다.\n"

#: src/fn/closures/capture.md:112
msgid ""
"[`Box`](../../std/box.md) and [`std::mem::drop`](https://doc.rust-lang.org/"
"std/mem/fn.drop.html)"
msgstr "[`Box`](../../std/box.md)와 [`std::mem::drop`](https://doc.rust-lang.org/std/mem/fn.drop.html)"

#: src/fn/closures/input_parameters.md:3
msgid ""
"While Rust chooses how to capture variables on the fly mostly without type "
"annotation, this ambiguity is not allowed when writing functions. When "
"taking a closure as an input parameter, the closure's complete type must be "
"annotated using one of a few `traits`, and they're determined by what the "
"closure does with captured value. In order of decreasing restriction, they "
"are:"
msgstr "Rust는 대부분 타입 어노테이션 없이 즉석에서 변수를 캡처하는 방식을 선택하지만, 함수를 작성할 때는 이러한 모호함이 허용되지 않습니다. 클로저를 입력 파라미터로 받을 때, 클로저의 전체 타입은 몇 가지 `트레이트` 중 하나를 사용하여 어노테이션되어야 하며, 이는 클로저가 캡처된 값으로 무엇을 하는지에 따라 결정됩니다. 제약이 강한 순서대로 나열하면 다음과 같습니다:"

#: src/fn/closures/input_parameters.md:10
msgid "`Fn`: the closure uses the captured value by reference (`&T`)"
msgstr "`Fn`: 클로저가 캡처된 값을 참조(`&T`)로 사용합니다"

#: src/fn/closures/input_parameters.md:11
msgid ""
"`FnMut`: the closure uses the captured value by mutable reference (`&mut T`)"
msgstr "`FnMut`: 클로저가 캡처된 값을 가변 참조(`&mut T`)로 사용합니다"

#: src/fn/closures/input_parameters.md:12
msgid "`FnOnce`: the closure uses the captured value by value (`T`)"
msgstr "`FnOnce`: 클로저가 캡처된 값을 값(`T`)으로 사용합니다"

#: src/fn/closures/input_parameters.md:14
msgid ""
"On a variable-by-variable basis, the compiler will capture variables in the "
"least restrictive manner possible."
msgstr "변수별로 컴파일러는 가능한 가장 제약이 적은 방식으로 변수를 캡처합니다."

#: src/fn/closures/input_parameters.md:17
msgid ""
"For instance, consider a parameter annotated as `FnOnce`. This specifies "
"that the closure _may_ capture by `&T`, `&mut T`, or `T`, but the compiler "
"will ultimately choose based on how the captured variables are used in the "
"closure."
msgstr "예를 들어, `FnOnce`로 어노테이션된 파라미터를 생각해 보세요. 이는 클로저가 `&T`, `&mut T`, 또는 `T`로 캡처할 수 있음을 나타내지만, 컴파일러는 최종적으로 클로저 내에서 캡처된 변수가 어떻게 사용되는지에 따라 선택합니다."

#: src/fn/closures/input_parameters.md:22
msgid ""
"This is because if a move is possible, then any type of borrow should also "
"be possible. Note that the reverse is not true. If the parameter is "
"annotated as `Fn`, then capturing variables by `&mut T` or `T` are not "
"allowed. However, `&T` is allowed."
msgstr "이동(move)이 가능하다면 어떤 유형의 빌림(borrow)도 가능해야 하기 때문입니다. 그 반대는 성립하지 않음에 유의하세요. 파라미터가 `Fn`으로 어노테이션된 경우, `&mut T`나 `T`로 변수를 캡처하는 것은 허용되지 않습니다. 하지만 `&T`는 허용됩니다."

#: src/fn/closures/input_parameters.md:27
msgid ""
"In the following example, try swapping the usage of `Fn`, `FnMut`, and "
"`FnOnce` to see what happens:"
msgstr "다음 예제에서 `Fn`, `FnMut`, `FnOnce`의 사용을 서로 바꿔보며 어떤 일이 일어나는지 확인해 보세요:"

#: src/fn/closures/input_parameters.md:31
msgid ""
"// A function which takes a closure as an argument and calls it.\n"
"// <F> denotes that F is a \"Generic type parameter\"\n"
msgstr ""
"// 클로저를 인자로 받아 호출하는 함수입니다.\n"
"// <F>는 F가 \"제네릭 타입 파라미터\"임을 나타냅니다.\n"

#: src/fn/closures/input_parameters.md:34
msgid "// The closure takes no input and returns nothing.\n"
msgstr "// 이 클로저는 입력을 받지 않고 아무것도 반환하지 않습니다.\n"

#: src/fn/closures/input_parameters.md:36
msgid "// ^ TODO: Try changing this to `Fn` or `FnMut`.\n"
msgstr "// ^ TODO: 이를 `Fn`이나 `FnMut`로 변경해 보세요.\n"

#: src/fn/closures/input_parameters.md:40
msgid "// A function which takes a closure and returns an `i32`.\n"
msgstr "// 클로저를 받아 `i32`를 반환하는 함수입니다.\n"

#: src/fn/closures/input_parameters.md:43
msgid "// The closure takes an `i32` and returns an `i32`.\n"
msgstr "// 이 클로저는 `i32`를 받아 `i32`를 반환합니다.\n"

#: src/fn/closures/input_parameters.md:53
msgid ""
"// A non-copy type.\n"
"    // `to_owned` creates owned data from borrowed one\n"
msgstr ""
"// 복사되지 않는 타입.\n"
"// `to_owned`는 빌려온 데이터로부터 소유권이 있는 데이터를 생성합니다.\n"

#: src/fn/closures/input_parameters.md:55
msgid "\"goodbye\""
msgstr "\"잘 가요\""

#: src/fn/closures/input_parameters.md:57
msgid ""
"// Capture 2 variables: `greeting` by reference and\n"
"    // `farewell` by value.\n"
msgstr "// 두 개의 변수를 캡처합니다: `greeting`은 참조로, `farewell`은 값으로.\n"

#: src/fn/closures/input_parameters.md:60
msgid "// `greeting` is by reference: requires `Fn`.\n"
msgstr "// `greeting`은 참조에 의한 방식입니다: `Fn`이 필요합니다.\n"

#: src/fn/closures/input_parameters.md:61
msgid "\"I said {}.\""
msgstr "\"저는 {}라고 말했습니다.\""

#: src/fn/closures/input_parameters.md:63
msgid ""
"// Mutation forces `farewell` to be captured by\n"
"        // mutable reference. Now requires `FnMut`.\n"
msgstr ""
"// 수정을 위해 `farewell`을 가변 참조로 캡처해야 합니다.\n"
"// 이제 `FnMut`가 필요합니다.\n"

#: src/fn/closures/input_parameters.md:65
msgid "\"!!!\""
msgstr "\"!!!\""

#: src/fn/closures/input_parameters.md:66
msgid "\"Then I screamed {}.\""
msgstr "\"그러고 나서 저는 {}라고 소리쳤습니다.\""

#: src/fn/closures/input_parameters.md:67
msgid "\"Now I can sleep. zzzzz\""
msgstr "\"이제 잘 수 있겠네요. zzzzz\""

#: src/fn/closures/input_parameters.md:69
msgid ""
"// Manually calling drop forces `farewell` to\n"
"        // be captured by value. Now requires `FnOnce`.\n"
msgstr ""
"// 수동으로 drop을 호출하면 `farewell`을 값으로\n"
"// 캡처해야 합니다. 이제 `FnOnce`가 필요합니다.\n"

#: src/fn/closures/input_parameters.md:74
msgid "// Call the function which applies the closure.\n"
msgstr "// 클로저를 적용하는 함수를 호출합니다.\n"

#: src/fn/closures/input_parameters.md:77
msgid "// `double` satisfies `apply_to_3`'s trait bound\n"
msgstr "// `double`은 `apply_to_3`의 트레이트 바운드를 만족합니다\n"

#: src/fn/closures/input_parameters.md:80
msgid "\"3 doubled: {}\""
msgstr "\"3의 두 배: {}\""

#: src/fn/closures/input_parameters.md:86
msgid ""
"[`std::mem::drop`](https://doc.rust-lang.org/std/mem/fn.drop.html), [`Fn`]"
"(https://doc.rust-lang.org/std/ops/trait.Fn.html), [`FnMut`](https://"
"doc.rust-lang.org/std/ops/trait.FnMut.html), [Generics](../../generics.md), "
"[where](../../generics/where.md) and [`FnOnce`](https://doc.rust-lang.org/"
"std/ops/trait.FnOnce.html)"
msgstr "[`std::mem::drop`](https://doc.rust-lang.org/std/mem/fn.drop.html), [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html), [`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html), [제네릭](../../generics.md), [where](../../generics/where.md) 및 [`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html)"

#: src/fn/closures/anonymity.md:3
msgid ""
"Closures succinctly capture variables from enclosing scopes. Does this have "
"any consequences? It surely does. Observe how using a closure as a function "
"parameter requires [generics](../../generics.md), which is necessary because "
"of how they are defined:"
msgstr "클로저는 자신을 감싸고 있는 스코프에서 변수를 간결하게 캡처합니다. 이것이 어떤 결과를 초래할까요? 분명히 결과가 있습니다. 클로저를 함수 파라미터로 사용할 때 [제네릭](../../generics.md)이 왜 필요한지, 클로저가 어떻게 정의되는지를 통해 살펴보세요:"

#: src/fn/closures/anonymity.md:9
msgid "// `F` must be generic.\n"
msgstr "// `F`는 제네릭이어야 합니다.\n"

#: src/fn/closures/anonymity.md:16
msgid ""
"When a closure is defined, the compiler implicitly creates a new anonymous "
"structure to store the captured variables inside, meanwhile implementing the "
"functionality via one of the `traits`: `Fn`, `FnMut`, or `FnOnce` for this "
"unknown type. This type is assigned to the variable which is stored until "
"calling."
msgstr "클로저가 정의될 때, 컴파일러는 내부에 캡처된 변수를 저장하기 위해 새로운 익명 구조체를 암시적으로 생성하며, 동시에 이 알 수 없는 타입에 대해 `Fn`, `FnMut`, 또는 `FnOnce` 트레이트 중 하나를 통해 기능을 구현합니다. 이 타입은 변수에 할당되어 호출될 때까지 저장됩니다."

#: src/fn/closures/anonymity.md:22
msgid ""
"Since this new type is of unknown type, any usage in a function will require "
"generics. However, an unbounded type parameter `<T>` would still be "
"ambiguous and not be allowed. Thus, bounding by one of the `traits`: `Fn`, "
"`FnMut`, or `FnOnce` (which it implements) is sufficient to specify its type."
msgstr "이 새로운 타입은 알 수 없는 타입이므로, 함수에서 사용할 때는 제네릭이 필요합니다. 하지만 제약이 없는 타입 파라미터 `<T>`는 여전히 모호하므로 허용되지 않습니다. 따라서 클로저가 구현하는 `Fn`, `FnMut`, 또는 `FnOnce` 트레이트 중 하나로 바운딩하는 것이 그 타입을 지정하기에 충분합니다."

#: src/fn/closures/anonymity.md:28
msgid ""
"// `F` must implement `Fn` for a closure which takes no\n"
"// inputs and returns nothing - exactly what is required\n"
"// for `print`.\n"
msgstr ""
"// `F`는 입력이 없고 아무것도 반환하지 않는 클로저를 위해\n"
"// `Fn`을 구현해야 합니다. 이는 정확히 `print`에 요구되는 사항입니다.\n"

#: src/fn/closures/anonymity.md:39
msgid ""
"// Capture `x` into an anonymous type and implement\n"
"    // `Fn` for it. Store it in `print`.\n"
msgstr ""
"// `x`를 익명 타입으로 캡처하고 그에 대해 `Fn`을 구현합니다.\n"
"// 이를 `print`에 저장합니다.\n"

#: src/fn/closures/anonymity.md:49
msgid ""
"[A thorough analysis](https://huonw.github.io/blog/2015/05/finding-closure-"
"in-rust/), [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html), [`FnMut`]"
"(https://doc.rust-lang.org/std/ops/trait.FnMut.html), and [`FnOnce`](https://"
"doc.rust-lang.org/std/ops/trait.FnOnce.html)"
msgstr "[철저한 분석](https://huonw.github.io/blog/2015/05/finding-closure-in-rust/), [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html), [`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html), 그리고 [`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html)"

#: src/fn/closures/input_functions.md:3
msgid ""
"Since closures may be used as arguments, you might wonder if the same can be "
"said about functions. And indeed they can! If you declare a function that "
"takes a closure as parameter, then any function that satisfies the trait "
"bound of that closure can be passed as a parameter."
msgstr "클로저가 인자로 사용될 수 있으므로, 함수에 대해서도 똑같이 말할 수 있는지 궁금할 것입니다. 실제로 가능합니다! 클로저를 파라미터로 받는 함수를 선언하면, 해당 클로저의 트레이트 바운드를 만족하는 모든 함수를 파라미터로 전달할 수 있습니다."

#: src/fn/closures/input_functions.md:9
msgid ""
"// Define a function which takes a generic `F` argument\n"
"// bounded by `Fn`, and calls it\n"
msgstr ""
"// `Fn`으로 바운딩된 제네릭 `F` 인자를 받아\n"
"// 호출하는 함수를 정의합니다\n"

#: src/fn/closures/input_functions.md:14
msgid "// Define a wrapper function satisfying the `Fn` bound\n"
msgstr "// `Fn` 바운드를 만족하는 래퍼 함수를 정의합니다\n"

#: src/fn/closures/input_functions.md:17
msgid "\"I'm a function!\""
msgstr "\"저는 함수입니다!\""

#: src/fn/closures/input_functions.md:21
msgid "// Define a closure satisfying the `Fn` bound\n"
msgstr "// `Fn` 바운드를 만족하는 클로저를 정의합니다\n"

#: src/fn/closures/input_functions.md:22
msgid "\"I'm a closure!\""
msgstr "\"저는 클로저입니다!\""

#: src/fn/closures/input_functions.md:29
msgid ""
"As an additional note, the `Fn`, `FnMut`, and `FnOnce` `traits` dictate how "
"a closure captures variables from the enclosing scope."
msgstr "추가로, `Fn`, `FnMut`, `FnOnce` 트레이트는 클로저가 주변 스코프에서 변수를 캡처하는 방식을 결정합니다."

#: src/fn/closures/input_functions.md:34
msgid ""
"[`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html), [`FnMut`](https://"
"doc.rust-lang.org/std/ops/trait.FnMut.html), and [`FnOnce`](https://doc.rust-"
"lang.org/std/ops/trait.FnOnce.html)"
msgstr "[`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html), [`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html), 그리고 [`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html)"

#: src/fn/closures/output_parameters.md:3
msgid ""
"Closures as input parameters are possible, so returning closures as output "
"parameters should also be possible. However, anonymous closure types are, by "
"definition, unknown, so we have to use `impl Trait` to return them."
msgstr "클로저를 입력 파라미터로 사용하는 것이 가능하므로, 클로저를 출력 파라미터로 반환하는 것도 가능해야 합니다. 하지만 익명 클로저 타입은 정의상 알 수 없으므로, 이를 반환하려면 `impl Trait`를 사용해야 합니다."

#: src/fn/closures/output_parameters.md:8
msgid "The valid traits for returning a closure are:"
msgstr "클로저를 반환하기 위해 유효한 트레이트들은 다음과 같습니다:"

#: src/fn/closures/output_parameters.md:10
msgid "`Fn`"
msgstr "`Fn`"

#: src/fn/closures/output_parameters.md:11
msgid "`FnMut`"
msgstr "`FnMut`"

#: src/fn/closures/output_parameters.md:12
msgid "`FnOnce`"
msgstr "`FnOnce`"

#: src/fn/closures/output_parameters.md:14
msgid ""
"Beyond this, the `move` keyword must be used, which signals that all "
"captures occur by value. This is required because any captures by reference "
"would be dropped as soon as the function exited, leaving invalid references "
"in the closure."
msgstr "이 외에도, 모든 캡처가 값에 의해 발생함을 나타내는 `move` 키워드를 반드시 사용해야 합니다. 이는 참조에 의한 캡처가 함수가 종료되는 즉시 드롭되어 클로저에 유효하지 않은 참조를 남기기 때문에 필요합니다."

#: src/fn/closures/output_parameters.md:21
msgid "\"Fn\""
msgstr "\"Fn\""

#: src/fn/closures/output_parameters.md:23
#: src/fn/closures/output_parameters.md:29
#: src/fn/closures/output_parameters.md:35
msgid "\"This is a: {}\""
msgstr "\"이것은 {}입니다\""

#: src/fn/closures/output_parameters.md:27
msgid "\"FnMut\""
msgstr "\"FnMut\""

#: src/fn/closures/output_parameters.md:33
msgid "\"FnOnce\""
msgstr "\"FnOnce\""

#: src/fn/closures/output_parameters.md:51
msgid ""
"[`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html), [`FnMut`](https://"
"doc.rust-lang.org/std/ops/trait.FnMut.html), [Generics](../../generics.md) "
"and [impl Trait](../../trait/impl_trait.md)."
msgstr "[`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html), [`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html), [제네릭](../../generics.md) 및 [impl Trait](../../trait/impl_trait.md)."

#: src/fn/closures/closure_examples.md:3
msgid ""
"This section contains a few examples of using closures from the `std` "
"library."
msgstr "이 섹션에는 `std` 라이브러리의 클로저를 사용하는 몇 가지 예제가 포함되어 있습니다."

#: src/fn/closures/closure_examples/iter_any.md:3
msgid ""
"`Iterator::any` is a function which when passed an iterator, will return "
"`true` if any element satisfies the predicate. Otherwise `false`. Its "
"signature:"
msgstr "`Iterator::any`는 이터레이터가 주어졌을 때, 어떤 요소라도 서술어(predicate)를 만족하면 `true`를 반환하는 함수입니다. 그렇지 않으면 `false`를 반환합니다. 시그니처는 다음과 같습니다:"

#: src/fn/closures/closure_examples/iter_any.md:9
#: src/fn/closures/closure_examples/iter_find.md:9
msgid "// The type being iterated over.\n"
msgstr "// 반복되는 요소의 타입.\n"

#: src/fn/closures/closure_examples/iter_any.md:12
msgid ""
"// `any` takes `&mut self` meaning the caller may be borrowed\n"
"    // and modified, but not consumed.\n"
msgstr ""
"// `any`는 `&mut self`를 취하므로 호출자는 빌려지거나\n"
"// 수정될 수 있지만, 소비(consume)되지는 않습니다.\n"

#: src/fn/closures/closure_examples/iter_any.md:15
msgid ""
"// `FnMut` meaning any captured variable may at most be\n"
"        // modified, not consumed. `Self::Item` is the closure parameter "
"type,\n"
"        // which is determined by the iterator (e.g., `&T` for `.iter()`,\n"
"        // `T` for `.into_iter()`).\n"
msgstr ""
"// `FnMut`는 캡처된 변수가 최대 수정될 수 있지만 소비되지는 않음을 의미합니다.\n"
"// `Self::Item`은 클로저 파라미터 타입으로, 이터레이터에 의해 결정됩니다\n"
"// (예: `.iter()`의 경우 `&T`, `.into_iter()`의 경우 `T`).\n"

#: src/fn/closures/closure_examples/iter_any.md:28
msgid "// `iter()` for vecs yields `&i32`. Destructure to `i32`.\n"
msgstr "// 벡터에 대한 `iter()`는 `&i32`를 생성합니다. `i32`로 구조 분해합니다.\n"

#: src/fn/closures/closure_examples/iter_any.md:29
msgid "\"2 in vec1: {}\""
msgstr "\"vec1에 2가 있음: {}\""

#: src/fn/closures/closure_examples/iter_any.md:30
msgid "// `into_iter()` for vecs yields `i32`. No destructuring required.\n"
msgstr "// 벡터에 대한 `into_iter()`는 `i32`를 생성합니다. 구조 분해가 필요 없습니다.\n"

#: src/fn/closures/closure_examples/iter_any.md:31
msgid "\"2 in vec2: {}\""
msgstr "\"vec2에 2가 있음: {}\""

#: src/fn/closures/closure_examples/iter_any.md:33
msgid ""
"// `iter()` only borrows `vec1` and its elements, so they can be used again\n"
msgstr "// `iter()`는 오직 `vec1`과 그 요소들을 빌리기만 하므로, 다시 사용할 수 있습니다.\n"

#: src/fn/closures/closure_examples/iter_any.md:34
msgid "\"vec1 len: {}\""
msgstr "\"vec1 길이: {}\""

#: src/fn/closures/closure_examples/iter_any.md:35
msgid "\"First element of vec1 is: {}\""
msgstr "\"vec1의 첫 번째 요소: {}\""

#: src/fn/closures/closure_examples/iter_any.md:36
msgid ""
"// `into_iter()` does move `vec2` and its elements, so they cannot be used "
"again\n"
"    // println!(\"First element of vec2 is: {}\", vec2[0]);\n"
"    // println!(\"vec2 len: {}\", vec2.len());\n"
"    // TODO: uncomment two lines above and see compiler errors.\n"
msgstr ""
"// `into_iter()`는 `vec2`와 그 요소들을 이동(move)시키므로, 다시 사용할 수 없습니다.\n"
"// println!(\"vec2의 첫 번째 요소: {}\", vec2[0]);\n"
"// println!(\"vec2 길이: {}\", vec2.len());\n"
"// TODO: 위의 두 줄의 주석을 해제하고 컴파일 에러를 확인해 보세요.\n"

#: src/fn/closures/closure_examples/iter_any.md:44
msgid "// `iter()` for arrays yields `&i32`.\n"
msgstr "// 배열에 대한 `iter()`는 `&i32`를 생성합니다.\n"

#: src/fn/closures/closure_examples/iter_any.md:45
msgid "\"2 in array1: {}\""
msgstr "\"array1에 2가 있음: {}\""

#: src/fn/closures/closure_examples/iter_any.md:46
msgid "// `into_iter()` for arrays yields `i32`.\n"
msgstr "// 배열에 대한 `into_iter()`는 `i32`를 생성합니다.\n"

#: src/fn/closures/closure_examples/iter_any.md:47
msgid "\"2 in array2: {}\""
msgstr "\"array2에 2가 있음: {}\""

#: src/fn/closures/closure_examples/iter_any.md:53
msgid ""
"[`std::iter::Iterator::any`](https://doc.rust-lang.org/std/iter/"
"trait.Iterator.html#method.any)"
msgstr "[`std::iter::Iterator::any`](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.any)"

#: src/fn/closures/closure_examples/iter_find.md:3
msgid ""
"`Iterator::find` is a function which iterates over an iterator and searches "
"for the first value which satisfies some condition. If none of the values "
"satisfy the condition, it returns `None`. Its signature:"
msgstr "`Iterator::find`는 이터레이터를 순회하며 어떤 조건을 만족하는 첫 번째 값을 찾는 함수입니다. 조건을 만족하는 값이 없으면 `None`을 반환합니다. 시그니처는 다음과 같습니다:"

#: src/fn/closures/closure_examples/iter_find.md:12
msgid ""
"// `find` takes `&mut self` meaning the caller may be borrowed\n"
"    // and modified, but not consumed.\n"
msgstr ""
"// `find`는 `&mut self`를 취하므로 호출자는 빌려지거나\n"
"// 수정될 수 있지만, 소비(consume)되지는 않습니다.\n"

#: src/fn/closures/closure_examples/iter_find.md:15
msgid ""
"// `FnMut` meaning any captured variable may at most be\n"
"        // modified, not consumed. `&Self::Item` states it takes\n"
"        // arguments to the closure by reference.\n"
msgstr ""
"// `FnMut`는 캡처된 변수가 최대 수정될 수 있지만 소비되지는 않음을 의미합니다.\n"
"// `&Self::Item`은 클로저에 대한 인자를 참조로 취함을 나타냅니다.\n"

#: src/fn/closures/closure_examples/iter_find.md:27
msgid "// `vec1.iter()` yields `&i32`.\n"
msgstr "// `vec1.iter()`는 `&i32`를 생성합니다.\n"

#: src/fn/closures/closure_examples/iter_find.md:29
msgid "// `vec2.into_iter()` yields `i32`.\n"
msgstr "// `vec2.into_iter()`는 `i32`를 생성합니다.\n"

#: src/fn/closures/closure_examples/iter_find.md:32
msgid ""
"// `iter()` yields `&i32`, and `find` passes `&Item` to the predicate.\n"
"    // Since `Item = &i32`, the closure argument has type `&&i32`,\n"
"    // which we pattern-match to dereference down to `i32`.\n"
msgstr ""
"// `iter()`는 `&i32`를 생성하고, `find`는 서술어(predicate)에 `&Item`을 전달합니다.\n"
"// `Item = &i32`이므로 클로저 인자는 `&&i32` 타입을 가지며,\n"
"// 우리는 이를 패턴 매칭하여 `i32`로 역참조합니다.\n"

#: src/fn/closures/closure_examples/iter_find.md:35
msgid "\"Find 2 in vec1: {:?}\""
msgstr "\"vec1에서 2 찾기: {:?}\""

#: src/fn/closures/closure_examples/iter_find.md:37
msgid ""
"// `into_iter()` yields `i32`, and `find` passes `&Item` to the predicate.\n"
"    // Since `Item = i32`, the closure argument has type `&i32`,\n"
"    // which we pattern-match to dereference down to `i32`.\n"
msgstr ""
"// `into_iter()`는 `i32`를 생성하고, `find`는 서술어에 `&Item`을 전달합니다.\n"
"// `Item = i32`이므로 클로저 인자는 `&i32` 타입을 가지며,\n"
"// 우리는 이를 패턴 매칭하여 `i32`로 역참조합니다.\n"

#: src/fn/closures/closure_examples/iter_find.md:40
msgid "\"Find 2 in vec2: {:?}\""
msgstr "\"vec2에서 2 찾기: {:?}\""

#: src/fn/closures/closure_examples/iter_find.md:45
msgid "// `array1.iter()` yields `&i32`\n"
msgstr "// `array1.iter()`는 `&i32`를 생성합니다\n"

#: src/fn/closures/closure_examples/iter_find.md:46
msgid "\"Find 2 in array1: {:?}\""
msgstr "\"array1에서 2 찾기: {:?}\""

#: src/fn/closures/closure_examples/iter_find.md:47
msgid "// `array2.into_iter()` yields `i32`\n"
msgstr "// `array2.into_iter()`는 `i32`를 생성합니다\n"

#: src/fn/closures/closure_examples/iter_find.md:48
msgid "\"Find 2 in array2: {:?}\""
msgstr "\"array2에서 2 찾기: {:?}\""

#: src/fn/closures/closure_examples/iter_find.md:52
msgid ""
"`Iterator::find` gives you a reference to the item. But if you want the "
"_index_ of the item, use `Iterator::position`."
msgstr "`Iterator::find`는 아이템에 대한 참조를 제공합니다. 하지만 아이템의 인덱스를 원한다면 `Iterator::position`을 사용하세요."

#: src/fn/closures/closure_examples/iter_find.md:59
msgid ""
"// `position` passes the iterator’s `Item` by value to the predicate.\n"
"    // `vec.iter()` yields `&i32`, so the predicate receives `&i32`,\n"
"    // which we pattern-match to dereference to `i32`.\n"
msgstr ""
"// `position`은 이터레이터의 `Item`을 값으로 서술어에 전달합니다.\n"
"// `vec.iter()`는 `&i32`를 생성하므로 서술어는 `&i32`를 받으며,\n"
"// 우리는 이를 패턴 매칭하여 `i32`로 역참조합니다.\n"

#: src/fn/closures/closure_examples/iter_find.md:65
msgid ""
"// `vec.into_iter()` yields `i32`, so the predicate receives `i32` "
"directly.\n"
msgstr "// `vec.into_iter()`는 `i32`를 생성하므로 서술어는 `i32`를 직접 받습니다.\n"

#: src/fn/closures/closure_examples/iter_find.md:73
msgid ""
"[`std::iter::Iterator::find`](https://doc.rust-lang.org/std/iter/"
"trait.Iterator.html#method.find)"
msgstr "[`std::iter::Iterator::find`](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.find)"

#: src/fn/closures/closure_examples/iter_find.md:75
msgid ""
"[`std::iter::Iterator::find_map`](https://doc.rust-lang.org/std/iter/"
msgstr "[`std::iter::Iterator::find_map`](https://doc.rust-lang.org/std/iter/"
"trait.Iterator.html#method.find_map)"
msgstr "trait.Iterator.html#method.find_map)"

#: src/fn/closures/closure_examples/iter_find.md:77
msgid ""
"[`std::iter::Iterator::position`](https://doc.rust-lang.org/std/iter/"
"trait.Iterator.html#method.position)"
msgstr "[`std::iter::Iterator::position`](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.position)"

#: src/fn/closures/closure_examples/iter_find.md:79
msgid ""
"[`std::iter::Iterator::rposition`](https://doc.rust-lang.org/std/iter/"
"trait.Iterator.html#method.rposition)"
msgstr "[`std::iter::Iterator::rposition`](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.rposition)"

#: src/fn/hof.md:3
msgid ""
"Rust provides Higher Order Functions (HOF). These are functions that take "
"one or more functions and/or produce a more useful function. HOFs and lazy "
"iterators give Rust its functional flavor."
msgstr "Rust는 고차 함수(Higher Order Functions, HOF)를 제공합니다. 이들은 하나 이상의 함수를 인자로 받거나 더 유용한 함수를 만들어내는 함수들입니다. HOF와 게으른(lazy) 이터레이터는 Rust에 함수형 프로그래밍의 풍미를 더해줍니다."

#: src/fn/hof.md:13
msgid "\"Find the sum of all the numbers with odd squares under 1000\""
msgstr "\"1000 미만의 홀수 제곱값들의 합 찾기\""

#: src/fn/hof.md:16
msgid ""
"// Imperative approach\n"
"    // Declare accumulator variable\n"
msgstr ""
"// 명령형 접근 방식\n"
"// 누적 변수 선언\n"

#: src/fn/hof.md:19
msgid "// Iterate: 0, 1, 2, ... to infinity\n"
msgstr "// 반복: 0, 1, 2, ... 무한대까지\n"

#: src/fn/hof.md:21
msgid "// Square the number\n"
msgstr "// 숫자를 제곱합니다\n"

#: src/fn/hof.md:25
msgid "// Break loop if exceeded the upper limit\n"
msgstr "// 상한을 초과하면 루프를 종료합니다\n"

#: src/fn/hof.md:28
msgid "// Accumulate value, if it's odd\n"
msgstr "// 홀수라면 값을 누적합니다\n"

#: src/fn/hof.md:32
msgid "\"imperative style: {}\""
msgstr "\"명령형 스타일: {}\""

#: src/fn/hof.md:34
msgid "// Functional approach\n"
msgstr "// 함수형 접근 방식\n"

#: src/fn/hof.md:36
msgid "// Below upper limit\n"
msgstr "// 상한 미만\n"

#: src/fn/hof.md:37
msgid "// That are odd\n"
msgstr "// 홀수인 것들\n"

#: src/fn/hof.md:38
msgid "// Sum them\n"
msgstr "// 합계를 구함\n"

#: src/fn/hof.md:39
msgid "\"functional style: {}\""
msgstr "\"함수형 스타일: {}\""

#: src/fn/hof.md:43
msgid ""
"[Option](https://doc.rust-lang.org/core/option/enum.Option.html) and "
"[Iterator](https://doc.rust-lang.org/core/iter/trait.Iterator.html) "
"implement their fair share of HOFs."
msgstr "[Option](https://doc.rust-lang.org/core/option/enum.Option.html)과 [Iterator](https://doc.rust-lang.org/core/iter/trait.Iterator.html)는 상당수의 HOF를 구현하고 있습니다."

#: src/fn/diverging.md:3
msgid ""
"Diverging functions never return. They are marked using `!`, which is an "
"empty type."
msgstr "발산 함수(Diverging functions)는 절대 반환되지 않습니다. 이들은 빈 타입인 `!`를 사용하여 표시됩니다."

#: src/fn/diverging.md:7 src/fn/diverging.md:35
msgid "\"This call never returns.\""
msgstr "\"이 호출은 절대 반환되지 않습니다.\""

#: src/fn/diverging.md:11
msgid ""
"As opposed to all the other types, this one cannot be instantiated, because "
"the set of all possible values this type can have is empty. Note that, it is "
"different from the `()` type, which has exactly one possible value."
msgstr "다른 모든 타입들과 달리, 이 타입은 인스턴스화할 수 없습니다. 이 타입이 가질 수 있는 모든 가능한 값의 집합이 비어 있기 때문입니다. 이는 정확히 하나의 가능한 값을 갖는 `()` 타입과는 다르다는 점에 유의하세요."

#: src/fn/diverging.md:15
msgid ""
"For example, this function returns as usual, although there is no "
"information in the return value."
msgstr "예를 들어, 이 함수는 반환 값에 정보가 없더라도 평소와 같이 반환됩니다."

#: src/fn/diverging.md:25
msgid "\"This function returns and you can see this line.\""
msgstr "\"이 함수는 반환되며 당신은 이 줄을 볼 수 있습니다.\""

#: src/fn/diverging.md:29
msgid ""
"As opposed to this function, which will never return the control back to the "
"caller."
msgstr "반면 이 함수는 호출자에게 제어권을 절대 반환하지 않습니다."

#: src/fn/diverging.md:36
msgid "\"You will never see this line!\""
msgstr "\"당신은 결코 이 줄을 볼 수 없을 것입니다!\""

#: src/fn/diverging.md:40
msgid ""
"Although this might seem like an abstract concept, it is actually very "
"useful and often handy. The main advantage of this type is that it can be "
"cast to any other type, making it versatile in situations where an exact "
"type is required, such as in match branches. This flexibility allows us to "
"write code like this:"
msgstr "이것이 추상적인 개념처럼 보일 수 있지만, 실제로는 매우 유용하며 종종 편리하게 사용됩니다. 이 타입의 주요 장점은 다른 어떤 타입으로도 형변환될 수 있다는 것이며, 이는 match 분기와 같이 정확한 타입이 요구되는 상황에서 다재다능하게 만들어줍니다. 이러한 유연성 덕분에 다음과 같은 코드를 작성할 수 있습니다:"

#: src/fn/diverging.md:50
msgid ""
"// Notice that the return type of this match expression must be u32\n"
"            // because of the type of the \"addition\" variable.\n"
msgstr ""
"// 이 match 표현식의 반환 타입은 \"addition\" 변수의 타입 때문에\n"
"// 반드시 u32여야 함에 주목하세요.\n"

#: src/fn/diverging.md:53
msgid "// The \"i\" variable is of type u32, which is perfectly fine.\n"
msgstr "// \"i\" 변수는 u32 타입이며, 이는 완벽하게 괜찮습니다.\n"

#: src/fn/diverging.md:55
msgid ""
"// On the other hand, the \"continue\" expression does not return\n"
"                // u32, but it is still fine, because it never returns and "
"therefore\n"
"                // does not violate the type requirements of the match "
"expression.\n"
msgstr ""
"// 반면에 \"continue\" 표현식은 u32를 반환하지 않지만,\n"
"// 결코 반환되지 않으므로 match 표현식의 타입 요구 사항을\n"
"// 위반하지 않으며 여전히 괜찮습니다.\n"

#: src/fn/diverging.md:64
msgid "\"Sum of odd numbers up to 9 (excluding): {}\""
msgstr "\"9 미만의 홀수들의 합: {}\""

#: src/fn/diverging.md:68
msgid ""
"It is also the return type of functions that loop forever (e.g. `loop {}`) "
"like network servers or functions that terminate the process (e.g. `exit()`)."
msgstr "또한 네트워크 서버처럼 영원히 루프를 도는 함수(예: `loop {}`)나 프로세스를 종료하는 함수(예: `exit()`)의 반환 타입이기도 합니다."

#: src/mod.md:3
msgid ""
"Rust provides a powerful module system that can be used to hierarchically "
"split code in logical units (modules), and manage visibility (public/"
"private) between them."
msgstr "Rust는 코드를 논리적 단위(모듈)로 계층적으로 나누고, 그들 사이의 가시성(public/private)을 관리하는 데 사용할 수 있는 강력한 모듈 시스템을 제공합니다."

#: src/mod.md:7
msgid ""
"A module is a collection of items: functions, structs, traits, `impl` "
"blocks, and even other modules."
msgstr "모듈은 함수, 구조체, 트레이트, `impl` 블록, 그리고 다른 모듈까지 포함하는 아이템들의 모음입니다."

#: src/mod/visibility.md:3
msgid ""
"By default, the items in a module have private visibility, but this can be "
"overridden with the `pub` modifier. Only the public items of a module can be "
"accessed from outside the module scope."
msgstr "기본적으로 모듈 내의 아이템들은 비공개(private) 가시성을 가지지만, `pub` 수식어를 사용하여 이를 재정의할 수 있습니다. 모듈 스코프 외부에서는 모듈의 공개(public) 아이템만 접근할 수 있습니다."

#: src/mod/visibility.md:8
msgid "// A module named `my_mod`\n"
msgstr "// `my_mod`라는 이름의 모듈\n"

#: src/mod/visibility.md:10
msgid "// Items in modules default to private visibility.\n"
msgstr "// 모듈 내의 아이템들은 기본적으로 비공개 가시성을 가집니다.\n"

#: src/mod/visibility.md:12
msgid "\"called `my_mod::private_function()`\""
msgstr "\"`my_mod::private_function()` 호출됨\""

#: src/mod/visibility.md:15
msgid "// Use the `pub` modifier to override default visibility.\n"
msgstr "// 기본 가시성을 재정의하려면 `pub` 수식어를 사용하세요.\n"

#: src/mod/visibility.md:17
msgid "\"called `my_mod::function()`\""
msgstr "\"`my_mod::function()` 호출됨\""

#: src/mod/visibility.md:20
msgid ""
"// Items can access other items in the same module,\n"
"    // even when private.\n"
msgstr ""
"// 아이템들은 같은 모듈 내의 다른 아이템들에 접근할 수 있으며,\n"
"// 이는 비공개 아이템이라도 마찬가지입니다.\n"

#: src/mod/visibility.md:23
msgid "\"called `my_mod::indirect_access()`, that\\n> \""
msgstr "\"`my_mod::indirect_access()` 호출됨, 결과는\\n> \""

#: src/mod/visibility.md:27
msgid "// Modules can also be nested\n"
msgstr "// 모듈은 중첩될 수도 있습니다\n"

#: src/mod/visibility.md:30
msgid "\"called `my_mod::nested::function()`\""
msgstr "\"`my_mod::nested::function()` 호출됨\""

#: src/mod/visibility.md:35
msgid "\"called `my_mod::nested::private_function()`\""
msgstr "\"`my_mod::nested::private_function()` 호출됨\""

#: src/mod/visibility.md:38
msgid ""
"// Functions declared using `pub(in path)` syntax are only visible\n"
"        // within the given path. `path` must be a parent or ancestor "
"module\n"
msgstr ""
"// `pub(in path)` 구문을 사용하여 선언된 함수들은 오직 지정된\n"
"// 경로 내에서만 보입니다. `path`는 반드시 부모 또는 조상 모듈이어야 합니다.\n"

#: src/mod/visibility.md:41
msgid "\"called `my_mod::nested::public_function_in_my_mod()`, that\\n> \""
msgstr "\"`my_mod::nested::public_function_in_my_mod()` 호출됨, 결과는\\n> \""

#: src/mod/visibility.md:45
msgid ""
"// Functions declared using `pub(self)` syntax are only visible within\n"
"        // the current module, which is the same as leaving them private\n"
msgstr ""
"// `pub(self)` 구문을 사용하여 선언된 함수들은 오직 현재 모듈\n"
"// 내에서만 보이며, 이는 비공개로 두는 것과 동일합니다.\n"

#: src/mod/visibility.md:48
msgid "\"called `my_mod::nested::public_function_in_nested()`\""
msgstr "\"`my_mod::nested::public_function_in_nested()` 호출됨\""

#: src/mod/visibility.md:51
msgid ""
"// Functions declared using `pub(super)` syntax are only visible within\n"
"        // the parent module\n"
msgstr ""
"// `pub(super)` 구문을 사용하여 선언된 함수들은 오직 부모 모듈\n"
"// 내에서만 보입니다.\n"

#: src/mod/visibility.md:54
msgid "\"called `my_mod::nested::public_function_in_super_mod()`\""
msgstr "\"`my_mod::nested::public_function_in_super_mod()` 호출됨\""

#: src/mod/visibility.md:59
msgid "\"called `my_mod::call_public_function_in_my_mod()`, that\\n> \""
msgstr "\"`my_mod::call_public_function_in_my_mod()` 호출됨, 결과는\\n> \""

#: src/mod/visibility.md:61
msgid "\"> \""
msgstr "\"> \""

#: src/mod/visibility.md:65
msgid "// pub(crate) makes functions visible only within the current crate\n"
msgstr "// pub(crate)는 함수를 오직 현재 크레이트 내에서만 보이게 만듭니다\n"

#: src/mod/visibility.md:67
msgid "\"called `my_mod::public_function_in_crate()`\""
msgstr "\"`my_mod::public_function_in_crate()` 호출됨\""

#: src/mod/visibility.md:70
msgid "// Nested modules follow the same rules for visibility\n"
msgstr "// 중첩된 모듈도 동일한 가시성 규칙을 따릅니다\n"

#: src/mod/visibility.md:74
msgid "\"called `my_mod::private_nested::function()`\""
msgstr "\"`my_mod::private_nested::function()` 호출됨\""

#: src/mod/visibility.md:77
msgid ""
"// Private parent items will still restrict the visibility of a child item,\n"
"        // even if it is declared as visible within a bigger scope.\n"
msgstr ""
"// 비공개 부모 아이템은 자식 아이템이 더 큰 스코프 내에서 보이도록\n"
"// 선언되어 있더라도 여전히 그 가시성을 제한합니다.\n"

#: src/mod/visibility.md:81
msgid "\"called `my_mod::private_nested::restricted_function()`\""
msgstr "\"`my_mod::private_nested::restricted_function()` 호출됨\""

#: src/mod/visibility.md:87 src/mod/use.md:25 src/mod/super.md:8
#: src/mod/split.md:24
msgid "\"called `function()`\""
msgstr "\"`function()` 호출됨\""

#: src/mod/visibility.md:91
msgid ""
"// Modules allow disambiguation between items that have the same name.\n"
msgstr "// 모듈은 이름이 같은 아이템들 간의 모호함을 해소할 수 있게 해줍니다.\n"

#: src/mod/visibility.md:95
msgid ""
"// Public items, including those inside nested modules, can be\n"
"    // accessed from outside the parent module.\n"
msgstr ""
"// 중첩된 모듈 내부에 있는 아이템을 포함한 공개 아이템들은\n"
"// 부모 모듈 외부에서 접근할 수 있습니다.\n"

#: src/mod/visibility.md:101
msgid "// pub(crate) items can be called from anywhere in the same crate\n"
msgstr "// pub(crate) 아이템은 같은 크레이트 내 어디에서나 호출될 수 있습니다\n"

#: src/mod/visibility.md:104
msgid ""
"// pub(in path) items can only be called from within the module specified\n"
"    // Error! function `public_function_in_my_mod` is private\n"
"    //my_mod::nested::public_function_in_my_mod();\n"
"    // TODO ^ Try uncommenting this line\n"
msgstr ""
"// `pub(in path)` 아이템은 오직 지정된 모듈 내에서만 호출될 수 있습니다\n"
"// 에러! `public_function_in_my_mod` 함수는 비공개입니다\n"
"// my_mod::nested::public_function_in_my_mod();\n"
"// TODO ^ 이 줄의 주석을 해제해 보세요\n"

#: src/mod/visibility.md:109
msgid ""
"// Private items of a module cannot be directly accessed, even if\n"
"    // nested in a public module:\n"
msgstr ""
"// 모듈의 비공개 아이템은 공개 모듈에 중첩되어 있더라도\n"
"// 직접 접근할 수 없습니다:\n"

#: src/mod/visibility.md:112
msgid ""
"// Error! `private_function` is private\n"
"    //my_mod::private_function();\n"
"    // TODO ^ Try uncommenting this line\n"
msgstr ""
"// 에러! `private_function`은 비공개입니다\n"
"// my_mod::private_function();\n"
"// TODO ^ 이 줄의 주석을 해제해 보세요\n"

#: src/mod/visibility.md:116
msgid ""
"// Error! `private_function` is private\n"
"    //my_mod::nested::private_function();\n"
"    // TODO ^ Try uncommenting this line\n"
msgstr ""
"// 에러! `private_function`은 비공개입니다\n"
"// my_mod::nested::private_function();\n"
"// TODO ^ 이 줄의 주석을 해제해 보세요\n"

#: src/mod/visibility.md:120
msgid ""
"// Error! `private_nested` is a private module\n"
"    //my_mod::private_nested::function();\n"
"    // TODO ^ Try uncommenting this line\n"
msgstr ""
"// 에러! `private_nested`는 비공개 모듈입니다\n"
"// my_mod::private_nested::function();\n"
"// TODO ^ 이 줄의 주석을 해제해 보세요\n"

#: src/mod/visibility.md:124
msgid ""
"// Error! `private_nested` is a private module\n"
"    //my_mod::private_nested::restricted_function();\n"
"    // TODO ^ Try uncommenting this line\n"
msgstr ""
"// 에러! `private_nested`는 비공개 모듈입니다\n"
"// my_mod::private_nested::restricted_function();\n"
"// TODO ^ 이 줄의 주석을 해제해 보세요\n"

#: src/mod/struct_visibility.md:3
msgid ""
"Structs have an extra level of visibility with their fields. The visibility "
"defaults to private, and can be overridden with the `pub` modifier. This "
"visibility only matters when a struct is accessed from outside the module "
"where it is defined, and has the goal of hiding information (encapsulation)."
msgstr "구조체는 필드에 대해 추가적인 수준의 가시성을 가집니다. 가시성은 기본적으로 비공개이며, `pub` 수식어로 재정의할 수 있습니다. 이 가시성은 구조체가 정의된 모듈 외부에서 접근할 때만 의미가 있으며, 정보를 숨기는 것(캡슐화)이 목적입니다."

#: src/mod/struct_visibility.md:10
msgid "// A public struct with a public field of generic type `T`\n"
msgstr "// 제네릭 타입 `T`의 공개 필드를 가진 공개 구조체\n"

#: src/mod/struct_visibility.md:15
msgid "// A public struct with a private field of generic type `T`\n"
msgstr "// 제네릭 타입 `T`의 비공개 필드를 가진 공개 구조체\n"

#: src/mod/struct_visibility.md:21
msgid "// A public constructor method\n"
msgstr "// 공개 생성자 메서드\n"

#: src/mod/struct_visibility.md:31
msgid "// Public structs with public fields can be constructed as usual\n"
msgstr "// 공개 필드를 가진 공개 구조체는 평소처럼 생성할 수 있습니다\n"

#: src/mod/struct_visibility.md:32
msgid "\"public information\""
msgstr "\"공개 정보\""

#: src/mod/struct_visibility.md:34
msgid "// and their fields can be normally accessed.\n"
msgstr "// 그리고 그 필드들에 정상적으로 접근할 수 있습니다.\n"

#: src/mod/struct_visibility.md:35
msgid "\"The open box contains: {}\""
msgstr "\"열린 박스 내용물: {}\""

#: src/mod/struct_visibility.md:37
msgid ""
"// Public structs with private fields cannot be constructed using field "
"names.\n"
"    // Error! `ClosedBox` has private fields\n"
"    //let closed_box = my::ClosedBox { contents: \"classified "
"information\" };\n"
"    // TODO ^ Try uncommenting this line\n"
msgstr ""
"// 비공개 필드를 가진 공개 구조체는 필드 이름을 사용하여 생성할 수 없습니다.\n"
"// 에러! `ClosedBox`에 비공개 필드가 있습니다\n"
"// let closed_box = my::ClosedBox { contents: \"classified information\" };\n"
"// TODO ^ 이 줄의 주석을 해제해 보세요\n"

#: src/mod/struct_visibility.md:42
msgid ""
"// However, structs with private fields can be created using\n"
"    // public constructors\n"
msgstr "// 하지만 비공개 필드를 가진 구조체는 공개 생성자를 통해 생성할 수 있습니다\n"

#: src/mod/struct_visibility.md:44
msgid "\"classified information\""
msgstr "\"기밀 정보\""

#: src/mod/struct_visibility.md:46
msgid ""
"// and the private fields of a public struct cannot be accessed.\n"
"    // Error! The `contents` field is private\n"
"    //println!(\"The closed box contains: {}\", _closed_box.contents);\n"
"    // TODO ^ Try uncommenting this line\n"
msgstr ""
"// 그리고 공개 구조체의 비공개 필드에는 접근할 수 없습니다.\n"
"// 에러! `contents` 필드는 비공개입니다\n"
"// println!(\"닫힌 박스 내용물: {}\", _closed_box.contents);\n"
"// TODO ^ 이 줄의 주석을 해제해 보세요\n"

#: src/mod/struct_visibility.md:55
msgid "[generics](../generics.md) and [methods](../fn/methods.md)"
msgstr "[제네릭](../generics.md) 및 [메서드](../fn/methods.md)"

#: src/mod/use.md:3
msgid ""
"The `use` declaration can be used to bind a full path to a new name, for "
"easier access. It is often used like this:"
msgstr "`use` 선언을 사용하여 전체 경로를 새로운 이름에 바인딩하여 더 쉽게 접근할 수 있습니다. 다음과 같이 자주 사용됩니다:"

#: src/mod/use.md:18
msgid "You can use the `as` keyword to bind imports to a different name:"
msgstr "`as` 키워드를 사용하여 임포트(imports)를 다른 이름에 바인딩할 수 있습니다:"

#: src/mod/use.md:21
msgid "// Bind the `deeply::nested::function` path to `other_function`.\n"
msgstr "// `deeply::nested::function` 경로를 `other_function`에 바인딩합니다.\n"

#: src/mod/use.md:31
msgid "\"called `deeply::nested::function()`\""
msgstr "\"`deeply::nested::function()` 호출됨\""

#: src/mod/use.md:37
msgid "// Easier access to `deeply::nested::function`\n"
msgstr "// `deeply::nested::function`에 더 쉽게 접근\n"

#: src/mod/use.md:40
msgid "\"Entering block\""
msgstr "\"블록 진입\""

#: src/mod/use.md:42
msgid ""
"// This is equivalent to `use deeply::nested::function as function`.\n"
"        // This `function()` will shadow the outer one.\n"
msgstr ""
"// 이는 `use deeply::nested::function as function`과 동일합니다.\n"
"// 이 `function()`은 외부의 것을 섀도잉합니다.\n"

#: src/mod/use.md:46
msgid ""
"// `use` bindings have a local scope. In this case, the\n"
"        // shadowing of `function()` is only in this block.\n"
msgstr ""
"// `use` 바인딩은 지역 스코프를 가집니다. 이 경우\n"
"// `function()`의 섀도잉은 이 블록 내에서만 유효합니다.\n"

#: src/mod/use.md:50
msgid "\"Leaving block\""
msgstr "\"블록 나감\""

#: src/mod/super.md:3
msgid ""
"The `super` and `self` keywords can be used in the path to remove ambiguity "
"when accessing items and to prevent unnecessary hardcoding of paths."
msgstr "`super`와 `self` 키워드는 아이템에 접근할 때 모호함을 제거하고 경로의 불필요한 하드코딩을 방지하기 위해 경로 내에서 사용될 수 있습니다."

#: src/mod/super.md:13
msgid "\"called `cool::function()`\""
msgstr "\"`cool::function()` 호출됨\""

#: src/mod/super.md:19 src/mod/split.md:49
msgid "\"called `my::function()`\""
msgstr "\"`my::function()` 호출됨\""

#: src/mod/super.md:24
msgid "\"called `my::cool::function()`\""
msgstr "\"`my::cool::function()` 호출됨\""

#: src/mod/super.md:29
msgid "// Let's access all the functions named `function` from this scope!\n"
msgstr "// 이 스코프에서 `function`이라는 이름의 모든 함수에 접근해 봅시다!\n"

#: src/mod/super.md:30
msgid "\"called `my::indirect_call()`, that\\n> \""
msgstr "\"`my::indirect_call()` 호출됨, 결과는\\n> \""

#: src/mod/super.md:32
msgid ""
"// The `self` keyword refers to the current module scope - in this case "
"`my`.\n"
"        // Calling `self::function()` and calling `function()` directly both "
"give\n"
"        // the same result, because they refer to the same function.\n"
msgstr ""
"// `self` 키워드는 현재 모듈 스코프를 가리킵니다. 이 경우 `my`입니다.\n"
"// `self::function()`을 호출하는 것과 `function()`을 직접 호출하는 것은\n"
"// 동일한 함수를 가리키기 때문에 같은 결과를 냅니다.\n"

#: src/mod/super.md:38
msgid "// We can also use `self` to access another module inside `my`:\n"
msgstr "// `self`를 사용하여 `my` 내부의 다른 모듈에 접근할 수도 있습니다:\n"

#: src/mod/super.md:41
msgid ""
"// The `super` keyword refers to the parent scope (outside the `my` "
"module).\n"
msgstr "// `super` 키워드는 부모 스코프(`my` 모듈 외부)를 가리킵니다.\n"

#: src/mod/super.md:44
msgid ""
"// This will bind to the `cool::function` in the *crate* scope.\n"
"        // In this case the crate scope is the outermost scope.\n"
msgstr ""
"// 이는 *크레이트* 스코프에 있는 `cool::function`에 바인딩됩니다.\n"
"// 이 경우 크레이트 스코프는 가장 바깥쪽 스코프입니다.\n"

#: src/mod/split.md:3
msgid ""
"Modules can be mapped to a file/directory hierarchy. Let's break down the "
"[visibility example](visibility.md) in files:"
msgstr "모듈은 파일/디렉토리 계층 구조에 매핑될 수 있습니다. [가시성 예제](visibility.md)를 파일별로 나누어 봅시다:"

#: src/mod/split.md:16
msgid "In `split.rs`:"
msgstr "`split.rs`에서:"

#: src/mod/split.md:19
msgid ""
"// This declaration will look for a file named `my.rs` and will\n"
"// insert its contents inside a module named `my` under this scope\n"
msgstr ""
"// 이 선언은 `my.rs`라는 파일을 찾아 그 내용을\n"
"// 이 스코프 아래의 `my`라는 이름의 모듈로 삽입할 것입니다\n"

#: src/mod/split.md:39
msgid "In `my.rs`:"
msgstr "`my.rs`에서:"

#: src/mod/split.md:42
msgid ""
"// Similarly `mod inaccessible` and `mod nested` will locate the "
"`nested.rs`\n"
"// and `inaccessible.rs` files and insert them here under their respective\n"
"// modules\n"
msgstr ""
"// 마찬가지로 `mod inaccessible`과 `mod nested`는 `nested.rs`와\n"
"// `inaccessible.rs` 파일을 찾아 각각의 모듈 아래에\n"
"// 삽입할 것입니다\n"

#: src/mod/split.md:53
msgid "\"called `my::private_function()`\""
msgstr "\"`my::private_function()` 호출됨\""

#: src/mod/split.md:57
msgid "\"called `my::indirect_access()`, that\\n> \""
msgstr "\"`my::indirect_access()` 호출됨, 결과는\\n> \""

#: src/mod/split.md:63
msgid "In `my/nested.rs`:"
msgstr "`my/nested.rs`에서:"

#: src/mod/split.md:67
msgid "\"called `my::nested::function()`\""
msgstr "\"`my::nested::function()` 호출됨\""

#: src/mod/split.md:72
msgid "\"called `my::nested::private_function()`\""
msgstr "\"`my::nested::private_function()` 호출됨\""

#: src/mod/split.md:76
msgid "In `my/inaccessible.rs`:"
msgstr "`my/inaccessible.rs`에서:"

#: src/mod/split.md:81
msgid "\"called `my::inaccessible::public_function()`\""
msgstr "\"`my::inaccessible::public_function()` 호출됨\""

#: src/mod/split.md:85
msgid "Let's check that things still work as before:"
msgstr "모든 것이 이전과 같이 여전히 잘 작동하는지 확인해 봅시다:"

#: src/crates.md:3
msgid ""
"A crate is a compilation unit in Rust. Whenever `rustc some_file.rs` is "
"called, `some_file.rs` is treated as the _crate file_. If `some_file.rs` has "
"`mod` declarations in it, then the contents of the module files would be "
"inserted in places where `mod` declarations in the crate file are found, "
"_before_ running the compiler over it. In other words, modules do _not_ get "
"compiled individually, only crates get compiled."
msgstr "크레이트(crate)는 Rust의 컴파일 단위입니다. `rustc some_file.rs`가 호출될 때마다 `some_file.rs`는 _크레이트 파일_로 처리됩니다. 만약 `some_file.rs` 내부에 `mod` 선언이 있다면, 컴파일러가 실행되기 _전_에 크레이트 파일에서 `mod` 선언이 발견된 위치에 모듈 파일의 내용이 삽입됩니다. 즉, 모듈은 개별적으로 컴파일되지 않으며 오직 크레이트만 컴파일됩니다."

#: src/crates.md:10
msgid ""
"A crate can be compiled into a binary or into a library. By default, `rustc` "
"will produce a binary from a crate. This behavior can be overridden by "
"passing the `--crate-type` flag to `lib`."
msgstr "크레이트는 바이너리 또는 라이브러리로 컴파일될 수 있습니다. 기본적으로 `rustc`는 크레이트로부터 바이너리를 생성합니다. 이 동작은 `--crate-type` 플래그에 `lib`을 전달하여 재정의할 수 있습니다."

#: src/crates/lib.md:3
msgid "Let's create a library, and then see how to link it to another crate."
msgstr "라이브러리를 만든 다음, 이를 다른 크레이트와 어떻게 연결하는지 살펴봅시다."

#: src/crates/lib.md:5
msgid "In `rary.rs`:"
msgstr "`rary.rs`에서:"

#: src/crates/lib.md:9 src/attribute/crate.md:19
msgid "\"called rary's `public_function()`\""
msgstr "rary의 `public_function()` 호출됨"

#: src/crates/lib.md:13 src/attribute/crate.md:23
msgid "\"called rary's `private_function()`\""
msgstr "rary의 `private_function()` 호출됨"

#: src/crates/lib.md:17 src/attribute/crate.md:27
msgid "\"called rary's `indirect_access()`, that\\n> \""
msgstr "rary의 `indirect_access()` 호출됨, 결과는\\n> \""

#: src/crates/lib.md:29
msgid ""
"Libraries get prefixed with \"lib\", and by default they get named after "
"their crate file, but this default name can be overridden by passing the `--"
"crate-name` option to `rustc` or by using the [`crate_name` attribute](../"
"attribute/crate.md)."
msgstr "라이브러리에는 \"lib\" 접두사가 붙으며, 기본적으로 크레이트 파일의 이름을 따서 명명되지만, 이 기본 이름은 `rustc`에 `--crate-name` 옵션을 전달하거나 [`crate_name` 속성](../attribute/crate.md)을 사용하여 재정의할 수 있습니다."

#: src/crates/using_lib.md:3
msgid ""
"To link a crate to this new library you may use `rustc`'s `--extern` flag. "
"All of its items will then be imported under a module named the same as the "
"library. This module generally behaves the same way as any other module."
msgstr "이 새로운 라이브러리에 크레이트를 연결하려면 `rustc`의 `--extern` 플래그를 사용할 수 있습니다. 그러면 모든 아이템은 라이브러리와 동일한 이름을 가진 모듈 아래로 임포트됩니다. 이 모듈은 일반적으로 다른 모듈과 동일하게 동작합니다."

#: src/crates/using_lib.md:8
msgid ""
"// extern crate rary; // May be required for Rust 2015 edition or earlier\n"
msgstr "// extern crate rary; // Rust 2015 에디션 이하에서는 필요할 수 있습니다\n"

#: src/crates/using_lib.md:13
msgid ""
"// Error! `private_function` is private\n"
"    //rary::private_function();\n"
msgstr ""
"// 에러! `private_function`은 비공개입니다\n"
"// rary::private_function();\n"

#: src/cargo.md:3
msgid ""
"`cargo` is the official Rust package management tool. It has lots of really "
"useful features to improve code quality and developer velocity! These include"
msgstr "`cargo`는 Rust 공식 패키지 관리 도구입니다. 코드 품질과 개발 속도를 향상시키기 위한 정말 유용한 기능들을 많이 가지고 있습니다! 다음과 같은 기능들이 포함됩니다:"

#: src/cargo.md:6
msgid ""
"Dependency management and integration with [crates.io](https://crates.io) "
"(the official Rust package registry)"
msgstr "[crates.io](https://crates.io) (공식 Rust 패키지 레지스트리)와의 통합 및 의존성 관리"

#: src/cargo.md:8
msgid "Awareness of unit tests"
msgstr "유닛 테스트 지원"

#: src/cargo.md:9
msgid "Awareness of benchmarks"
msgstr "벤치마크 지원"

#: src/cargo.md:11
msgid ""
"This chapter will go through some quick basics, but you can find the "
"comprehensive docs in [The Cargo Book](https://doc.rust-lang.org/cargo/)."
msgstr "이 장에서는 기본적인 사항들을 빠르게 살펴볼 것입니다. 더 자세한 문서는 [The Cargo Book](https://doc.rust-lang.org/cargo/)에서 찾을 수 있습니다."

#: src/cargo/deps.md:3
msgid ""
"Most programs have dependencies on some libraries. If you have ever managed "
"dependencies by hand, you know how much of a pain this can be. Luckily, the "
"Rust ecosystem comes standard with `cargo`! `cargo` can manage dependencies "
"for a project."
msgstr "대부분의 프로그램은 일부 라이브러리에 의존성을 가집니다. 의존성을 수동으로 관리해 본 적이 있다면 그것이 얼마나 고통스러운 일인지 알 것입니다. 다행히도 Rust 생태계에는 `cargo`가 표준으로 포함되어 있습니다! `cargo`는 프로젝트의 의존성을 관리할 수 있습니다."

#: src/cargo/deps.md:8
msgid "To create a new Rust project,"
msgstr "새로운 Rust 프로젝트를 만들려면,"

#: src/cargo/deps.md:11
msgid "# A binary\n"
msgstr "# 바이너리\n"

#: src/cargo/deps.md:13
msgid "# A library\n"
msgstr "# 라이브러리\n"

#: src/cargo/deps.md:18
msgid ""
"For the rest of this chapter, let's assume we are making a binary, rather "
"than a library, but all of the concepts are the same."
msgstr "이 장의 나머지 부분에서는 라이브러리가 아닌 바이너리를 만든다고 가정하겠습니다. 하지만 모든 개념은 동일합니다."

#: src/cargo/deps.md:21
msgid "After the above commands, you should see a file hierarchy like this:"
msgstr "위의 명령어를 실행한 후에는 다음과 같은 파일 계층 구조를 보게 될 것입니다:"

#: src/cargo/deps.md:35
msgid ""
"The `main.rs` is the root source file for your new `foo` project -- nothing "
"new there. The `Cargo.toml` is the config file for `cargo` for this project. "
"If you look inside it, you should see something like this:"
msgstr "`main.rs`는 새로운 `foo` 프로젝트의 루트 소스 파일입니다. 특별할 것은 없습니다. `Cargo.toml`은 이 프로젝트에 대한 `cargo` 설정 파일입니다. 그 안을 들여다보면 다음과 같은 내용을 볼 수 있을 것입니다:"

#: src/cargo/deps.md:39
msgid ""
"```toml\n"
"[package]\n"
"name = \"foo\"\n"
"version = \"0.1.0\"\n"
"authors = [\"mark\"]\n"
"\n"
"[dependencies]\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"foo\"\n"
"version = \"0.1.0\"\n"
"authors = [\"mark\"]\n"
"\n"
"[dependencies]\n"
"```"

#: src/cargo/deps.md:48
msgid ""
"The `name` field under `[package]` determines the name of the project. This "
"is used by `crates.io` if you publish the crate (more later). It is also the "
"name of the output binary when you compile."
msgstr "`[package]` 아래의 `name` 필드는 프로젝트의 이름을 결정합니다. 이는 크레이트를 배포할 때(나중에 자세히 설명함) `crates.io`에서 사용됩니다. 또한 컴파일할 때 생성되는 바이너리의 이름이기도 합니다."

#: src/cargo/deps.md:52
msgid ""
"The `version` field is a crate version number using [Semantic Versioning]"
"(http://semver.org/)."
msgstr "`version` 필드는 [유의적 버전(Semantic Versioning)](http://semver.org/)을 사용하는 크레이트 버전 번호입니다."

#: src/cargo/deps.md:55
msgid ""
"The `authors` field is a list of authors used when publishing the crate."
msgstr "`authors` 필드는 크레이트를 배포할 때 사용되는 작성자 목록입니다."

#: src/cargo/deps.md:57
msgid ""
"The `[dependencies]` section lets you add dependencies for your project."
msgstr "`[dependencies]` 섹션에서는 프로젝트에 필요한 의존성을 추가할 수 있습니다."

#: src/cargo/deps.md:59
msgid ""
"For example, suppose that we want our program to have a great CLI. You can "
"find lots of great packages on [crates.io](https://crates.io) (the official "
"Rust package registry). One popular choice is [clap](https://crates.io/"
"crates/clap). As of this writing, the most recent published version of "
"`clap` is `2.27.1`. To add a dependency to our program, we can simply add "
"the following to our `Cargo.toml` under `[dependencies]`: `clap = "
msgstr "예를 들어, 우리 프로그램이 멋진 CLI를 갖기를 원한다고 가정해 봅시다. [crates.io](https://crates.io) (공식 Rust 패키지 레지스트리)에서 훌륭한 패키지들을 많이 찾을 수 있습니다. 인기 있는 선택지 중 하나는 [clap](https://crates.io/crates/clap)입니다. 이 글을 쓰는 시점에서 `clap`의 최신 버전은 `2.27.1`입니다. 프로그램에 의존성을 추가하려면 `Cargo.toml`의 `[dependencies]` 아래에 다음과 같이 추가하면 됩니다: `clap = "
"\"2.27.1\"`. And that's it! You can start using `clap` in your program."
msgstr "\"2.27.1\"`. 이것으로 끝입니다! 이제 프로그램에서 `clap`을 사용할 수 있습니다."

#: src/cargo/deps.md:67
msgid ""
"`cargo` also supports [other types of dependencies](https://doc.rust-"
"lang.org/cargo/reference/specifying-dependencies.html). Here is just a small "
"sampling:"
msgstr "`cargo`는 [다른 유형의 의존성](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html)도 지원합니다. 다음은 몇 가지 예시입니다:"

#: src/cargo/deps.md:70
msgid ""
"```toml\n"
"[package]\n"
"name = \"foo\"\n"
"version = \"0.1.0\"\n"
"authors = [\"mark\"]\n"
"\n"
"[dependencies]\n"
"clap = \"2.27.1\" # from crates.io\n"
"rand = { git = \"https://github.com/rust-lang-nursery/rand\" } # from online "
"repo\n"
"bar = { path = \"../bar\" } # from a path in the local filesystem\n"
"```"
msgstr ""

#: src/cargo/deps.md:82
msgid ""
"`cargo` is more than a dependency manager. All of the available "
"configuration options are listed in the [format specification](https://"
"doc.rust-lang.org/cargo/reference/manifest.html) of `Cargo.toml`."
msgstr "`cargo`는 단순한 의존성 관리자 그 이상입니다. 사용 가능한 모든 설정 옵션은 `Cargo.toml`의 [형식 명세(format specification)](https://doc.rust-lang.org/cargo/reference/manifest.html)에 나열되어 있습니다."

#: src/cargo/deps.md:86
msgid ""
"To build our project we can execute `cargo build` anywhere in the project "
"directory (including subdirectories!). We can also do `cargo run` to build "
"and run. Notice that these commands will resolve all dependencies, download "
"crates if needed, and build everything, including your crate. (Note that it "
"only rebuilds what it has not already built, similar to `make`)."
msgstr "프로젝트를 빌드하려면 프로젝트 디렉토리 어디에서나(하위 디렉토리 포함!) `cargo build`를 실행하면 됩니다. 또한 `cargo run`을 통해 빌드와 실행을 동시에 할 수도 있습니다. 이 명령어들은 모든 의존성을 해결하고, 필요한 경우 크레이트를 다운로드하며, 여러분의 크레이트를 포함한 모든 것을 빌드합니다. (이미 빌드된 것은 다시 빌드하지 않으며, 이는 `make`와 유사합니다)."

#: src/cargo/deps.md:92
msgid "Voila! That's all there is to it!"
msgstr "보세요! 이게 전부입니다!"

#: src/cargo/conventions.md:3
msgid "In the previous chapter, we saw the following directory hierarchy:"
msgstr ""

#: src/cargo/conventions.md:12
msgid ""
"Suppose that we wanted to have two binaries in the same project, though. "
"What then?"
msgstr ""

#: src/cargo/conventions.md:15
msgid ""
"It turns out that `cargo` supports this. The default binary name is `main`, "
"as we saw before, but you can add additional binaries by placing them in a "
"`bin/` directory:"
msgstr ""

#: src/cargo/conventions.md:28
msgid ""
"To tell `cargo` to only compile or run this binary, we just pass `cargo` the "
"`--bin my_other_bin` flag, where `my_other_bin` is the name of the binary we "
"want to work with."
msgstr ""

#: src/cargo/conventions.md:32
msgid ""
"In addition to extra binaries, `cargo` supports [more features](https://"
"doc.rust-lang.org/cargo/guide/project-layout.html) such as benchmarks, "
"tests, and examples."
msgstr ""

#: src/cargo/conventions.md:35
msgid "In the next chapter, we will look more closely at tests."
msgstr ""

#: src/cargo/test.md:3
msgid ""
"As we know testing is integral to any piece of software! Rust has first-"
"class support for unit and integration testing ([see this chapter](https://"
"doc.rust-lang.org/book/ch11-00-testing.html) in TRPL)."
msgstr ""

#: src/cargo/test.md:7
msgid ""
"From the testing chapters linked above, we see how to write unit tests and "
"integration tests. Organizationally, we can place unit tests in the modules "
"they test and integration tests in their own `tests/` directory:"
msgstr ""

#: src/cargo/test.md:22
msgid ""
"Each file in `tests` is a separate [integration test](https://doc.rust-"
"lang.org/book/ch11-03-test-organization.html#integration-tests), i.e. a test "
"that is meant to test your library as if it were being called from a "
"dependent crate."
msgstr "`tests` 내의 각 파일은 별도의 [통합 테스트](https://doc.rust-lang.org/book/ch11-03-test-organization.html#integration-tests)입니다. 즉, 의존성 있는 크레이트에서 호출되는 것처럼 라이브러리를 테스트하기 위한 것입니다."

#: src/cargo/test.md:27
msgid ""
"The [Testing](../testing.md) chapter elaborates on the three different "
"testing styles: [Unit](../testing/unit_testing.md), [Doc](../testing/"
"doc_testing.md), and [Integration](../testing/integration_testing.md)."
msgstr "[테스트](../testing.md) 장에서는 [유닛(Unit)](../testing/unit_testing.md), [문서(Doc)](../testing/doc_testing.md), [통합(Integration)](../testing/integration_testing.md)의 세 가지 테스트 스타일에 대해 자세히 설명합니다."

#: src/cargo/test.md:30
msgid "`cargo` naturally provides an easy way to run all of your tests!"
msgstr "`cargo`는 당연히 모든 테스트를 실행할 수 있는 쉬운 방법을 제공합니다!"

#: src/cargo/test.md:36
msgid "You should see output like this:"
msgstr "다음과 같은 출력을 볼 수 있을 것입니다:"

#: src/cargo/test.md:38
msgid ""
"```shell\n"
"$ cargo test\n"
"   Compiling blah v0.1.0 (file:///nobackup/blah)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.89 secs\n"
"     Running target/debug/deps/blah-d3b32b97275ec472\n"
"\n"
"running 4 tests\n"
"test test_bar ... ok\n"
"test test_baz ... ok\n"
"test test_foo_bar ... ok\n"
"test test_foo ... ok\n"
"\n"
"test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n"
"```"
msgstr ""
"```shell\n"
"$ cargo test\n"
"   Compiling blah v0.1.0 (file:///nobackup/blah)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.89 secs\n"
"     Running target/debug/deps/blah-d3b32b97275ec472\n"
"\n"
"running 4 tests\n"
"test test_bar ... ok\n"
"test test_baz ... ok\n"
"test test_foo_bar ... ok\n"
"test test_foo ... ok\n"
"\n"
"test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n"
"```"
"```shell\n"
"$ cargo test\n"
"   Compiling blah v0.1.0 (file:///nobackup/blah)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.89 secs\n"
"     Running target/debug/deps/blah-d3b32b97275ec472\n"
"\n"
"running 4 tests\n"
"test test_bar ... ok\n"
"test test_baz ... ok\n"
"test test_foo_bar ... ok\n"
"test test_foo ... ok\n"
"\n"
"test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n"
"```"

#: src/cargo/test.md:53
msgid "You can also run tests whose name matches a pattern:"
msgstr "이름이 패턴과 일치하는 테스트만 실행할 수도 있습니다:"

#: src/cargo/test.md:59
msgid ""
"```shell\n"
"$ cargo test test_foo\n"
"   Compiling blah v0.1.0 (file:///nobackup/blah)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.35 secs\n"
"     Running target/debug/deps/blah-d3b32b97275ec472\n"
"\n"
"running 2 tests\n"
"test test_foo ... ok\n"
"test test_foo_bar ... ok\n"
"\n"
"test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out\n"
"```"
msgstr ""
"```shell\n"
"$ cargo test test_foo\n"
"   Compiling blah v0.1.0 (file:///nobackup/blah)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.35 secs\n"
"     Running target/debug/deps/blah-d3b32b97275ec472\n"
"\n"
"running 2 tests\n"
"test test_foo ... ok\n"
"test test_foo_bar ... ok\n"
"\n"
"test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out\n"
"```"

#: src/cargo/test.md:72
msgid ""
"One word of caution: Cargo may run multiple tests concurrently, so make sure "
"that they don't race with each other."
msgstr "한 가지 주의할 점: Cargo는 여러 테스트를 동시에 실행할 수 있으므로 서로 경쟁(race)하지 않도록 확인해야 합니다."

#: src/cargo/test.md:75
msgid ""
"One example of this concurrency causing issues is if two tests output to a "
"file, such as below:"
msgstr "이러한 동시성이 문제를 일으키는 한 가지 예는 아래와 같이 두 테스트가 하나의 파일에 출력하는 경우입니다:"

#: src/cargo/test.md:81
msgid "// Import the necessary modules\n"
msgstr "// 필요한 모듈 가져오기\n"

#: src/cargo/test.md:85
msgid "// This test writes to a file\n"
msgstr "// 이 테스트는 파일에 씁니다\n"

#: src/cargo/test.md:88 src/cargo/test.md:105
msgid "// Opens the file ferris.txt or creates one if it doesn't exist.\n"
msgstr "// ferris.txt 파일을 열거나 없으면 생성합니다.\n"

#: src/cargo/test.md:92 src/cargo/test.md:109
msgid "\"ferris.txt\""
msgstr "\"ferris.txt\""

#: src/cargo/test.md:93 src/cargo/test.md:110
msgid "\"Failed to open ferris.txt\""
msgstr "\"ferris.txt를 여는 데 실패했습니다\""

#: src/cargo/test.md:95
msgid "// Print \"Ferris\" 5 times.\n"
msgstr "// \"Ferris\"를 5번 출력합니다.\n"

#: src/cargo/test.md:97
msgid "\"Ferris\\n\""
msgstr "\"Ferris\\n\""

#: src/cargo/test.md:98 src/cargo/test.md:115
msgid "\"Could not write to ferris.txt\""
msgstr "\"ferris.txt에 쓸 수 없습니다\""

#: src/cargo/test.md:102
msgid "// This test tries to write to the same file\n"
msgstr "// 이 테스트는 동일한 파일에 쓰기를 시도합니다\n"

#: src/cargo/test.md:112
msgid "// Print \"Corro\" 5 times.\n"
msgstr "// \"Corro\"를 5번 출력합니다.\n"

#: src/cargo/test.md:114
msgid "\"Corro\\n\""
msgstr "\"Corro\\n\""

#: src/cargo/test.md:121
msgid "Although the intent is to get the following:"
msgstr "의도는 다음과 같은 결과를 얻는 것이었지만:"

#: src/cargo/test.md:137
msgid "What actually gets put into `ferris.txt` is this:"
msgstr "`ferris.txt`에 실제로 기록된 내용은 다음과 같습니다:"

#: src/cargo/build_scripts.md:3
msgid ""
"Sometimes a normal build from `cargo` is not enough. Perhaps your crate "
"needs some pre-requisites before `cargo` will successfully compile, things "
"like code generation, or some native code that needs to be compiled. To "
"solve this problem we have build scripts that Cargo can run."
msgstr "`cargo`의 일반적인 빌드만으로는 충분하지 않은 경우가 있습니다. 코드 생성이나 컴파일되어야 하는 네이티브 코드와 같이 `cargo`가 성공적으로 컴파일되기 전에 크레이트가 필요로 하는 전제 조건이 있을 수 있습니다. 이 문제를 해결하기 위해 Cargo가 실행할 수 있는 빌드 스크립트가 있습니다."

#: src/cargo/build_scripts.md:8
msgid ""
"To add a build script to your package it can either be specified in the "
""`Cargo.toml` as follows:"
msgstr "패키지에 빌드 스크립트를 추가하려면 다음과 같이 `Cargo.toml`에 지정할 수 있습니다:"

#: src/cargo/build_scripts.md:11
msgid ""
"```toml\n"
"[package]\n"
"...\n"
"build = \"build.rs\"\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"...\n"
"build = \"build.rs\"\n"
"```"

#: src/cargo/build_scripts.md:17
msgid ""
"Otherwise Cargo will look for a `build.rs` file in the project directory by "
"default."
msgstr "그렇지 않으면 Cargo는 기본적으로 프로젝트 디렉토리에서 `build.rs` 파일을 찾습니다."

#: src/cargo/build_scripts.md:20
msgid "How to use a build script"
msgstr "빌드 스크립트 사용 방법"

#: src/cargo/build_scripts.md:22
msgid ""
"The build script is simply another Rust file that will be compiled and "
"invoked prior to compiling anything else in the package. Hence it can be "
"used to fulfill pre-requisites of your crate."
msgstr "빌드 스크립트는 단순히 또 다른 Rust 파일로, 패키지의 다른 어떤 것을 컴파일하기 전에 먼저 컴파일되고 호출됩니다. 따라서 크레이트의 전제 조건을 충족시키는 데 사용할 수 있습니다."

#: src/cargo/build_scripts.md:26
msgid ""
"Cargo provides the script with inputs via environment variables [specified "
"here](https://doc.rust-lang.org/cargo/reference/environment-"
"variables.html#environment-variables-cargo-sets-for-build-scripts) that can "
"be used."
msgstr "Cargo는 스크립트에서 사용할 수 있는 환경 변수([여기에 명시됨](https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts))를 통해 입력을 제공합니다."

#: src/cargo/build_scripts.md:29
msgid ""
"The script provides output via stdout. All lines printed are written to "
"`target/debug/build/<pkg>/output`. Further, lines prefixed with `cargo:` "
"will be interpreted by Cargo directly and hence can be used to define "
"parameters for the package's compilation."
msgstr "스크립트는 stdout을 통해 출력을 제공합니다. 출력된 모든 줄은 `target/debug/build/<pkg>/output`에 기록됩니다. 또한, `cargo:`로 시작하는 줄은 Cargo에 의해 직접 해석되어 패키지 컴파일을 위한 매개변수를 정의하는 데 사용될 수 있습니다."

#: src/cargo/build_scripts.md:34
msgid ""
"For further specification and examples have a read of the [Cargo "
"specification](https://doc.rust-lang.org/cargo/reference/build-scripts.html)."
msgstr "추가적인 사양과 예제는 [Cargo 사양서](https://doc.rust-lang.org/cargo/reference/build-scripts.html)를 읽어보세요."

#: src/attribute.md:3
msgid ""
"An attribute is metadata applied to some module, crate or item. This "
"metadata can be used to/for:"
msgstr "속성(attribute)은 모듈, 크레이트 또는 아이템에 적용되는 메타데이터입니다. 이 메타데이터는 다음과 같은 용도로 사용될 수 있습니다:"

#: src/attribute.md:8
msgid "[conditional compilation of code](attribute/cfg.md)"
msgstr "코드의 [조건부 컴파일](attribute/cfg.md)"

#: src/attribute.md:9
msgid ""
"[set crate name, version and type (binary or library)](attribute/crate.md)"
msgstr "[크레이트 이름, 버전 및 유형(바이너리 또는 라이브러리) 설정](attribute/crate.md)"

#: src/attribute.md:10
msgid ""
"disable [lints](https://en.wikipedia.org/wiki/Lint_%28software%29) (warnings)"
msgstr "[린트(lints)](https://en.wikipedia.org/wiki/Lint_%28software%29) (경고) 비활성화"

#: src/attribute.md:11
msgid "enable compiler features (macros, glob imports, etc.)"
msgstr "컴파일러 기능(매크로, glob 임포트 등) 활성화"

#: src/attribute.md:12
msgid "link to a foreign library"
msgstr "외부 라이브러리 링크"

#: src/attribute.md:13
msgid "mark functions as unit tests"
msgstr "함수를 유닛 테스트로 표시"

#: src/attribute.md:14
msgid "mark functions that will be part of a benchmark"
msgstr "벤치마크의 일부가 될 함수 표시"

#: src/attribute.md:15
msgid ""
"[attribute like macros](https://doc.rust-lang.org/book/ch19-06-"
"macros.html#attribute-like-macros)"
msgstr "[속성형 매크로](https://doc.rust-lang.org/book/ch19-06-macros.html#attribute-like-macros)"

#: src/attribute.md:17
msgid ""
"Attributes look like `#[outer_attribute]` or `#![inner_attribute]`, with the "
"difference between them being where they apply."
msgstr "속성은 `#[outer_attribute]` 또는 `#![inner_attribute]`와 같은 형태를 띠며, 이 둘의 차이점은 적용되는 위치에 있습니다."

#: src/attribute.md:20
msgid ""
"`#[outer_attribute]` applies to the [item](https://doc.rust-lang.org/stable/"
"reference/items.html) immediately following it. Some examples of items are: "
"a function, a module declaration, a constant, a structure, an enum. Here is "
"an example where attribute `#[derive(Debug)]` applies to the struct "
"`Rectangle`:"
msgstr "`#[outer_attribute]`는 바로 뒤에 오는 [아이템](https://doc.rust-lang.org/stable/reference/items.html)에 적용됩니다. 아이템의 예로는 함수, 모듈 선언, 상수, 구조체, 열거형 등이 있습니다. 다음은 `#[derive(Debug)]` 속성이 `Rectangle` 구조체에 적용된 예시입니다:"

#: src/attribute.md:34
msgid ""
"`#![inner_attribute]` applies to the enclosing [item](https://doc.rust-"
"lang.org/stable/reference/items.html) (typically a module or a crate). In "
"other words, this attribute is interpreted as applying to the entire scope "
"in which it's placed. Here is an example where `#![allow(unused_variables)]` "
"applies to the whole crate (if placed in `main.rs`):"
msgstr "`#![inner_attribute]`는 자신을 감싸고 있는 [아이템](https://doc.rust-lang.org/stable/reference/items.html) (주로 모듈이나 크레이트)에 적용됩니다. 다시 말해, 이 속성은 자신이 위치한 전체 스코프에 적용되는 것으로 해석됩니다. 다음은 `#![allow(unused_variables)]`가 (`main.rs`에 위치할 경우) 전체 크레이트에 적용되는 예시입니다:"

#: src/attribute.md:44
msgid "// This would normally warn about an unused variable.\n"
msgstr "// 이것은 보통 사용되지 않는 변수에 대해 경고합니다.\n"

#: src/attribute.md:48
msgid "Attributes can take arguments with different syntaxes:"
msgstr "속성은 다양한 문법으로 인자를 받을 수 있습니다:"

#: src/attribute.md:50
msgid "`#[attribute = \"value\"]`"
msgstr "`#[attribute = \"value\"]`"

#: src/attribute.md:51
msgid "`#[attribute(key = \"value\")]`"
msgstr "`#[attribute(key = \"value\")]`"

#: src/attribute.md:52
msgid "`#[attribute(value)]`"
msgstr "`#[attribute(value)]`"

#: src/attribute.md:54
msgid ""
"Attributes can have multiple values and can be separated over multiple "
"lines, too:"
msgstr "속성은 여러 값을 가질 수 있으며 여러 줄에 걸쳐 분리될 수도 있습니다:"

#: src/attribute/unused.md:3
msgid ""
"The compiler provides a `dead_code` [_lint_](https://en.wikipedia.org/wiki/"
"Lint_%28software%29) that will warn about unused functions. An _attribute_ "
"can be used to disable the lint."
msgstr "컴파일러는 사용되지 않는 함수에 대해 경고하는 `dead_code` [_린트(lint)_](https://en.wikipedia.org/wiki/Lint_%28software%29)를 제공합니다. _속성_을 사용하여 이 린트를 비활성화할 수 있습니다."

#: src/attribute/unused.md:9
msgid ""
"// `#[allow(dead_code)]` is an attribute that disables the `dead_code` lint\n"
msgstr ""
"// `#[allow(dead_code)]`는 `dead_code` 린트를 비활성화하는 속성입니다\n"

#: src/attribute/unused.md:14
msgid "// FIXME ^ Add an attribute to suppress the warning\n"
msgstr "// FIXME ^ 경고를 억제하기 위해 속성을 추가하세요\n"

#: src/attribute/unused.md:22
msgid ""
"Note that in real programs, you should eliminate dead code. In these "
"examples we'll allow dead code in some places because of the interactive "
"nature of the examples."
msgstr "실제 프로그램에서는 죽은 코드를 제거해야 합니다. 이 예제들에서는 예제의 대화형 특성 때문에 일부 장소에서 죽은 코드를 허용할 것입니다."

#: src/attribute/crate.md:3
msgid ""
"The `crate_type` attribute can be used to tell the compiler whether a crate "
"is a binary or a library (and even which type of library), and the "
"`crate_name` attribute can be used to set the name of the crate."
msgstr "`crate_type` 속성은 크레이트가 바이너리인지 라이브러리인지(심지어 어떤 종류의 라이브러리인지) 컴파일러에게 알려주는 데 사용될 수 있으며, `crate_name` 속성은 크레이트의 이름을 설정하는 데 사용될 수 있습니다."

#: src/attribute/crate.md:7
msgid ""
"However, it is important to note that both the `crate_type` and `crate_name` "
"attributes have **no** effect whatsoever when using Cargo, the Rust package "
"manager. Since Cargo is used for the majority of Rust projects, this means "
"real-world uses of `crate_type` and `crate_name` are relatively limited."
msgstr "하지만 Rust 패키지 관리자인 Cargo를 사용할 때는 `crate_type`과 `crate_name` 속성 모두 **아무런** 효과가 없다는 점에 유의해야 합니다. 대다수의 Rust 프로젝트가 Cargo를 사용하므로, `crate_type`과 `crate_name`의 실제 사용은 상대적으로 제한적입니다."

#: src/attribute/crate.md:13
msgid "// This crate is a library\n"
msgstr "// 이 크레이트는 라이브러리입니다\n"

#: src/attribute/crate.md:14
msgid "\"lib\""
msgstr "\"lib\""

#: src/attribute/crate.md:14
msgid "// The library is named \"rary\"\n"
msgstr "// 라이브러리 이름은 \"rary\"입니다\n"

#: src/attribute/crate.md:16
msgid "\"rary\""
msgstr "\"rary\""

#: src/attribute/crate.md:33
msgid ""
"When the `crate_type` attribute is used, we no longer need to pass the `--"
"crate-type` flag to `rustc`."
msgstr "`crate_type` 속성이 사용되면, 더 이상 `rustc`에 `--crate-type` 플래그를 전달할 필요가 없습니다."

#: src/attribute/cfg.md:3
msgid ""
"Configuration conditional checks are possible through two different "
"operators:"
msgstr "설정 조건 검사는 두 가지 다른 연산자를 통해 가능합니다:"

#: src/attribute/cfg.md:5
msgid "the `cfg` attribute: `#[cfg(...)]` in attribute position"
msgstr "`cfg` 속성: 속성 위치에서의 `#[cfg(...)]`"

#: src/attribute/cfg.md:6
msgid "the `cfg!` macro: `cfg!(...)` in boolean expressions"
msgstr "`cfg!` 매크로: 불리언 표현식에서의 `cfg!(...)`"

#: src/attribute/cfg.md:8
msgid ""
"While the former enables conditional compilation, the latter conditionally "
"evaluates to `true` or `false` literals, allowing for checks at run-time. "
"Both utilize identical argument syntax."
msgstr "전자는 조건부 컴파일을 가능하게 하는 반면, 후자는 조건부로 `true` 또는 `false` 리터럴로 평가되어 런타임에 검사를 가능하게 합니다. 둘 다 동일한 인자 문법을 사용합니다."
"evaluates to `true` or `false` literals allowing for checks at run-time. "
"Both utilize identical argument syntax."
msgstr ""

#: src/attribute/cfg.md:12
msgid ""
"`cfg!`, unlike `#[cfg]`, does not remove any code and only evaluates to true "
"or false. For example, all blocks in an if/else expression need to be valid "
"when `cfg!` is used for the condition, regardless of what `cfg!` is "
"evaluating."
msgstr "`cfg!`는 `#[cfg]`와 달리 코드를 제거하지 않으며 오직 참 또는 거짓으로만 평가됩니다. 예를 들어 `cfg!`가 조건으로 사용될 때, `cfg!`가 무엇으로 평가되든 상관없이 if/else 표현식의 모든 블록은 유효해야 합니다."

#: src/attribute/cfg.md:15
msgid "// This function only gets compiled if the target OS is linux\n"
msgstr "// 이 함수는 대상 OS가 리눅스인 경우에만 컴파일됩니다\n"

#: src/attribute/cfg.md:16 src/attribute/cfg.md:22 src/attribute/cfg.md:31
msgid "\"linux\""
msgstr "\"linux\""

#: src/attribute/cfg.md:18
msgid "\"You are running linux!\""
msgstr "\"당신은 리눅스를 사용하고 있습니다!\""

#: src/attribute/cfg.md:20
msgid ""
"// And this function only gets compiled if the target OS is *not* linux\n"


#: src/generics.md:23
msgid ""
"Because `T` has been specified as a generic type parameter using `<T>`, it "
"is considered generic when used here as `(arg: T)`. This is the case even if "
"`T` has previously been defined as a `struct`."
msgstr ""

#: src/generics.md:27
msgid "This example shows some of the syntax in action:"
msgstr ""

#: src/generics.md:30
msgid "// A concrete type `A`.\n"
msgstr ""

#: src/generics.md:32
msgid ""
"// In defining the type `Single`, the first use of `A` is not preceded by "
"`<A>`.\n"
"// Therefore, `Single` is a concrete type, and `A` is defined as above.\n"
msgstr ""

#: src/generics.md:35
msgid "//            ^ Here is `Single`s first use of the type `A`.\n"
msgstr ""

#: src/generics.md:37
msgid ""
"// Here, `<T>` precedes the first use of `T`, so `SingleGen` is a generic "
"type.\n"
"// Because the type parameter `T` is generic, it could be anything, "
"including\n"
"// the concrete type `A` defined at the top.\n"
msgstr ""

#: src/generics.md:44
msgid "// `Single` is concrete and explicitly takes `A`.\n"
msgstr ""

#: src/generics.md:47
msgid ""
"// Create a variable `_char` of type `SingleGen<char>`\n"
"    // and give it the value `SingleGen('a')`.\n"
"    // Here, `SingleGen` has a type parameter explicitly specified.\n"
msgstr ""

#: src/generics.md:52
msgid "// `SingleGen` can also have a type parameter implicitly specified:\n"
msgstr ""

#: src/generics.md:53
msgid "// Uses `A` defined at the top.\n"
msgstr ""

#: src/generics.md:54
msgid "// Uses `i32`.\n"
msgstr ""

#: src/generics.md:55
msgid "// Uses `char`.\n"
msgstr ""

#: src/generics.md:61
msgid "[`structs`](custom_types/structs.md)"
msgstr ""

#: src/generics/gen_fn.md:3
msgid ""
"The same set of rules can be applied to functions: a type `T` becomes "
"generic when preceded by `<T>`."
msgstr ""

#: src/generics/gen_fn.md:6
msgid ""
"Using generic functions sometimes requires explicitly specifying type "
"parameters. This may be the case if the function is called where the return "
"type is generic, or if the compiler doesn't have enough information to infer "
"the necessary type parameters."
msgstr "제네릭 함수를 사용할 때 때로는 타입 파라미터를 명시적으로 지정해야 할 필요가 있습니다. 반환 타입이 제네릭인 곳에서 함수가 호출되거나, 컴파일러가 필요한 타입 파라미터를 추론하기에 충분한 정보를 가지고 있지 않은 경우가 이에 해당할 수 있습니다."

#: src/generics/gen_fn.md:11
msgid ""
"A function call with explicitly specified type parameters looks like: `fun::"
"<A, B, ...>()`."
msgstr "명시적으로 지정된 타입 파라미터를 사용한 함수 호출은 다음과 같습니다: `fun::<A, B, ...>()`."

#: src/generics/gen_fn.md:15
msgid "// Concrete type `A`.\n"
msgstr "// 구체적인 타입 `A`.\n"

#: src/generics/gen_fn.md:16
msgid "// Concrete type `S`.\n"
msgstr "// 구체적인 타입 `S`.\n"

#: src/generics/gen_fn.md:17
msgid "// Generic type `SGen`.\n"
msgstr "// 제네릭 타입 `SGen`.\n"

#: src/generics/gen_fn.md:18
msgid ""
"// The following functions all take ownership of the variable passed into\n"
"// them and immediately go out of scope, freeing the variable.\n"
msgstr ""
"// 다음 함수들은 모두 전달된 변수의 소유권을 가져가며,\n"
"// 즉시 스코프를 벗어나 변수를 해제합니다.\n"

#: src/generics/gen_fn.md:21
msgid ""
"// Define a function `reg_fn` that takes an argument `_s` of type `S`.\n"
"// This has no `<T>` so this is not a generic function.\n"
msgstr ""
"// `S` 타입의 인자 `_s`를 받는 `reg_fn` 함수를 정의합니다.\n"
"// `<T>`가 없으므로 이것은 제네릭 함수가 아닙니다.\n"

#: src/generics/gen_fn.md:25
msgid ""
"// Define a function `gen_spec_t` that takes an argument `_s` of type "
"`SGen<T>`.\n"
"// It has been explicitly given the type parameter `A`, but because `A` has "
"not\n"
"// been specified as a generic type parameter for `gen_spec_t`, it is not "
"generic.\n"
msgstr ""
"// `SGen<T>` 타입의 인자 `_s`를 받는 `gen_spec_t` 함수를 정의합니다.\n"
"// 타입 파라미터 `A`가 명시적으로 주어졌지만, `A`가 `gen_spec_t`의\n"
"// 제네릭 타입 파라미터로 지정되지 않았으므로, 이것은 제네릭이 아닙니다.\n"

#: src/generics/gen_fn.md:30
msgid ""
"// Define a function `gen_spec_i32` that takes an argument `_s` of type "
"`SGen<i32>`.\n"
"// It has been explicitly given the type parameter `i32`, which is a "
"specific type.\n"
"// Because `i32` is not a generic type, this function is also not generic.\n"
msgstr ""
"// `SGen<i32>` 타입의 인자 `_s`를 받는 `gen_spec_i32` 함수를 정의합니다.\n"
"// 구체적인 타입인 `i32`가 타입 파라미터로 명시적으로 주어졌습니다.\n"
"// `i32`는 제네릭 타입이 아니므로, 이 함수 또한 제네릭이 아닙니다.\n"

#: src/generics/gen_fn.md:35
msgid ""
"// Define a function `generic` that takes an argument `_s` of type "
"`SGen<T>`.\n"
"// Because `SGen<T>` is preceded by `<T>`, this function is generic over "
"`T`.\n"
msgstr ""
"// `SGen<T>` 타입의 인자 `_s`를 받는 `generic` 함수를 정의합니다.\n"
"// `SGen<T>` 앞에 `<T>`가 오기 때문에, 이 함수는 `T`에 대해 제네릭입니다.\n"

#: src/generics/gen_fn.md:41
msgid "// Using the non-generic functions\n"
msgstr "// 제네릭이 아닌 함수들 사용\n"

#: src/generics/gen_fn.md:42
msgid "// Concrete type.\n"
msgstr "// 구체적인 타입.\n"

#: src/generics/gen_fn.md:43
msgid "// Implicitly specified type parameter `A`.\n"
msgstr "// 암시적으로 지정된 타입 파라미터 `A`.\n"

#: src/generics/gen_fn.md:44
msgid "// Implicitly specified type parameter `i32`.\n"
msgstr "// 암시적으로 지정된 타입 파라미터 `i32`.\n"

#: src/generics/gen_fn.md:46
msgid "// Explicitly specified type parameter `char` to `generic()`.\n"
msgstr "// `generic()`에 명시적으로 지정된 타입 파라미터 `char`.\n"

#: src/generics/gen_fn.md:49
msgid "// Implicitly specified type parameter `char` to `generic()`.\n"
msgstr "// `generic()`에 암시적으로 지정된 타입 파라미터 `char`.\n"

#: src/generics/gen_fn.md:50
msgid "'c'"
msgstr "'c'"

#: src/generics/gen_fn.md:56
msgid "[functions](../fn.md) and [`struct`s](../custom_types/structs.md)"
msgstr "[함수](../fn.md)와 [`struct`](../custom_types/structs.md)"

#: src/generics/impl.md:3
msgid "Similar to functions, implementations require care to remain generic."
msgstr "함수와 마찬가지로, 구현(implementation)도 제네릭을 유지하기 위해 주의가 필요합니다."

#: src/generics/impl.md:6
msgid "// Concrete type `S`\n"
msgstr "// 구체적인 타입 `S`\n"

#: src/generics/impl.md:7
msgid "// Generic type `GenericVal`\n"
msgstr "// 제네릭 타입 `GenericVal`\n"

#: src/generics/impl.md:8
msgid "// impl of GenericVal where we explicitly specify type parameters:\n"
msgstr "// 타입 파라미터를 명시적으로 지정한 GenericVal의 구현:\n"

#: src/generics/impl.md:10
msgid "// Specify `f32`\n"
msgstr "// `f32` 지정\n"

#: src/generics/impl.md:11
msgid "// Specify `S` as defined above\n"
msgstr "// 위에서 정의한 `S` 지정\n"

#: src/generics/impl.md:12
msgid "// `<T>` Must precede the type to remain generic\n"
msgstr "// 제네릭을 유지하려면 `<T>`가 타입 앞에 와야 합니다\n"

#: src/generics/impl.md:25
msgid "// impl of Val\n"
msgstr "// Val 구현\n"

#: src/generics/impl.md:32
msgid "// impl of GenVal for a generic type `T`\n"
msgstr "// 제네릭 타입 `T`에 대한 GenVal 구현\n"

#: src/generics/impl.md:50
msgid ""
"[functions returning references](../scope/lifetime/fn.md), [`impl`](../fn/"
"methods.md), and [`struct`](../custom_types/structs.md)"
msgstr "[참조를 반환하는 함수](../scope/lifetime/fn.md), [`impl`](../fn/methods.md), 그리고 [`struct`](../custom_types/structs.md)"

#: src/generics/gen_trait.md:3
msgid ""
"Of course `trait`s can also be generic. Here we define one which "
"reimplements the `Drop` `trait` as a generic method to `drop` itself and an "
"input."
msgstr "물론 `trait`도 제네릭일 수 있습니다. 여기서는 `Drop` `트레이트`를 자신과 입력을 `drop`하는 제네릭 메서드로 재구현한 것을 정의합니다."

#: src/generics/gen_trait.md:7
msgid "// Non-copyable types.\n"
msgstr "// 복사 불가능한 타입.\n"

#: src/generics/gen_trait.md:10
msgid "// A trait generic over `T`.\n"
msgstr "// `T`에 대해 제네릭인 트레이트.\n"

#: src/generics/gen_trait.md:13
msgid ""
"// Define a method on the caller type which takes an\n"
"    // additional single parameter `T` and does nothing with it.\n"
msgstr ""

#: src/generics/gen_trait.md:17
msgid ""
"// Implement `DoubleDrop<T>` for any generic parameter `T` and\n"
"// caller `U`.\n"
msgstr ""

#: src/generics/gen_trait.md:21
msgid ""
"// This method takes ownership of both passed arguments,\n"
"    // deallocating both.\n"
msgstr ""

#: src/generics/gen_trait.md:30
msgid "// Deallocate `empty` and `null`.\n"
msgstr ""

#: src/generics/gen_trait.md:33
msgid ""
"//empty;\n"
"    //null;\n"
"    // ^ TODO: Try uncommenting these lines.\n"
msgstr ""

#: src/generics/gen_trait.md:41
msgid ""
"[`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html), [`struct`](../"
"custom_types/structs.md), and [`trait`](../trait.md)"
msgstr ""

#: src/generics/bounds.md:3
msgid ""
"When working with generics, the type parameters often must use traits as "
"_bounds_ to stipulate what functionality a type implements. For example, the "
"following example uses the trait `Display` to print and so it requires `T` "
"to be bound by `Display`; that is, `T` _must_ implement `Display`."
msgstr "제네릭을 사용할 때, 타입 파라미터는 종종 타입이 구현해야 하는 기능을 규정하기 위해 트레이트를 _바운드(bounds)_로 사용해야 합니다. 예를 들어, 다음 예제는 `Display` 트레이트를 사용하여 출력하므로 `T`가 `Display`에 바운드되어야 합니다. 즉, `T`는 반드시 `Display`를 구현해야 합니다."

#: src/generics/bounds.md:9
msgid ""
"// Define a function `printer` that takes a generic type `T` which\n"
"// must implement trait `Display`.\n"
msgstr ""
"// 제네릭 타입 `T`를 받는 함수 `printer`를 정의합니다.\n"
"// `T`는 반드시 `Display` 트레이트를 구현해야 합니다.\n"

#: src/generics/bounds.md:16
msgid ""
"Bounding restricts the generic to types that conform to the bounds. That is:"
msgstr "바운딩은 제네릭을 해당 바운드를 준수하는 타입들로 제한합니다. 즉:"

#: src/generics/bounds.md:20
msgid ""
"// Error! `Vec<T>` does not implement `Display`. This\n"
"// specialization will fail.\n"
msgstr ""
"// 에러! `Vec<T>`는 `Display`를 구현하지 않습니다.\n"
"// 이 특수화는 실패할 것입니다.\n"

#: src/generics/bounds.md:26
msgid ""
"Another effect of bounding is that generic instances are allowed to access "
"the [methods](../fn/methods.md) of traits specified in the bounds. For "
"example:"
msgstr "바운딩의 또 다른 효과는 제네릭 인스턴스가 바운드에 지정된 트레이트의 [메서드](../fn/methods.md)에 접근할 수 있게 된다는 것입니다. 예를 들어:"

#: src/generics/bounds.md:30
msgid "// A trait which implements the print marker: `{:?}`.\n"
msgstr "// 출력 마커 `{:?}`를 구현하는 트레이트입니다.\n"

#: src/generics/bounds.md:45
msgid ""
"// The generic `T` must implement `Debug`. Regardless\n"
"// of the type, this will work properly.\n"
msgstr ""
"// 제네릭 `T`는 반드시 `Debug`를 구현해야 합니다.\n"
"// 타입에 상관없이 이는 제대로 작동할 것입니다.\n"

#: src/generics/bounds.md:51
msgid ""
"// `T` must implement `HasArea`. Any type which meets\n"
"// the bound can access `HasArea`'s function `area`.\n"
msgstr ""
"// `T`는 반드시 `HasArea`를 구현해야 합니다. 바운드를 충족하는\n"
"// 모든 타입은 `HasArea`의 `area` 함수에 접근할 수 있습니다.\n"

#: src/generics/bounds.md:61
msgid "\"Area: {}\""
msgstr "\"면적: {}\""

#: src/generics/bounds.md:63
msgid ""
"//print_debug(&_triangle);\n"
"    //println!(\"Area: {}\", area(&_triangle));\n"
"    // ^ TODO: Try uncommenting these.\n"
"    // | Error: Does not implement either `Debug` or `HasArea`.\n"
msgstr ""
"//print_debug(&_triangle);\n"
"//println!(\"면적: {}\", area(&_triangle));\n"
"// ^ TODO: 이 줄들의 주석을 해제해 보세요.\n"
"// | 에러: `Debug`나 `HasArea` 중 어느 것도 구현하지 않았습니다.\n"

#: src/generics/bounds.md:70
msgid ""
"As an additional note, [`where`](../generics/where.md) clauses can also be "
"used to apply bounds in some cases to be more expressive."
msgstr "추가적으로, 어떤 경우에는 [`where`](../generics/where.md) 절을 사용하여 바운드를 더 표현력 있게 적용할 수도 있습니다."

#: src/generics/bounds.md:75
msgid ""
"[`std::fmt`](../hello/print.md), [`struct`s](../custom_types/structs.md), "
"and [`trait`s](../trait.md)"
msgstr "[`std::fmt`](../hello/print.md), [`struct`](../custom_types/structs.md), 그리고 [`trait`](../trait.md)"

#: src/generics/bounds/testcase_empty.md:3
msgid ""
"A consequence of how bounds work is that even if a `trait` doesn't include "
"any functionality, you can still use it as a bound. `Eq` and `Copy` are "
"examples of such `trait`s from the `std` library."
msgstr "바운드가 작동하는 방식의 결과로, `trait`가 아무런 기능을 포함하지 않더라도 여전히 바운드로 사용할 수 있습니다. `std` 라이브러리의 `Eq`와 `Copy`가 그러한 `trait`의 예입니다."

#: src/generics/bounds/testcase_empty.md:17
msgid ""
"// These functions are only valid for types which implement these\n"
"// traits. The fact that the traits are empty is irrelevant.\n"
msgstr ""
"// 이 함수들은 이 트레이트들을 구현하는 타입에 대해서만 유효합니다.\n"
"// 트레이트가 비어 있다는 사실은 무관합니다.\n"

#: src/generics/bounds/testcase_empty.md:20
msgid "\"red\""
msgstr "\"빨강\""

#: src/generics/bounds/testcase_empty.md:21
msgid "\"blue\""
msgstr "\"파랑\""

#: src/generics/bounds/testcase_empty.md:28
msgid ""
"// `red()` won't work on a blue jay nor vice versa\n"
"    // because of the bounds.\n"
msgstr ""
"// 바운드 때문에 `red()`는 blue jay(파랑 어치)에 대해 작동하지 않으며\n"
"// 그 반대도 마찬가지입니다.\n"

#: src/generics/bounds/testcase_empty.md:30
msgid "\"A cardinal is {}\""
msgstr "\"홍관조(cardinal)는 {}입니다\""

#: src/generics/bounds/testcase_empty.md:31
msgid "\"A blue jay is {}\""
msgstr "\"파랑 어치(blue jay)는 {}입니다\""

#: src/generics/bounds/testcase_empty.md:32
msgid ""
"//println!(\"A turkey is {}\", red(&_turkey));\n"
"    // ^ TODO: Try uncommenting this line.\n"
msgstr ""
"//println!(\"칠면조는 {}\", red(&_turkey));\n"
"// ^ TODO: 이 줄의 주석을 해제해 보세요.\n"

#: src/generics/bounds/testcase_empty.md:39
msgid ""
"[`std::cmp::Eq`](https://doc.rust-lang.org/std/cmp/trait.Eq.html), "
"[`std::marker::Copy`](https://doc.rust-lang.org/std/marker/trait.Copy.html), "
"and [`trait`s](../../trait.md)"
msgstr "[`std::cmp::Eq`](https://doc.rust-lang.org/std/cmp/trait.Eq.html), [`std::marker::Copy`](https://doc.rust-lang.org/std/marker/trait.Copy.html), 그리고 [`trait`](../../trait.md)"

#: src/generics/multi_bounds.md:3
msgid ""
"Multiple bounds for a single type can be applied with a `+`. Like normal, "
"different types are separated with `,`."
msgstr "단일 타입에 대해 `+`를 사용하여 다중 바운드를 적용할 수 있습니다. 평소와 마찬가지로, 서로 다른 타입은 `,`로 구분됩니다."

#: src/generics/multi_bounds.md:10
msgid "\"Debug: `{:?}`\""
msgstr "\"디버그: `{:?}`\""

#: src/generics/multi_bounds.md:11
msgid "\"Display: `{}`\""
msgstr "\"디스플레이: `{}`\""

#: src/generics/multi_bounds.md:15
msgid "\"t: `{:?}`\""
msgstr "\"t: `{:?}`\""

#: src/generics/multi_bounds.md:16
msgid "\"u: `{:?}`\""
msgstr "\"u: `{:?}`\""

#: src/generics/multi_bounds.md:20
msgid "\"words\""
msgstr "\"단어들\""

#: src/generics/multi_bounds.md:25
msgid ""
"//compare_prints(&array);\n"
"    // TODO ^ Try uncommenting this.\n"
msgstr ""
"//compare_prints(&array);\n"
"// TODO ^ 주석을 해제해 보세요.\n"

#: src/generics/multi_bounds.md:34
msgid "[`std::fmt`](../hello/print.md) and [`trait`s](../trait.md)"
msgstr "[`std::fmt`](../hello/print.md)와 [`trait`](../trait.md)"

#: src/generics/where.md:3
msgid ""
"A bound can also be expressed using a `where` clause immediately before the "
"opening `{`, rather than at the type's first mention. Additionally, `where` "
"clauses can apply bounds to arbitrary types, rather than just to type "
"parameters."
msgstr "바운드는 타입이 처음 언급되는 곳이 아닌, 여는 중괄호 `{` 직전에 `where` 절을 사용하여 표현할 수도 있습니다. 또한, `where` 절은 타입 파라미터뿐만 아니라 임의의 타입에도 바운드를 적용할 수 있습니다."

#: src/generics/where.md:8
msgid "Some cases that a `where` clause is useful:"
msgstr "`where` 절이 유용한 몇 가지 경우:"

#: src/generics/where.md:10
msgid "When specifying generic types and bounds separately is clearer:"
msgstr "제네릭 타입과 바운드를 따로 명시하는 것이 더 명확할 때:"

#: src/generics/where.md:14
msgid "// Expressing bounds with a `where` clause\n"
msgstr "// `where` 절로 바운드 표현하기\n"

#: src/generics/where.md:21
msgid ""
"When using a `where` clause is more expressive than using normal syntax. The "
"`impl` in this example cannot be directly expressed without a `where` clause:"
msgstr "`where` 절을 사용하는 것이 일반 구문을 사용하는 것보다 더 표현력이 좋을 때. 이 예제의 `impl`은 `where` 절 없이는 직접 표현할 수 없습니다:"

#: src/generics/where.md:30
msgid ""
"// Because we would otherwise have to express this as `T: Debug` or\n"
"// use another method of indirect approach, this requires a `where` clause:\n"
msgstr ""
"// 그렇지 않으면 `T: Debug`로 표현하거나\n"
"// 다른 간접적인 방법을 사용해야 하므로, 여기에는 `where` 절이 필요합니다:\n"

#: src/generics/where.md:35
msgid ""
"// We want `Option<T>: Debug` as our bound because that is what's\n"
"    // being printed. Doing otherwise would be using the wrong bound.\n"
msgstr ""
"// 출력되는 것이 `Option<T>`이므로, 바운드로 `Option<T>: Debug`를 원합니다.\n"
"    // 다르게 하면 잘못된 바운드를 사용하는 셈이 됩니다.\n"

#: src/generics/where.md:51
msgid ""
"[RFC](https://github.com/rust-lang/rfcs/blob/master/text/0135-where.md), "
"[`struct`](../custom_types/structs.md), and [`trait`](../trait.md)"
msgstr "[RFC](https://github.com/rust-lang/rfcs/blob/master/text/0135-where.md), [`struct`](../custom_types/structs.md), 그리고 [`trait`](../trait.md)"

#: src/generics/new_types.md:3
msgid ""
"The `newtype` idiom gives compile time guarantees that the right type of "
"value is supplied to a program."
msgstr "`newtype` 관용구는 프로그램에 올바른 타입의 값이 제공됨을 컴파일 타임에 보장해 줍니다."

#: src/generics/new_types.md:6
msgid ""
"For example, an age verification function that checks age in years, _must_ "
"be given a value of type `Years`."
msgstr "예를 들어, 나이를 연 단위로 확인하는 나이 검증 함수는 반드시 `Years` 타입의 값을 받아야 합니다."

#: src/generics/new_types.md:21
msgid "/// truncates partial years\n"
msgstr "/// 부분적인 연도는 버립니다\n"

#: src/generics/new_types.md:34 src/generics/new_types.md:35
msgid "\"Is an adult? {}\""
msgstr "\"성인입니까? {}\""

#: src/generics/new_types.md:36
msgid "// println!(\"Is an adult? {}\", is_adult(&age_days));\n"
msgstr "// println!(\"성인입니까? {}\", is_adult(&age_days));\n"

#: src/generics/new_types.md:40
msgid ""
"Uncomment the last print statement to observe that the type supplied must be "
"`Years`."
msgstr "마지막 출력문의 주석을 해제하여 제공되는 타입이 반드시 `Years`여야 함을 관찰해 보세요."

#: src/generics/new_types.md:42
msgid ""
"To obtain the `newtype`'s value as the base type, you may use the tuple or "
"destructuring syntax like so:"
msgstr "`newtype`의 값을 기본 타입으로 얻으려면, 다음과 같이 튜플 또는 구조 분해 문법을 사용할 수 있습니다:"

#: src/generics/new_types.md:49
msgid "// Tuple\n"
msgstr "// 튜플\n"

#: src/generics/new_types.md:50
msgid "// Destructuring\n"
msgstr "// 구조 분해\n"

#: src/generics/new_types.md:56
msgid "[`structs`](../custom_types/structs.md)"
msgstr "[`structs`](../custom_types/structs.md)"

#: src/generics/assoc_items.md:3
msgid ""
"\"Associated Items\" refers to a set of rules pertaining to [`item`](https://"
"doc.rust-lang.org/reference/items.html)s of various types. It is an "
"extension to `trait` generics, and allows `trait`s to internally define new "
"items."
msgstr "\"연관 아이템(Associated Items)\"은 다양한 타입의 [`아이템`](https://doc.rust-lang.org/reference/items.html)에 관련된 규칙 집합을 말합니다. 이는 `trait` 제네릭의 확장이며, `trait`가 내부적으로 새로운 아이템을 정의할 수 있게 해줍니다."

#: src/generics/assoc_items.md:7
msgid ""
"One such item is called an _associated type_, providing simpler usage "
"patterns when the `trait` is generic over its container type."
msgstr "그러한 아이템 중 하나가 _연관 타입(associated type)_이며, `trait`가 컨테이너 타입에 대해 제네릭일 때 더 간단한 사용 패턴을 제공합니다."

#: src/generics/assoc_items.md:12
msgid ""
"[RFC](https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-"
"items.md)"
msgstr "[RFC](https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md)"

#: src/generics/assoc_items/the_problem.md:3
msgid ""
"A `trait` that is generic over its container type has type specification "
"requirements - users of the `trait` _must_ specify all of its generic types."
msgstr "컨테이너 타입에 대해 제네릭인 `trait`는 타입 명시 요구사항을 가집니다 - `trait` 사용자는 모든 제네릭 타입을 _반드시_ 명시해야 합니다."

#: src/generics/assoc_items/the_problem.md:6
msgid ""
"In the example below, the `Contains` `trait` allows the use of the generic "
"types `A` and `B`. The trait is then implemented for the `Container` type, "
"specifying `i32` for `A` and `B` so that it can be used with `fn "
"difference()`."
msgstr "아래 예제에서 `Contains` `trait`는 제네릭 타입 `A`와 `B`의 사용을 허용합니다. 그 후 이 트레이트는 `Container` 타입에 대해 구현되는데, `fn difference()`와 함께 사용될 수 있도록 `A`와 `B`에 대해 `i32`를 지정합니다."

#: src/generics/assoc_items/the_problem.md:10
msgid ""
"Because `Contains` is generic, we are forced to explicitly state _all_ of "
"the generic types for `fn difference()`. In practice, we want a way to "
"express that `A` and `B` are determined by the _input_ `C`. As you will see "
"in the next section, associated types provide exactly that capability."
msgstr "`Contains`가 제네릭이기 때문에, 우리는 `fn difference()`에 대해 _모든_ 제네릭 타입을 명시적으로 나열해야만 합니다. 실제로는 `A`와 `B`가 _입력_ `C`에 의해 결정된다는 것을 표현하고 싶습니다. 다음 섹션에서 보게 되겠지만, 연관 타입은 정확히 그런 기능을 제공합니다."

#: src/generics/assoc_items/the_problem.md:17
#: src/generics/assoc_items/types.md:36
msgid ""
"// A trait which checks if 2 items are stored inside of container.\n"
"// Also retrieves first or last value.\n"
msgstr ""
"// 컨테이너 안에 2개의 아이템이 저장되어 있는지 확인하는 트레이트입니다.\n"
"// 또한 첫 번째 또는 마지막 값을 가져옵니다.\n"

#: src/generics/assoc_items/the_problem.md:21
msgid "// Explicitly requires `A` and `B`.\n"
msgstr "// 명시적으로 `A`와 `B`를 요구합니다.\n"

#: src/generics/assoc_items/the_problem.md:22
#: src/generics/assoc_items/the_problem.md:23
msgid "// Doesn't explicitly require `A` or `B`.\n"
msgstr "// 명시적으로 `A`나 `B`를 요구하지 않습니다.\n"

#: src/generics/assoc_items/the_problem.md:27
msgid "// True if the numbers stored are equal.\n"
msgstr "// 저장된 숫자들이 같으면 참입니다.\n"

#: src/generics/assoc_items/the_problem.md:32
#: src/generics/assoc_items/types.md:60
msgid "// Grab the first number.\n"
msgstr "// 첫 번째 숫자를 가져옵니다.\n"

#: src/generics/assoc_items/the_problem.md:35
#: src/generics/assoc_items/types.md:63
msgid "// Grab the last number.\n"
msgstr "// 마지막 숫자를 가져옵니다.\n"

#: src/generics/assoc_items/the_problem.md:38
msgid ""
"// `C` contains `A` and `B`. In light of that, having to express `A` and\n"
"// `B` again is a nuisance.\n"
msgstr ""
"// `C`는 `A`와 `B`를 포함합니다. 이를 고려할 때, `A`와 `B`를\n"
"// 다시 표현해야 하는 것은 성가신 일입니다.\n"

#: src/generics/assoc_items/the_problem.md:52
#: src/generics/assoc_items/types.md:77
msgid "\"Does container contain {} and {}: {}\""
msgstr "\"컨테이너가 {}와 {}를 포함합니까: {}\""

#: src/generics/assoc_items/the_problem.md:55
#: src/generics/assoc_items/types.md:80
msgid "\"First number: {}\""
msgstr "\"첫 번째 숫자: {}\""

#: src/generics/assoc_items/the_problem.md:56
#: src/generics/assoc_items/types.md:81
msgid "\"Last number: {}\""
msgstr "\"마지막 숫자: {}\""

#: src/generics/assoc_items/the_problem.md:58
#: src/generics/assoc_items/types.md:83
msgid "\"The difference is: {}\""
msgstr "\"차이는: {}\""

#: src/generics/assoc_items/the_problem.md:64
msgid ""
"[`struct`s](../../custom_types/structs.md), and [`trait`s](../../trait.md)"
msgstr "[`struct`](../../custom_types/structs.md), 그리고 [`trait`](../../trait.md)"

#: src/generics/assoc_items/types.md:3
msgid ""
"The use of \"Associated types\" improves the overall readability of code by "
"moving inner types locally into a trait as _output_ types. Syntax for the "
"`trait` definition is as follows:"
msgstr "\"연관 타입\"을 사용하면 내부 타입을 트레이트 내의 _출력_ 타입으로 지역적으로 이동시켜 코드의 전반적인 가독성을 향상시킬 수 있습니다. `trait` 정의를 위한 구문은 다음과 같습니다:"

#: src/generics/assoc_items/types.md:8
msgid ""
"// `A` and `B` are defined in the trait via the `type` keyword.\n"
"// (Note: `type` in this context is different from `type` when used for\n"
"// aliases).\n"
msgstr ""
"// `A`와 `B`는 `type` 키워드를 통해 트레이트 내에 정의됩니다.\n"
"// (참고: 이 문맥에서의 `type`은 별칭(aliases)에 사용되는 `type`과는 다릅니다).\n"

#: src/generics/assoc_items/types.md:15
msgid "// Updated syntax to refer to these new types generically.\n"
msgstr "// 이 새로운 타입들을 제네릭하게 참조하기 위해 업데이트된 구문입니다.\n"

#: src/generics/assoc_items/types.md:20
msgid ""
"Note that functions that use the `trait` `Contains` are no longer required "
"to express `A` or `B` at all:"
msgstr "`Contains` `trait`를 사용하는 함수들은 더 이상 `A`나 `B`를 표현할 필요가 없다는 점에 유의하세요:"

#: src/generics/assoc_items/types.md:24
msgid "// Without using associated types\n"
msgstr "// 연관 타입을 사용하지 않는 경우\n"

#: src/generics/assoc_items/types.md:27
msgid "// Using associated types\n"
msgstr "// 연관 타입 사용\n"

#: src/generics/assoc_items/types.md:32
msgid ""
"Let's rewrite the example from the previous section using associated types:"
msgstr "이전 섹션의 예제를 연관 타입을 사용하여 다시 작성해 봅시다:"

#: src/generics/assoc_items/types.md:40
msgid "// Define generic types here which methods will be able to utilize.\n"
msgstr "// 여기서 제네릭 타입을 정의하여 메서드들이 활용할 수 있게 합니다.\n"

#: src/generics/assoc_items/types.md:50
msgid ""
"// Specify what types `A` and `B` are. If the `input` type\n"
"    // is `Container(i32, i32)`, the `output` types are determined\n"
"    // as `i32` and `i32`.\n"
msgstr ""
"// `A`와 `B`가 어떤 타입인지 명시합니다. 만약 `input` 타입이\n"
"    // `Container(i32, i32)`라면, `output` 타입은 `i32`와 `i32`로\n"
"    // 결정됩니다.\n"

#: src/generics/assoc_items/types.md:56
msgid "// `&Self::A` and `&Self::B` are also valid here.\n"
msgstr "// `&Self::A`와 `&Self::B` 또한 여기서 유효합니다.\n"

#: src/generics/phantom.md:3
msgid ""
"A phantom type parameter is one that doesn't show up at runtime, but is "
"checked statically (and only) at compile time."
msgstr "팬텀 타입 파라미터(phantom type parameter)는 런타임에는 나타나지 않지만, 컴파일 타임에만 정적으로 검사되는 파라미터입니다."

#: src/generics/phantom.md:6
msgid ""
"Data types can use extra generic type parameters to act as markers or to "
"perform type checking at compile time. These extra parameters hold no "
"storage values, and have no runtime behavior."
msgstr "데이터 타입은 추가적인 제네릭 타입 파라미터를 사용하여 마커 역할을 하거나 컴파일 타임에 타입 검사를 수행할 수 있습니다. 이러한 추가 파라미터는 저장 값을 가지지 않으며, 런타임 동작도 없습니다."

#: src/generics/phantom.md:10
msgid ""
"In the following example, we combine [std::marker::PhantomData](https://"
"doc.rust-lang.org/std/marker/struct.PhantomData.html) with the phantom type "
"parameter concept to create tuples containing different data types."
msgstr "다음 예제에서는 [std::marker::PhantomData](https://doc.rust-lang.org/std/marker/struct.PhantomData.html)와 팬텀 타입 파라미터 개념을 결합하여 서로 다른 데이터 타입을 포함하는 튜플을 생성합니다."

#: src/generics/phantom.md:16
msgid ""
"// A phantom tuple struct which is generic over `A` with hidden parameter "
"`B`.\n"
msgstr "// 숨겨진 파라미터 `B`를 가지며 `A`에 대해 제네릭인 팬텀 튜플 구조체.\n"

#: src/generics/phantom.md:18 src/generics/phantom.md:22
msgid "// Allow equality test for this type.\n"
msgstr "// 이 타입에 대한 동등성 테스트를 허용합니다.\n"

#: src/generics/phantom.md:20
msgid ""
"// A phantom type struct which is generic over `A` with hidden parameter "
"`B`.\n"
msgstr "// 숨겨진 파라미터 `B`를 가지며 `A`에 대해 제네릭인 팬텀 타입 구조체.\n"

#: src/generics/phantom.md:24
msgid ""
"// Note: Storage is allocated for generic type `A`, but not for `B`.\n"
"//       Therefore, `B` cannot be used in computations.\n"
msgstr ""
"// 주의: 제네릭 타입 `A`에는 저장 공간이 할당되지만, `B`에는 할당되지 않습니다.\n"
"//       따라서 `B`는 연산에 사용될 수 없습니다.\n"

#: src/generics/phantom.md:29
msgid ""
"// Here, `f32` and `f64` are the hidden parameters.\n"
"    // PhantomTuple type specified as `<char, f32>`.\n"
msgstr ""
"// 여기서 `f32`와 `f64`는 숨겨진 파라미터입니다.\n"
"    // PhantomTuple 타입이 `<char, f32>`로 지정되었습니다.\n"

#: src/generics/phantom.md:31 src/generics/phantom.md:33
#: src/generics/phantom.md:37 src/generics/phantom.md:42
#: src/scope/borrow/ref.md:12
msgid "'Q'"
msgstr "'Q'"

#: src/generics/phantom.md:32
msgid "// PhantomTuple type specified as `<char, f64>`.\n"
msgstr "// PhantomTuple 타입이 `<char, f64>`로 지정되었습니다.\n"

#: src/generics/phantom.md:35
msgid "// Type specified as `<char, f32>`.\n"
msgstr "// 타입이 `<char, f32>`로 지정되었습니다.\n"

#: src/generics/phantom.md:40
msgid "// Type specified as `<char, f64>`.\n"
msgstr "// 타입이 `<char, f64>`로 지정되었습니다.\n"

#: src/generics/phantom.md:46
msgid ""
"// Compile-time Error! Type mismatch so these cannot be compared:\n"
msgstr "// 컴파일 타임 에러! 타입 불일치로 인해 비교할 수 없습니다:\n"

#: src/generics/phantom.md:50
msgid ""
"// Compile-time Error! Type mismatch so these cannot be compared:\n"
"    // println!(\"_struct1 == _struct2 yields: {}\",\n"
"    //           _struct1 == _struct2);\n"
msgstr ""
"// 컴파일 타임 에러! 타입 불일치로 인해 비교할 수 없습니다:\n"
"// println!(\"_struct1 == _struct2 yields: {}\",\n"
"//           _struct1 == _struct2);\n"

#: src/generics/phantom.md:58
msgid ""
"[Derive](../trait/derive.md), [struct](../custom_types/structs.md), and "
"[tuple](../primitives/tuples.html)."
msgstr "[Derive](../trait/derive.md), [구조체](../custom_types/structs.md), 그리고 [튜플](../primitives/tuples.html)."

#: src/generics/phantom/testcase_units.md:3
msgid ""
"A useful method of unit conversions can be examined by implementing `Add` "
"with a phantom type parameter. The `Add` `trait` is examined below:"
msgstr "팬텀 타입 파라미터로 `Add`를 구현하여 유용한 단위 변환 방법을 살펴볼 수 있습니다. `Add` `트레이트`는 아래에서 살펴봅니다:"

#: src/generics/phantom/testcase_units.md:7
msgid ""
"// This construction would impose: `Self + RHS = Output`\n"
"// where RHS defaults to Self if not specified in the implementation.\n"
msgstr ""
"// 이 구조는 다음을 부과합니다: `Self + RHS = Output`\n"
"// 구현에서 지정되지 않은 경우 RHS는 기본적으로 Self입니다.\n"

#: src/generics/phantom/testcase_units.md:14
msgid "// `Output` must be `T<U>` so that `T<U> + T<U> = T<U>`.\n"
msgstr "// `Output`은 `T<U> + T<U> = T<U>`가 되도록 반드시 `T<U>`여야 합니다.\n"

#: src/generics/phantom/testcase_units.md:22
msgid "The whole implementation:"
msgstr "전체 구현:"

#: src/generics/phantom/testcase_units.md:27
msgid "/// Create void enumerations to define unit types.\n"
msgstr "/// 단위 타입을 정의하기 위해 빈 열거형을 생성합니다.\n"

#: src/generics/phantom/testcase_units.md:33
msgid ""
"/// `Length` is a type with phantom type parameter `Unit`,\n"
"/// and is not generic over the length type (that is `f64`).\n"
"///\n"
"/// `f64` already implements the `Clone` and `Copy` traits.\n"
msgstr ""
"/// `Length`는 팬텀 타입 파라미터 `Unit`을 가지는 타입이며,\n"
"/// 길이 타입(`f64`)에 대해서는 제네릭이 아닙니다.\n"
"///\n"
"/// `f64`는 이미 `Clone`과 `Copy` 트레이트를 구현하고 있습니다.\n"

#: src/generics/phantom/testcase_units.md:40
msgid "/// The `Add` trait defines the behavior of the `+` operator.\n"
msgstr "/// `Add` 트레이트는 `+` 연산자의 동작을 정의합니다.\n"

#: src/generics/phantom/testcase_units.md:45
msgid "// add() returns a new `Length` struct containing the sum.\n"
msgstr "// add()는 합계를 포함하는 새로운 `Length` 구조체를 반환합니다.\n"

#: src/generics/phantom/testcase_units.md:47
msgid "// `+` calls the `Add` implementation for `f64`.\n"
msgstr "// `+`는 `f64`에 대한 `Add` 구현을 호출합니다.\n"

#: src/generics/phantom/testcase_units.md:53
msgid "// Specifies `one_foot` to have phantom type parameter `Inch`.\n"
msgstr "// `one_foot`가 팬텀 타입 파라미터 `Inch`를 가지도록 지정합니다.\n"

#: src/generics/phantom/testcase_units.md:55
msgid "// `one_meter` has phantom type parameter `Mm`.\n"
msgstr "// `one_meter`는 팬텀 타입 파라미터 `Mm`을 가집니다.\n"

#: src/generics/phantom/testcase_units.md:58
msgid ""
"// `+` calls the `add()` method we implemented for `Length<Unit>`.\n"
"    //\n"
"    // Since `Length` implements `Copy`, `add()` does not consume\n"
"    // `one_foot` and `one_meter` but copies them into `self` and `rhs`.\n"
msgstr ""
"// `+`는 우리가 `Length<Unit>`에 대해 구현한 `add()` 메서드를 호출합니다.\n"
"//\n"
"// `Length`가 `Copy`를 구현하므로, `add()`는 `one_foot`과 `one_meter`를\n"
"// 소비(consume)하지 않고 `self`와 `rhs`로 복사합니다.\n"

#: src/generics/phantom/testcase_units.md:65
msgid "// Addition works.\n"
msgstr "// 덧셈이 작동합니다.\n"

#: src/generics/phantom/testcase_units.md:66
msgid "\"one foot + one_foot = {:?} in\""
msgstr "\"1피트 + 1피트 = {:?} 인치\""

#: src/generics/phantom/testcase_units.md:67
msgid "\"one meter + one_meter = {:?} mm\""
msgstr "\"1미터 + 1미터 = {:?} mm\""

#: src/generics/phantom/testcase_units.md:69
msgid ""
"// Nonsensical operations fail as they should:\n"
"    // Compile-time Error: type mismatch.\n"
"    //let one_feter = one_foot + one_meter;\n"
msgstr ""
"// 말도 안 되는 연산은 실패합니다:\n"
"// 컴파일 타임 에러: 타입 불일치.\n"
"// let one_feter = one_foot + one_meter;\n"

#: src/generics/phantom/testcase_units.md:77
msgid ""
"[Borrowing (`&`)](../../scope/borrow.md), [Bounds (`X: Y`)](../../generics/"
"bounds.md), [enum](../../custom_types/enum.md), [impl & self](../../fn/"
"methods.md), [Overloading](../../trait/ops.md), [ref](../../scope/borrow/"
"ref.md), [Traits (`X for Y`)](../../trait.md), and [TupleStructs](../../"
"custom_types/structs.md)."
msgstr "[빌림(Borrowing) (`&`)](../../scope/borrow.md), [바운드(Bounds) (`X: Y`)](../../generics/bounds.md), [열거형(enum)](../../custom_types/enum.md), [impl & self](../../fn/methods.md), [오버로딩(Overloading)](../../trait/ops.md), [ref](../../scope/borrow/ref.md), [트레이트(Traits) (`X for Y`)](../../trait.md), 그리고 [튜플 구조체(TupleStructs)](../../custom_types/structs.md)."

#: src/scope.md:3
msgid ""
"Scopes play an important part in ownership, borrowing, and lifetimes. That "
"is, they indicate to the compiler when borrows are valid, when resources can "
"be freed, and when variables are created or destroyed."
msgstr "스코프(범위)는 소유권(ownership), 빌림(borrowing), 라이프타임(lifetimes)에서 중요한 역할을 합니다. 즉, 스코프는 컴파일러에게 언제 빌림이 유효한지, 언제 자원이 해제될 수 있는지, 언제 변수가 생성되고 파괴되는지를 알려줍니다."

#: src/scope/raii.md:3
msgid ""
"Variables in Rust do more than just hold data in the stack: they also _own_ "
"resources, e.g. `Box<T>` owns memory in the heap. Rust enforces [RAII]"
"(https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization) "
"(Resource Acquisition Is Initialization), so whenever an object goes out of "
"scope, its destructor is called and its owned resources are freed."
msgstr "Rust의 변수는 스택에 데이터를 저장하는 것 이상의 일을 합니다. 예를 들어 `Box<T>`는 힙 메모리를 소유하는 것처럼 리소스를 _소유(own)_하기도 합니다. Rust는 [RAII](https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization) (자원의 획득은 초기화이다)를 강제하므로, 객체가 스코프를 벗어날 때마다 소멸자가 호출되어 소유한 리소스가 해제됩니다."

#: src/scope/raii.md:8
msgid ""
"This behavior shields against _resource leak_ bugs, so you'll never have to "
"manually free memory or worry about memory leaks again! Here's a quick "
"showcase:"
msgstr "이러한 동작은 _리소스 누수_ 버그를 방지하므로, 수동으로 메모리를 해제하거나 메모리 누수에 대해 걱정할 필요가 없습니다! 간단한 예시를 보여드리겠습니다:"

#: src/scope/raii.md:12
msgid "// raii.rs\n"
msgstr "// raii.rs\n"

#: src/scope/raii.md:14 src/scope/raii.md:21 src/scope/raii.md:26
msgid "// Allocate an integer on the heap\n"
msgstr "// 힙에 정수를 할당합니다\n"

#: src/scope/raii.md:17
msgid "// `_box1` is destroyed here, and memory gets freed\n"
msgstr "// `_box1`은 여기서 파괴되고, 메모리가 해제됩니다\n"

#: src/scope/raii.md:24
msgid "// A nested scope:\n"
msgstr "// 중첩된 스코프:\n"

#: src/scope/raii.md:29
msgid "// `_box3` is destroyed here, and memory gets freed\n"
msgstr "// `_box3`은 여기서 파괴되고, 메모리가 해제됩니다\n"

#: src/scope/raii.md:32
msgid ""
"// Creating lots of boxes just for fun\n"
"    // There's no need to manually free memory!\n"
msgstr ""
"// 재미 삼아 많은 상자를 만듭니다\n"
"    // 수동으로 메모리를 해제할 필요가 없습니다!\n"

#: src/scope/raii.md:38
msgid "// `_box2` is destroyed here, and memory gets freed\n"
msgstr "// `_box2`는 여기서 파괴되고, 메모리가 해제됩니다\n"

#: src/scope/raii.md:42
msgid ""
"Of course, we can double check for memory errors using [`valgrind`](http://"
"valgrind.org/info/):"
msgstr "물론 [`valgrind`](http://valgrind.org/info/)를 사용하여 메모리 에러를 다시 확인할 수 있습니다:"

#: src/scope/raii.md:65
msgid "No leaks here!"
msgstr "누수가 없습니다!"

#: src/scope/raii.md:67
msgid "Destructor"
msgstr "소멸자"

#: src/scope/raii.md:69
msgid ""
"The notion of a destructor in Rust is provided through the [`Drop`](https://"
"doc.rust-lang.org/std/ops/trait.Drop.html) trait. The destructor is called "
"when the resource goes out of scope. This trait is not required to be "
"implemented for every type, only implement it for your type if you require "
"its own destructor logic."
msgstr "Rust에서 소멸자의 개념은 [`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html) 트레이트를 통해 제공됩니다. 소멸자는 리소스가 스코프를 벗어날 때 호출됩니다. 모든 타입에 대해 이 트레이트를 구현할 필요는 없으며, 자체적인 소멸자 로직이 필요한 경우에만 구현하면 됩니다."

#: src/scope/raii.md:74
msgid ""
"Run the below example to see how the [`Drop`](https://doc.rust-lang.org/std/"
"ops/trait.Drop.html) trait works. When the variable in the `main` function "
"goes out of scope the custom destructor will be invoked."
msgstr ""
"아래 예제를 실행하여 [`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html) 트레이트가 어떻게 작동하는지 확인해 보세요. `main` 함수의 변수가 스코프를 벗어나면 사용자 정의 소멸자가 호출될 것입니다."

#: src/scope/raii.md:82
msgid "\"ToDrop is being dropped\""
msgstr "\"ToDrop이 드롭되고 있습니다\""

#: src/scope/raii.md:88
msgid "\"Made a ToDrop!\""
msgstr "\"ToDrop을 만들었습니다!\""

#: src/scope/raii.md:94
msgid "[Box](../std/box.md)"
msgstr "[Box](../std/box.md)"

#: src/scope/move.md:3
msgid ""
"Because variables are in charge of freeing their own resources, **resources "
"can only have one owner**. This prevents resources from being freed more "
"than once. Note that not all variables own resources (e.g. [references](../"
"flow_control/match/destructuring/destructure_pointers.md))."
msgstr "변수는 자신의 리소스를 해제할 책임이 있으므로, **리소스는 오직 하나의 소유자만 가질 수 있습니다**. 이는 리소스가 한 번 이상 해제되는 것을 방지합니다. 모든 변수가 리소스를 소유하는 것은 아닙니다(예: [참조](../flow_control/match/destructuring/destructure_pointers.md))."

#: src/scope/move.md:8
msgid ""
"When doing assignments (`let x = y`) or passing function arguments by value "
"(`foo(x)`), the _ownership_ of the resources is transferred. In Rust-speak, "
"this is known as a _move_."
msgstr "할당(`let x = y`)을 하거나 함수 인자를 값으로 전달(`foo(x)`)할 때, 리소스의 _소유권_이 이전됩니다. Rust 용어로는 이를 _이동(move)_이라고 합니다."

#: src/scope/move.md:12
msgid ""
"After moving resources, the previous owner can no longer be used. This "
"avoids creating dangling pointers."
msgstr "리소스를 이동한 후에는 이전 소유자를 더 이상 사용할 수 없습니다. 이는 댕글링 포인터(dangling pointers) 생성을 방지합니다."

#: src/scope/move.md:16
msgid "// This function takes ownership of the heap allocated memory\n"
msgstr "// 이 함수는 힙에 할당된 메모리의 소유권을 가져갑니다\n"

#: src/scope/move.md:18
msgid "\"Destroying a box that contains {}\""
msgstr "\"{}를 포함하는 상자를 파괴 중\""

#: src/scope/move.md:20
msgid "// `c` is destroyed and the memory freed\n"
msgstr "// `c`가 파괴되고 메모리가 해제됩니다\n"

#: src/scope/move.md:24
msgid "// _Stack_ allocated integer\n"
msgstr "// _스택_에 할당된 정수\n"

#: src/scope/move.md:27
msgid "// *Copy* `x` into `y` - no resources are moved\n"
msgstr "// `x`를 `y`로 *복사* - 리소스가 이동되지 않음\n"

#: src/scope/move.md:30
msgid "// Both values can be independently used\n"
msgstr "// 두 값 모두 독립적으로 사용될 수 있음\n"

#: src/scope/move.md:31
msgid "\"x is {}, and y is {}\""
msgstr "\"x는 {}이고, y는 {}입니다\""

#: src/scope/move.md:33
msgid "// `a` is a pointer to a _heap_ allocated integer\n"
msgstr "// `a`는 _힙_에 할당된 정수에 대한 포인터입니다\n"

#: src/scope/move.md:36
msgid "\"a contains: {}\""
msgstr "\"a가 포함하는 것: {}\""

#: src/scope/move.md:38
msgid "// *Move* `a` into `b`\n"
msgstr "// `a`를 `b`로 *이동*\n"

#: src/scope/move.md:40
msgid ""
"// The pointer address of `a` is copied (not the data) into `b`.\n"
"    // Both are now pointers to the same heap allocated data, but\n"
"    // `b` now owns it.\n"
msgstr ""
"// `a`의 포인터 주소가 (데이터가 아니라) `b`로 복사됩니다.\n"
"// 둘 다 이제 동일한 힙 할당 데이터를 가리키지만,\n"
"// 이제 `b`가 소유권을 가집니다.\n"

#: src/scope/move.md:44
msgid ""
"// Error! `a` can no longer access the data, because it no longer owns the\n"
"    // heap memory\n"
"    //println!(\"a contains: {}\", a);\n"
"    // TODO ^ Try uncommenting this line\n"
msgstr ""
"// 에러! `a`는 더 이상 데이터를 소유하고 있지 않으므로 접근할 수 없습니다.\n"
"//println!(\"a가 포함하는 것: {}\", a);\n"
"// TODO ^ 이 줄의 주석을 해제해 보세요\n"

#: src/scope/move.md:49
msgid ""
"// This function takes ownership of the heap allocated memory from `b`\n"
"    //destroy_box(b);\n"
msgstr "// 이 함수는 `b`로부터 힙 할당 메모리의 소유권을 가져갑니다\n"

#: src/scope/move.md:52
msgid ""
"// Since the heap memory has been freed at this point, this action would\n"
"    // result in dereferencing freed memory, but it's forbidden by the "
"compiler\n"
"    // Error! Same reason as the previous Error\n"
"    //println!(\"b contains: {}\", b);\n"
"    // TODO ^ Try uncommenting this line\n"
msgstr ""
"// 이 시점에서 힙 메모리가 해제되었으므로, 이 동작은\n"
"    // 해제된 메모리를 역참조하는 결과를 낳겠지만, 컴파일러에 의해 금지됩니다.\n"
"    // 에러! 이전 에러와 같은 이유입니다.\n"
"    //println!(\"b가 포함하는 것: {}\", b);\n"
"    // TODO ^ 이 줄의 주석을 해제해 보세요\n"

#: src/scope/move/mut.md:3
msgid "Mutability of data can be changed when ownership is transferred."
msgstr "소유권이 이전될 때 데이터의 가변성이 변경될 수 있습니다."

#: src/scope/move/mut.md:9
msgid "\"immutable_box contains {}\""
msgstr "\"불변 상자가 포함하는 것: {}\""

#: src/scope/move/mut.md:11
msgid ""
"// Mutability error\n"
"    //*immutable_box = 4;\n"
msgstr ""
"// 가변성 에러\n"
"    //*immutable_box = 4;\n"

#: src/scope/move/mut.md:14
msgid "// *Move* the box, changing the ownership (and mutability)\n"
msgstr "// 상자를 *이동*하여 소유권(및 가변성)을 변경합니다\n"

#: src/scope/move/mut.md:17
msgid "\"mutable_box contains {}\""
msgstr "\"가변 상자가 포함하는 것: {}\""

#: src/scope/move/mut.md:19
msgid "// Modify the contents of the box\n"
msgstr "// 상자의 내용물을 수정합니다\n"

#: src/scope/move/mut.md:22
msgid "\"mutable_box now contains {}\""
msgstr "\"가변 상자가 이제 포함하는 것: {}\""

#: src/scope/move/partial_move.md:3
msgid ""
"Within the [destructuring](../../flow_control/match/destructuring.md) of a "
"single variable, both `by-move` and `by-reference` pattern bindings can be "
"used at the same time. Doing this will result in a _partial move_ of the "
"variable, which means that parts of the variable will be moved while other "
"parts stay. In such a case, the parent variable cannot be used afterwards as "
"a whole, however the parts that are only referenced (and not moved) can "
"still be used. Note that types that implement the [`Drop` trait](../../trait/"
"drop.md) cannot be partially moved from, because its `drop` method would use "
"it afterwards as a whole."
msgstr "단일 변수의 [구조 분해](../../flow_control/match/destructuring.md) 내에서 `이동에 의한(by-move)` 패턴 바인딩과 `참조에 의한(by-reference)` 패턴 바인딩을 동시에 사용할 수 있습니다. 이렇게 하면 변수의 _부분 이동(partial move)_이 발생하는데, 이는 변수의 일부는 이동하고 다른 부분은 남아있음을 의미합니다. 이런 경우 부모 변수는 전체로서 나중에 사용될 수 없지만, 참조만 되고 이동되지 않은 부분은 여전히 사용될 수 있습니다. [`Drop` 트레이트](../../trait/drop.md)를 구현한 타입은 부분적으로 이동될 수 없다는 점에 유의하세요. 왜냐하면 해당 타입의 `drop` 메서드가 나중에 전체로서 사용될 것이기 때문입니다."

#: src/scope/move/partial_move.md:22
msgid ""
"// Error! cannot move out of a type which implements the `Drop` trait\n"
"    //impl Drop for Person {\n"
"    //    fn drop(&mut self) {\n"
"    //        println!(\"Dropping the person struct {:?}\", self)\n"
"    //    }\n"
"    //}\n"
"    // TODO ^ Try uncommenting these lines\n"
msgstr ""
"// 에러! `Drop` 트레이트를 구현한 타입에서는 이동해 나올 수 없습니다\n"
"    //impl Drop for Person {\n"
"    //    fn drop(&mut self) {\n"
"    //        println!(\"Person 구조체를 드롭합니다 {:?}\", self)\n"
"    //    }\n"
"    //}\n"
"    // TODO ^ 이 줄들의 주석을 해제해 보세요\n"

#: src/scope/move/partial_move.md:35
msgid "// `name` is moved out of person, but `age` is referenced\n"
msgstr "// `name`은 person에서 밖으로 이동되지만, `age`는 참조됩니다\n"

#: src/scope/move/partial_move.md:38
msgid "\"The person's age is {}\""
msgstr "\"이 사람의 나이는 {}입니다\""

#: src/scope/move/partial_move.md:40
msgid "\"The person's name is {}\""
msgstr "\"이 사람의 이름은 {}입니다\""

#: src/scope/move/partial_move.md:42
msgid ""
"// Error! borrow of partially moved value: `person` partial move occurs\n"
"    //println!(\"The person struct is {:?}\", person);\n"
msgstr ""
"// 에러! 부분적으로 이동된 값의 빌림: `person`의 부분 이동이 발생했습니다\n"
"    //println!(\"Person 구조체는 {:?}입니다\", person);\n"

#: src/scope/move/partial_move.md:45
msgid ""
"// `person` cannot be used but `person.age` can be used as it is not moved\n"
"msgstr "// `person`은 사용할 수 없지만 `person.age`는 이동되지 않았으므로 사용할 수 있습니다\n"

#: src/scope/move/partial_move.md:46
msgid "\"The person's age from person struct is {}\""
msgstr "\"person 구조체에서 가져온 이 사람의 나이는 {}입니다\""

#: src/scope/move/partial_move.md:50
msgid ""
"(In this example, we store the `age` variable on the heap to illustrate the "
"partial move: deleting `ref` in the above code would give an error as the "
"ownership of `person.age` would be moved to the variable `age`. If "
"`Person.age` were stored on the stack, `ref` would not be required as the "
"definition of `age` would copy the data from `person.age` without moving it.)"
msgstr "(이 예제에서는 부분 이동을 설명하기 위해 `age` 변수를 힙에 저장합니다. 위 코드에서 `ref`를 삭제하면 `person.age`의 소유권이 `age` 변수로 이동하기 때문에 에러가 발생합니다. `Person.age`가 스택에 저장되어 있었다면, `age`의 정의가 `person.age`에서 데이터를 이동 없이 복사하므로 `ref`가 필요하지 않았을 것입니다.)"

#: src/scope/move/partial_move.md:59
msgid "[destructuring](../../flow_control/match/destructuring.md)"
msgstr "[구조 분해](../../flow_control/match/destructuring.md)"

#: src/scope/borrow.md:3
msgid ""
"Most of the time, we'd like to access data without taking ownership over it. "
"To accomplish this, Rust uses a _borrowing_ mechanism. Instead of passing "
"objects by value (`T`), objects can be passed by reference (`&T`)."
msgstr "대부분의 경우, 우리는 데이터의 소유권을 가져오지 않고 데이터에 접근하고 싶어 합니다. 이를 달성하기 위해 Rust는 _빌림(borrowing)_ 메커니즘을 사용합니다. 객체를 값(`T`)으로 전달하는 대신, 참조(`&T`)로 전달할 수 있습니다."

#: src/scope/borrow.md:7
msgid ""
"The compiler statically guarantees (via its borrow checker) that references "
"_always_ point to valid objects. That is, while references to an object "
"exist, the object cannot be destroyed."
msgstr "컴파일러는 (빌림 검사기를 통해) 참조가 _항상_ 유효한 객체를 가리킨다는 것을 정적으로 보장합니다. 즉, 객체에 대한 참조가 존재하는 동안에는 해당 객체를 파괴할 수 없습니다."

#: src/scope/borrow.md:12
msgid "// This function takes ownership of a box and destroys it\n"
msgstr "// 이 함수는 상자의 소유권을 가져와 파괴합니다\n"

#: src/scope/borrow.md:14
msgid "\"Destroying box that contains {}\""
msgstr "\"{}를 포함하는 상자를 파괴 중\""

#: src/scope/borrow.md:16
msgid "// This function borrows an i32\n"
msgstr "// 이 함수는 i32를 빌립니다\n"

#: src/scope/borrow.md:19
msgid "\"This int is: {}\""
msgstr "\"이 정수는: {}\""

#: src/scope/borrow.md:23
msgid ""
"// Create a boxed i32 in the heap, and an i32 on the stack\n"
"    // Remember: numbers can have arbitrary underscores added for "
"readability\n"
"    // 5_i32 is the same as 5i32\n"
msgstr ""
"// 힙에 boxed i32를 생성하고, 스택에 i32를 생성합니다\n"
"// 기억하세요: 숫자는 가독성을 위해 임의의 밑줄을 추가할 수 있습니다\n"
"// 5_i32는 5i32와 동일합니다\n"

#: src/scope/borrow.md:29
msgid ""
"// Borrow the contents of the box. Ownership is not taken,\n"
"    // so the contents can be borrowed again.\n"
msgstr ""
"// 상자의 내용물을 빌립니다. 소유권을 가져가지 않으므로,\n"
"// 내용물을 다시 빌릴 수 있습니다.\n"

#: src/scope/borrow.md:35
msgid "// Take a reference to the data contained inside the box\n"
msgstr "// 상자 안에 포함된 데이터에 대한 참조를 가져옵니다\n"

#: src/scope/borrow.md:38
msgid ""
"// Error!\n"
"        // Can't destroy `boxed_i32` while the inner value is borrowed later "
"in scope.\n"
msgstr ""
"// 에러!\n"
"// 내부 값이 스코프의 나중 부분에서 빌려지고 있는 동안에는 `boxed_i32`를 파괴할 수 없습니다.\n"

#: src/scope/borrow.md:43
msgid "// Attempt to borrow `_ref_to_i32` after inner value is destroyed\n"
msgstr "// 내부 값이 파괴된 후에 `_ref_to_i32`를 빌리려고 시도합니다\n"

#: src/scope/borrow.md:45
msgid "// `_ref_to_i32` goes out of scope and is no longer borrowed.\n"
msgstr "// `_ref_to_i32`가 스코프를 벗어나며 더 이상 빌려지지 않습니다.\n"

#: src/scope/borrow.md:48
msgid ""
"// `boxed_i32` can now give up ownership to `eat_box_i32` and be destroyed\n"
msgstr "// `boxed_i32`는 이제 `eat_box_i32`에게 소유권을 넘기고 파괴될 수 있습니다\n"

#: src/scope/borrow/mut.md:3
msgid ""
"Mutable data can be mutably borrowed using `&mut T`. This is called a "
"_mutable reference_ and gives read/write access to the borrower. In "
"contrast, `&T` borrows the data via an immutable reference, and the borrower "
"can read the data but not modify it:"
msgstr ""
"가변 데이터는 `&mut T`를 사용하여 가변적으로 빌려올 수 있습니다. 이를 _가변 참조(mutable reference)_라고 하며 빌리는 사람에게 읽기/쓰기 권한을 부여합니다. 반면 `&T`는 불변 참조를 통해 데이터를 빌려오며, 빌리는 사람은 데이터를 읽을 수는 있지만 수정할 수는 없습니다:"

#: src/scope/borrow/mut.md:12
msgid ""
"// `&'static str` is a reference to a string allocated in read only memory\n"
msgstr "// `&'static str`은 읽기 전용 메모리에 할당된 문자열에 대한 참조입니다\n"

#: src/scope/borrow/mut.md:17
msgid "// This function takes a reference to a book\n"
msgstr "// 이 함수는 책에 대한 참조를 받습니다\n"

#: src/scope/borrow/mut.md:20
msgid "\"I immutably borrowed {} - {} edition\""
msgstr "\"{} - {} 판을 불변으로 빌렸습니다\""

#: src/scope/borrow/mut.md:22
msgid ""
"// This function takes a reference to a mutable book and changes `year` to "
"2014\n"
msgstr "// 이 함수는 가변적인 책에 대한 참조를 받아 `year`를 2014로 변경합니다\n"

#: src/scope/borrow/mut.md:26
msgid "\"I mutably borrowed {} - {} edition\""
msgstr "\"{} - {} 판을 가변으로 빌렸습니다\""

#: src/scope/borrow/mut.md:30
msgid "// Create an immutable Book named `immutabook`\n"
msgstr "// `immutabook`이라는 이름의 불변 책을 생성합니다\n"

#: src/scope/borrow/mut.md:32
msgid "// string literals have type `&'static str`\n"
msgstr "// 문자열 리터럴은 `&'static str` 타입을 가집니다\n"

#: src/scope/borrow/mut.md:33
msgid "\"Douglas Hofstadter\""
msgstr "\"더글라스 호프스태터\""

#: src/scope/borrow/mut.md:34
msgid "\"Gödel, Escher, Bach\""
msgstr "\"괴델, 에셔, 바흐\""

#: src/scope/borrow/mut.md:38
msgid "// Create a mutable copy of `immutabook` and call it `mutabook`\n"
msgstr "// `immutabook`의 가변 복사본을 생성하고 `mutabook`이라고 부릅니다\n"

#: src/scope/borrow/mut.md:41
msgid "// Immutably borrow an immutable object\n"
msgstr "// 불변 객체를 불변으로 빌립니다\n"

#: src/scope/borrow/mut.md:44
msgid "// Immutably borrow a mutable object\n"
msgstr "// 가변 객체를 불변으로 빌립니다\n"

#: src/scope/borrow/mut.md:47
msgid "// Borrow a mutable object as mutable\n"
msgstr "// 가변 객체를 가변으로 빌립니다\n"

#: src/scope/borrow/mut.md:50
msgid "// Error! Cannot borrow an immutable object as mutable\n"
msgstr "// 에러! 불변 객체는 가변으로 빌릴 수 없습니다\n"

#: src/scope/borrow/mut.md:58
msgid "[`static`](../lifetime/static_lifetime.md)"
msgstr "[`static`](../lifetime/static_lifetime.md)"

#: src/scope/borrow/alias.md:3
msgid ""
"Data can be immutably borrowed any number of times, but while immutably "
"borrowed, the original data can't be mutably borrowed. On the other hand, "
"only _one_ mutable borrow is allowed at a time. The original data can be "
"borrowed again only _after_ the mutable reference has been used for the last "
"time."
msgstr "데이터는 횟수에 제한 없이 불변으로 빌려질 수 있지만, 불변으로 빌려진 동안에는 원본 데이터를 가변으로 빌릴 수 없습니다. 반면에, 가변 빌림은 한 번에 _하나_만 허용됩니다. 원본 데이터는 가변 참조가 마지막으로 사용된 _후_에만 다시 빌려질 수 있습니다."

#: src/scope/borrow/alias.md:17
msgid "// Data can be accessed via the references and the original owner\n"
msgstr "// 데이터는 참조와 원본 소유자를 통해 접근할 수 있습니다\n"

#: src/scope/borrow/alias.md:18 src/scope/borrow/alias.md:27
#: src/scope/borrow/alias.md:49
msgid "\"Point has coordinates: ({}, {}, {})\""
msgstr "\"점의 좌표: ({}, {}, {})\""

#: src/scope/borrow/alias.md:21
msgid ""
"// Error! Can't borrow `point` as mutable because it's currently\n"
"    // borrowed as immutable.\n"
"    // let mutable_borrow = &mut point;\n"
"    // TODO ^ Try uncommenting this line\n"
msgstr ""
"// 에러! 현재 불변으로 빌려진 상태이기 때문에 `point`를 가변으로 빌릴 수 없습니다.\n"
"// let mutable_borrow = &mut point;\n"
"// TODO ^ 이 줄의 주석을 해제해 보세요\n"

#: src/scope/borrow/alias.md:26
msgid "// The borrowed values are used again here\n"
msgstr "// 빌려온 값들이 여기서 다시 사용됩니다\n"

#: src/scope/borrow/alias.md:30
msgid ""
"// The immutable references are no longer used for the rest of the code so\n"
"    // it is possible to reborrow with a mutable reference.\n"
msgstr ""
"// 불변 참조들이 코드의 나머지 부분에서 더 이상 사용되지 않으므로\n"
"// 가변 참조로 다시 빌리는 것이 가능합니다.\n"

#: src/scope/borrow/alias.md:34
msgid "// Change data via mutable reference\n"
msgstr "// 가변 참조를 통해 데이터를 변경합니다\n"

#: src/scope/borrow/alias.md:39
msgid ""
"// Error! Can't borrow `point` as immutable because it's currently\n"
"    // borrowed as mutable.\n"
"    // let y = &point.y;\n"
"    // TODO ^ Try uncommenting this line\n"
msgstr ""
"// 에러! 현재 가변으로 빌려진 상태이기 때문에 `point`를 불변으로 빌릴 수 없습니다.\n"
"// let y = &point.y;\n"
"// TODO ^ 이 줄의 주석을 해제해 보세요\n"

#: src/scope/borrow/alias.md:44
msgid ""
"// Error! Can't print because `println!` takes an immutable reference.\n"
"    // println!(\"Point Z coordinate is {}\", point.z);\n"
"    // TODO ^ Try uncommenting this line\n"
msgstr ""
"// 에러! `println!`은 불변 참조를 받기 때문에 출력할 수 없습니다.\n"
"// println!(\"점의 Z 좌표는 {}입니다\", point.z);\n"
"// TODO ^ 이 줄의 주석을 해제해 보세요\n"

#: src/scope/borrow/alias.md:48
msgid "// Ok! Mutable references can be passed as immutable to `println!`\n"
msgstr "// 좋습니다! 가변 참조는 불변 참조로 `println!`에 전달될 수 있습니다\n"

#: src/scope/borrow/alias.md:52
msgid ""
"// The mutable reference is no longer used for the rest of the code so it\n"
"    // is possible to reborrow\n"
msgstr ""
"// 가변 참조가 코드의 나머지 부분에서 더 이상 사용되지 않으므로\n"
"// 다시 빌리는 것이 가능합니다\n"

#: src/scope/borrow/alias.md:55
msgid "\"Point now has coordinates: ({}, {}, {})\""
msgstr "\"점은 이제 다음 좌표를 가집니다: ({}, {}, {})\""

#: src/scope/borrow/ref.md:3
msgid ""
"When doing pattern matching or destructuring via the `let` binding, the "
"`ref` keyword can be used to take references to the fields of a struct/"
"tuple. The example below shows a few instances where this can be useful:"
msgstr "`let` 바인딩을 통해 패턴 매칭이나 구조 분해를 수행할 때, `ref` 키워드를 사용하여 구조체/튜플 필드에 대한 참조를 가져올 수 있습니다. 아래 예제는 이것이 유용할 수 있는 몇 가지 사례를 보여줍니다:"

#: src/scope/borrow/ref.md:14
msgid ""
"// A `ref` borrow on the left side of an assignment is equivalent to\n"
"    // an `&` borrow on the right side.\n"
msgstr ""
"// 할당의 왼쪽 편에 있는 `ref` 빌림은\n"
"// 오른쪽 편에 있는 `&` 빌림과 동일합니다.\n"

#: src/scope/borrow/ref.md:19
msgid "\"ref_c1 equals ref_c2: {}\""
msgstr "\"ref_c1은 ref_c2와 같습니다: {}\""

#: src/scope/borrow/ref.md:23
msgid "// `ref` is also valid when destructuring a struct.\n"
msgstr "// `ref`는 구조체를 구조 분해할 때도 유효합니다.\n"

#: src/scope/borrow/ref.md:25
msgid "// `ref_to_x` is a reference to the `x` field of `point`.\n"
msgstr "// `ref_to_x`는 `point`의 `x` 필드에 대한 참조입니다.\n"

#: src/scope/borrow/ref.md:28
msgid "// Return a copy of the `x` field of `point`.\n"
msgstr "// `point`의 `x` 필드 복사본을 반환합니다.\n"

#: src/scope/borrow/ref.md:32
msgid "// A mutable copy of `point`\n"
msgstr "// `point`의 가변 복사본\n"

#: src/scope/borrow/ref.md:36
msgid "// `ref` can be paired with `mut` to take mutable references.\n"
msgstr "// `ref`는 `mut`와 짝을 이루어 가변 참조를 가져올 수 있습니다.\n"

#: src/scope/borrow/ref.md:39
msgid "// Mutate the `y` field of `mutable_point` via a mutable reference.\n"
msgstr "// 가변 참조를 통해 `mutable_point`의 `y` 필드를 변경합니다.\n"

#: src/scope/borrow/ref.md:43
msgid "\"point is ({}, {})\""
msgstr "\"point는 ({}, {})입니다\""

#: src/scope/borrow/ref.md:44
msgid "\"mutable_point is ({}, {})\""
msgstr "\"mutable_point는 ({}, {})입니다\""

#: src/scope/borrow/ref.md:46
msgid "// A mutable tuple that includes a pointer\n"
msgstr "// 포인터를 포함하는 가변 튜플\n"

#: src/scope/borrow/ref.md:50
msgid "// Destructure `mutable_tuple` to change the value of `last`.\n"
msgstr "// `mutable_tuple`을 구조 분해하여 `last` 값을 변경합니다.\n"

#: src/scope/borrow/ref.md:55
msgid "\"tuple is {:?}\""
msgstr "\"튜플은 {:?}입니다\""

#: src/scope/lifetime.md:3
msgid ""
"A _lifetime_ is a construct the compiler (or more specifically, its _borrow "
"checker_) uses to ensure all borrows are valid. Specifically, a variable's "
"lifetime begins when it is created and ends when it is destroyed. While "
"lifetimes and scopes are often referred to together, they are not the same."
msgstr "_라이프타임(lifetime)_은 컴파일러(더 구체적으로는 _빌림 검사기_)가 모든 빌림이 유효한지 확인하기 위해 사용하는 구성 요소입니다. 구체적으로, 변수의 라이프타임은 생성될 때 시작하고 파괴될 때 끝납니다. 라이프타임과 스코프는 종종 함께 언급되지만, 같은 것은 아닙니다."

#: src/scope/lifetime.md:8
msgid ""
"Take, for example, the case where we borrow a variable via `&`. The borrow "
"has a lifetime that is determined by where it is declared. As a result, the "
"borrow is valid as long as it ends before the lender is destroyed. However, "
"the scope of the borrow is determined by where the reference is used."
msgstr "예를 들어, `&`를 통해 변수를 빌리는 경우를 생각해 봅시다. 빌림은 선언된 위치에 따라 결정되는 라이프타임을 가집니다. 결과적으로 빌림은 빌려준 대상이 파괴되기 전에 끝나는 한 유효합니다. 하지만 빌림의 스코프는 참조가 사용되는 위치에 따라 결정됩니다."

#: src/scope/lifetime.md:13
msgid ""
"In the following example and in the rest of this section, we will see how "
"lifetimes relate to scopes, as well as how the two differ."
msgstr "다음 예제와 이 섹션의 나머지 부분에서 라이프타임이 스코프와 어떻게 관련되어 있는지, 그리고 두 가지가 어떻게 다른지 살펴보겠습니다."

#: src/scope/lifetime.md:17
msgid ""
"// Lifetimes are annotated below with lines denoting the creation\n"
"// and destruction of each variable.\n"
"// `i` has the longest lifetime because its scope entirely encloses\n"
"// both `borrow1` and `borrow2`. The duration of `borrow1` compared\n"
"// to `borrow2` is irrelevant since they are disjoint.\n"
msgstr ""
"// 아래에는 각 변수의 생성과 파괴를 나타내는 선으로 라이프타임이 주석 처리되어 있습니다.\n"
"// `i`의 스코프가 `borrow1`과 `borrow2`를 완전히 감싸고 있기 때문에\n"
"// `i`는 가장 긴 라이프타임을 가집니다. `borrow1`과 `borrow2`는 서로 겹치지 않으므로\n"
"// 둘의 기간 비교는 무의미합니다.\n"

#: src/scope/lifetime.md:23
msgid ""
"// Lifetime for `i` starts. ────────────────┐\n"
"    //                                                     │\n"
msgstr ""
"// `i`의 라이프타임 시작. ──────────────────┐\n"
"    //                                                     │\n"

#: src/scope/lifetime.md:25 src/scope/lifetime.md:32
msgid "//                                                   │\n"
msgstr "//                                                   │\n"

#: src/scope/lifetime.md:26
msgid ""
"// `borrow1` lifetime starts. ──┐│\n"
"        //                                                ││\n"
msgstr ""
"// `borrow1` 라이프타임 시작. ──┐│\n"
"        //                                                ││\n"

#: src/scope/lifetime.md:28
msgid "\"borrow1: {}\""
msgstr "\"borrow1: {}\""

#: src/scope/lifetime.md:28 src/scope/lifetime.md:35
msgid "//              ││\n"
msgstr "//              ││\n"

#: src/scope/lifetime.md:29
msgid ""
"// `borrow1` ends. ─────────────────────────────────┘│\n"
"    //                                                     │\n"
"    //                                                     │\n"
msgstr ""
"// `borrow1` 끝. ───────────────────────────────────┘│\n"
"    //                                                     │\n"
"    //                                                     │\n"

#: src/scope/lifetime.md:33
msgid ""
"// `borrow2` lifetime starts. ──┐│\n"
"        //                                                ││\n"
msgstr ""
"// `borrow2` 라이프타임 시작. ──┐│\n"
"        //                                                ││\n"

#: src/scope/lifetime.md:35
msgid "\"borrow2: {}\""
msgstr "\"borrow2: {}\""

#: src/scope/lifetime.md:36
msgid ""
"// `borrow2` ends. ─────────────────────────────────┘│\n"
"    //                                                     │\n"
msgstr ""
"// `borrow2` 끝. ───────────────────────────────────┘│\n"
"    //                                                     │\n"

#: src/scope/lifetime.md:38
msgid "// Lifetime ends. ─────────────────────────────────────┘\n"
msgstr "// 라이프타임 끝. ─────────────────────────────────────┘\n"

#: src/scope/lifetime.md:41
msgid ""
"Note that no names or types are assigned to label lifetimes. This restricts "
"how lifetimes will be able to be used as we will see."
msgstr "레이블 라이프타임에는 이름이나 타입이 할당되지 않는다는 점에 유의하세요. 이는 앞으로 보게 될 것처럼 라이프타임을 사용하는 방식에 제한을 줍니다."

#: src/scope/lifetime/explicit.md:3
msgid ""
"The borrow checker uses explicit lifetime annotations to determine how long "
"references should be valid. In cases where lifetimes are not elided[^1], "
"Rust requires explicit annotations to determine what the lifetime of a "
"reference should be. The syntax for explicitly annotating a lifetime uses an "
"apostrophe character as follows:"
msgstr "빌림 검사기는 참조가 얼마나 오래 유효해야 하는지 결정하기 위해 명시적 라이프타임 어노테이션을 사용합니다. 라이프타임이 생략(elided)[^1]되지 않는 경우, Rust는 참조의 라이프타임이 어떻게 되어야 하는지 결정하기 위해 명시적인 어노테이션을 요구합니다. 라이프타임을 명시적으로 어노테이션하는 구문은 다음과 같이 아포스트로피 문자를 사용합니다:"

#: src/scope/lifetime/explicit.md:10
msgid "// `foo` has a lifetime parameter `'a`\n"
msgstr "// `foo`는 라이프타임 파라미터 `'a`를 가집니다\n"

#: src/scope/lifetime/explicit.md:14
msgid ""
"Similar to [closures](../../fn/closures/anonymity.md), using lifetimes "
"requires generics. Additionally, this lifetime syntax indicates that the "
"lifetime of `foo` may not exceed that of `'a`. Explicit annotation of a type "
"has the form `&'a T` where `'a` has already been introduced."
msgstr "[클로저](../../fn/closures/anonymity.md)와 유사하게, 라이프타임을 사용하려면 제네릭이 필요합니다. 또한, 이 라이프타임 구문은 `foo`의 라이프타임이 `'a`의 라이프타임을 초과할 수 없음을 나타냅니다. 타입의 명시적 어노테이션은 `&'a T` 형식을 가지며, 여기서 `'a`는 이미 도입된 라이프타임입니다."

#: src/scope/lifetime/explicit.md:19
msgid "In cases with multiple lifetimes, the syntax is similar:"
msgstr "여러 라이프타임이 있는 경우에도 구문은 유사합니다:"

#: src/scope/lifetime/explicit.md:22
msgid "// `foo` has lifetime parameters `'a` and `'b`\n"
msgstr "// `foo`는 라이프타임 파라미터 `'a`와 `'b`를 가집니다\n"

#: src/scope/lifetime/explicit.md:26
msgid ""
"In this case, the lifetime of `foo` cannot exceed that of either `'a` _or_ "
"`'b`."
msgstr "이 경우, `foo`의 라이프타임은 `'a` _또는_ `'b` 중 어느 하나의 라이프타임도 초과할 수 없습니다."

#: src/scope/lifetime/explicit.md:28
msgid "See the following example for explicit lifetime annotation in use:"
msgstr "명시적 라이프타임 어노테이션이 사용된 다음 예제를 참조하세요:"

#: src/scope/lifetime/explicit.md:31
msgid ""
"// `print_refs` takes two references to `i32` which have different\n"
"// lifetimes `'a` and `'b`. These two lifetimes must both be at\n"
"// least as long as the function `print_refs`.\n"
msgstr ""
"// `print_refs`는 서로 다른 라이프타임 `'a`와 `'b`를 가진\n"
"// 두 개의 `i32` 참조를 받습니다. 이 두 라이프타임은 모두\n"
"// 적어도 `print_refs` 함수만큼 길어야 합니다.\n"

#: src/scope/lifetime/explicit.md:35
msgid "\"x is {} and y is {}\""
msgstr "\"x는 {}이고 y는 {}입니다\""

#: src/scope/lifetime/explicit.md:37
msgid ""
"// A function which takes no arguments, but has a lifetime parameter `'a`.\n"
msgstr "// 인자를 받지 않지만 라이프타임 파라미터 `'a`를 가진 함수입니다.\n"

#: src/scope/lifetime/explicit.md:42
msgid "// ERROR: `_x` does not live long enough\n"
msgstr "// 에러: `_x`의 수명이 충분히 길지 않습니다\n"

#: src/scope/lifetime/explicit.md:44
msgid ""
"// Attempting to use the lifetime `'a` as an explicit type annotation\n"
"    // inside the function will fail because the lifetime of `&_x` is "
"shorter\n"
"    // than that of `_y`. A short lifetime cannot be coerced into a longer "
"one.\n"
msgstr ""
"// 함수 내부에서 라이프타임 `'a`를 명시적 타입 어노테이션으로 사용하려고 하면\n"
"    // 실패합니다. `&_x`의 라이프타임이 `_y`의 라이프타임보다 짧기 때문입니다.\n"
"    // 짧은 라이프타임은 더 긴 라이프타임으로 강제 변환될 수 없습니다.\n"

#: src/scope/lifetime/explicit.md:50
msgid "// Create variables to be borrowed below.\n"
msgstr "// 아래에서 빌려올 변수들을 생성합니다.\n"

#: src/scope/lifetime/explicit.md:53
msgid "// Borrows (`&`) of both variables are passed into the function.\n"
msgstr "// 두 변수의 빌림(`&`)이 함수로 전달됩니다.\n"

#: src/scope/lifetime/explicit.md:55
msgid ""
"// Any input which is borrowed must outlive the borrower.\n"
"    // In other words, the lifetime of `four` and `nine` must\n"
"    // be longer than that of `print_refs`.\n"
msgstr ""
"// 빌려온 모든 입력은 빌리는 주체보다 오래 살아야 합니다.\n"
"    // 다시 말해, `four`와 `nine`의 라이프타임은\n"
"    // `print_refs`의 라이프타임보다 길어야 합니다.\n"

#: src/scope/lifetime/explicit.md:60
msgid ""
"// `failed_borrow` contains no references to force `'a` to be\n"
"    // longer than the lifetime of the function, but `'a` is longer.\n"
"    // Because the lifetime is never constrained, it defaults to `'static`.\n"
msgstr ""
"// `failed_borrow`는 `'a`가 함수의 라이프타임보다 길어야 함을 강제하는\n"
"// 참조를 포함하지 않지만, `'a`는 더 깁니다.\n"
"// 라이프타임이 결코 제약되지 않으므로, 이는 `'static`으로 기본 설정됩니다.\n"

#: src/scope/lifetime/explicit.md:66
msgid ""
"[elision](elision.md) implicitly annotates lifetimes and so is different."
msgstr "[생략(elision)](elision.md)은 암시적으로 라이프타임을 어노테이션하므로 다릅니다."

#: src/scope/lifetime/explicit.md:70
msgid "[generics](../../generics.md) and [closures](../../fn/closures.md)"
msgstr "[제네릭](../../generics.md) 및 [클로저](../../fn/closures.md)"

#: src/scope/lifetime/fn.md:3
msgid ""
"Ignoring [elision](elision.md), function signatures with lifetimes have a "
"few constraints:"
msgstr "[생략](elision.md)을 무시하고, 라이프타임을 가진 함수 시그니처에는 몇 가지 제약 사항이 있습니다:"

#: src/scope/lifetime/fn.md:5
msgid "any reference _must_ have an annotated lifetime."
msgstr "모든 참조는 _반드시_ 어노테이션된 라이프타임을 가져야 합니다."

#: src/scope/lifetime/fn.md:6
msgid ""
"any reference being returned _must_ have the same lifetime as an input or be "
"`static`."
msgstr "반환되는 모든 참조는 입력과 동일한 라이프타임을 가지거나 `static`이어야 _합니다_."

#: src/scope/lifetime/fn.md:9
msgid ""
"Additionally, note that returning references without input is banned if it "
"would result in returning references to invalid data. The following example "
"shows off some valid forms of functions with lifetimes:"
msgstr "또한, 입력 없이 참조를 반환하는 것이 유효하지 않은 데이터에 대한 참조를 반환하는 결과를 낳는다면 금지된다는 점에 유의하세요. 다음 예제는 라이프타임이 있는 유효한 함수 형태를 보여줍니다:"

#: src/scope/lifetime/fn.md:14
msgid ""
"// One input reference with lifetime `'a` which must live\n"
"// at least as long as the function.\n"
msgstr ""
"// 라이프타임 `'a`를 가진 하나의 입력 참조입니다.\n"
"// 이 참조는 적어도 함수만큼 오래 살아야 합니다.\n"

#: src/scope/lifetime/fn.md:17
msgid "\"`print_one`: x is {}\""
msgstr "\"`print_one`: x는 {}입니다\""

#: src/scope/lifetime/fn.md:19
msgid "// Mutable references are possible with lifetimes as well.\n"
msgstr "// 가변 참조도 라이프타임과 함께 사용할 수 있습니다.\n"

#: src/scope/lifetime/fn.md:24
msgid ""
"// Multiple elements with different lifetimes. In this case, it\n"
"// would be fine for both to have the same lifetime `'a`, but\n"
"// in more complex cases, different lifetimes may be required.\n"
msgstr ""
"// 서로 다른 라이프타임을 가진 여러 요소들입니다. 이 경우,\n"
"// 둘 다 동일한 라이프타임 `'a`를 가져도 괜찮지만,\n"
"// 더 복잡한 경우에는 서로 다른 라이프타임이 필요할 수 있습니다.\n"

#: src/scope/lifetime/fn.md:29
msgid "\"`print_multi`: x is {}, y is {}\""
msgstr "\"`print_multi`: x는 {}, y는 {}입니다\""

#: src/scope/lifetime/fn.md:31
msgid ""
"// Returning references that have been passed in is acceptable.\n"
"// However, the correct lifetime must be returned.\n"
msgstr ""
"// 전달된 참조를 반환하는 것은 허용됩니다.\n"
"// 하지만, 올바른 라이프타임이 반환되어야 합니다.\n"

#: src/scope/lifetime/fn.md:35
msgid ""
"//fn invalid_output<'a>() -> &'a String { &String::from(\"foo\") }\n"
"// The above is invalid: `'a` must live longer than the function.\n"
"// Here, `&String::from(\"foo\")` would create a `String`, followed by a\n"
"// reference. Then the data is dropped upon exiting the scope, leaving\n"
"// a reference to invalid data to be returned.\n"
msgstr ""
"//fn invalid_output<'a>() -> &'a String { &String::from(\"foo\") }\n"
"// 위 코드는 유효하지 않습니다: `'a`는 함수보다 오래 살아야 합니다.\n"
"// 여기서 `&String::from(\"foo\")`는 `String`을 생성한 후 참조를 생성합니다.\n"
"// 그런 다음 스코프를 벗어날 때 데이터가 드롭되어,\n"
"// 유효하지 않은 데이터에 대한 참조가 반환됩니다.\n"

#: src/scope/lifetime/fn.md:60
msgid "[Functions](../../fn.md)"
msgstr "[함수](../../fn.md)"

#: src/scope/lifetime/methods.md:3
msgid "Methods are annotated similarly to functions:"
msgstr "메서드는 함수와 유사하게 어노테이션됩니다:"

#: src/scope/lifetime/methods.md:9
msgid "// Annotate lifetimes as in a standalone function.\n"
msgstr "// 독립형 함수처럼 라이프타임을 어노테이션합니다.\n"

#: src/scope/lifetime/methods.md:12
msgid "\"`print`: {}\""
msgstr "\"`print`: {}\""

#: src/scope/lifetime/methods.md:26
msgid "[methods](../../fn/methods.md)"
msgstr "[메서드](../../fn/methods.md)"

#: src/scope/lifetime/struct.md:3
msgid "Annotation of lifetimes in structures are also similar to functions:"
msgstr "구조체에서의 라이프타임 어노테이션도 함수와 비슷합니다:"

#: src/scope/lifetime/struct.md:6
msgid ""
"// A type `Borrowed` which houses a reference to an\n"
"// `i32`. The reference to `i32` must outlive `Borrowed`.\n"
msgstr ""
"// `i32`에 대한 참조를 보관하는 `Borrowed` 타입입니다.\n"
"// `i32`에 대한 참조는 `Borrowed`보다 오래 살아야 합니다.\n"

#: src/scope/lifetime/struct.md:10
msgid "// Similarly, both references here must outlive this structure.\n"
msgstr "// 마찬가지로, 여기의 두 참조는 이 구조체보다 오래 살아야 합니다.\n"

#: src/scope/lifetime/struct.md:17
msgid "// An enum which is either an `i32` or a reference to one.\n"
msgstr "// `i32`이거나 이에 대한 참조인 열거형입니다.\n"

#: src/scope/lifetime/struct.md:34 src/scope/lifetime/struct.md:36
msgid "\"x is borrowed in {:?}\""
msgstr "\"x는 {:?}에서 빌려졌습니다\""

#: src/scope/lifetime/struct.md:35
msgid "\"x and y are borrowed in {:?}\""
msgstr "\"x와 y는 {:?}에서 빌려졌습니다\""

#: src/scope/lifetime/struct.md:37
msgid "\"y is *not* borrowed in {:?}\""
msgstr "\"y는 {:?}에서 빌려지지 *않았습니다*\""

#: src/scope/lifetime/struct.md:43
msgid "[`struct`s](../../custom_types/structs.md)"
msgstr "[`struct`](../../custom_types/structs.md)"

#: src/scope/lifetime/trait.md:3
msgid ""
"Annotation of lifetimes in trait methods basically are similar to functions. "
"Note that `impl` may have annotation of lifetimes too."
msgstr "트레이트 메서드의 라이프타임 어노테이션은 기본적으로 함수와 유사합니다. `impl`도 라이프타임 어노테이션을 가질 수 있음에 유의하세요."

#: src/scope/lifetime/trait.md:7
msgid "// A struct with annotation of lifetimes.\n"
msgstr "// 라이프타임 어노테이션이 있는 구조체.\n"

#: src/scope/lifetime/trait.md:12
msgid "// Annotate lifetimes to impl.\n"
msgstr "// impl에 라이프타임을 어노테이션합니다.\n"

#: src/scope/lifetime/trait.md:24
msgid "\"b is {:?}\""
msgstr "\"b는 {:?}입니다\""

#: src/scope/lifetime/trait.md:30
msgid "[`trait`s](../../trait.md)"
msgstr "[`trait`](../../trait.md)"

#: src/scope/lifetime/lifetime_bounds.md:3
msgid ""
"Just like generic types can be bounded, lifetimes (themselves generic) use "
"bounds as well. The `:` character has a slightly different meaning here, but "
"`+` is the same. Note how the following read:"
msgstr "제네릭 타입이 바운드될 수 있는 것처럼, (그 자체로 제네릭인) 라이프타임도 바운드를 사용합니다. 여기서 `:` 문자는 약간 다른 의미를 갖지만, `+`는 동일합니다. 다음이 어떻게 읽히는지 주목하세요:"

#: src/scope/lifetime/lifetime_bounds.md:7
msgid "`T: 'a`: _All_ references in `T` must outlive lifetime `'a`."
msgstr "`T: 'a`: `T` 내의 _모든_ 참조는 라이프타임 `'a`보다 오래 살아야 합니다."

#: src/scope/lifetime/lifetime_bounds.md:8
msgid ""
"`T: Trait + 'a`: Type `T` must implement trait `Trait` and _all_ references "
"in `T` must outlive `'a`."
msgstr "`T: Trait + 'a`: 타입 `T`는 트레이트 `Trait`를 구현해야 하며, `T` 내의 _모든_ 참조는 `'a`보다 오래 살아야 합니다."

#: src/scope/lifetime/lifetime_bounds.md:11
msgid ""
"The example below shows the above syntax in action used after keyword "
"`where`:"
msgstr "아래 예제는 `where` 키워드 뒤에 사용된 위 구문의 실제 사용 예를 보여줍니다:"

#: src/scope/lifetime/lifetime_bounds.md:14
msgid "// Trait to bound with.\n"
msgstr "// 바운드할 트레이트.\n"

#: src/scope/lifetime/lifetime_bounds.md:17
msgid ""
"// `Ref` contains a reference to a generic type `T` that has\n"
"// some lifetime `'a` unknown by `Ref`. `T` is bounded such that any\n"
"// *references* in `T` must outlive `'a`. Additionally, the lifetime\n"
"// of `Ref` may not exceed `'a`.\n"
msgstr ""
"// `Ref`는 `Ref`가 알 수 없는 어떤 라이프타임 `'a`를 가진 제네릭 타입 `T`에 대한\n"
"// 참조를 포함합니다. `T`는 `T` 내부의 모든 *참조*가 `'a`보다 오래 살아야 한다는\n"
"// 바운드를 가집니다. 추가적으로, `Ref`의 라이프타임은 `'a`를 초과할 수 없습니다.\n"

#: src/scope/lifetime/lifetime_bounds.md:22
msgid "// A generic function which prints using the `Debug` trait.\n"
msgstr "// `Debug` 트레이트를 사용하여 출력하는 제네릭 함수.\n"

#: src/scope/lifetime/lifetime_bounds.md:26
msgid "\"`print`: t is {:?}\""
msgstr "\"`print`: t는 {:?}입니다\""

#: src/scope/lifetime/lifetime_bounds.md:28
msgid ""
"// Here a reference to `T` is taken where `T` implements\n"
"// `Debug` and all *references* in `T` outlive `'a`. In\n"
"// addition, `'a` must outlive the function.\n"
msgstr ""
"// 여기서 `T`는 `Debug`를 구현하고 `T`의 모든 *참조*가 `'a`보다 오래 사는\n"
"// `T`에 대한 참조를 받습니다. 또한, `'a`는 함수보다 오래 살아야 합니다.\n"

#: src/scope/lifetime/lifetime_bounds.md:34
msgid "\"`print_ref`: t is {:?}\""
msgstr "\"`print_ref`: t는 {:?}입니다\""

#: src/scope/lifetime/lifetime_bounds.md:48
msgid ""
"[generics](../../generics.md), [bounds in generics](../../generics/"
"bounds.md), and [multiple bounds in generics](../../generics/multi_bounds.md)"
msgstr "[제네릭](../../generics.md), [제네릭의 바운드](../../generics/bounds.md), 그리고 [제네릭의 다중 바운드](../../generics/multi_bounds.md)"

#: src/scope/lifetime/lifetime_coercion.md:3
msgid ""
"A longer lifetime can be coerced into a shorter one so that it works inside "
"a scope it normally wouldn't work in. This comes in the form of inferred "
"coercion by the Rust compiler, and also in the form of declaring a lifetime "
"difference:"
msgstr "더 긴 라이프타임은 평소에는 작동하지 않을 스코프 내에서도 작동하도록 더 짧은 라이프타임으로 강제 변환(coerced)될 수 있습니다. 이는 Rust 컴파일러에 의한 추론된 강제 변환 형태와 라이프타임 차이를 선언하는 형태로 나타납니다:"

#: src/scope/lifetime/lifetime_coercion.md:9
msgid ""
"// Here, Rust infers a lifetime that is as short as possible.\n"
"// The two references are then coerced to that lifetime.\n"
msgstr ""
"// 여기서 Rust는 가능한 한 짧은 라이프타임을 추론합니다.\n"
"// 그 후 두 참조는 해당 라이프타임으로 강제 변환됩니다.\n"

#: src/scope/lifetime/lifetime_coercion.md:14
msgid ""
"// `<'a: 'b, 'b>` reads as lifetime `'a` is at least as long as `'b`.\n"
"// Here, we take in an `&'a i32` and return a `&'b i32` as a result of "
"coercion.\n"
msgstr ""
"// `<'a: 'b, 'b>`는 라이프타임 `'a`가 적어도 `'b`만큼 길다는 뜻으로 읽힙니다.\n"
"// 여기서 우리는 `&'a i32`를 받아 강제 변환의 결과로 `&'b i32`를 반환합니다.\n"

#: src/scope/lifetime/lifetime_coercion.md:22
msgid "// Longer lifetime\n"
msgstr "// 더 긴 라이프타임\n"

#: src/scope/lifetime/lifetime_coercion.md:25
msgid "// Shorter lifetime\n"
msgstr "// 더 짧은 라이프타임\n"

#: src/scope/lifetime/lifetime_coercion.md:27
msgid "\"The product is {}\""
msgstr "\"곱은 {}입니다\""

#: src/scope/lifetime/lifetime_coercion.md:28
msgid "\"{} is the first\""
msgstr "\"{}은(는) 첫 번째입니다\""

#: src/scope/lifetime/static_lifetime.md:3
msgid ""
"Rust has a few reserved lifetime names. One of those is `'static`. You might "
"encounter it in two situations:"
msgstr "Rust에는 몇 가지 예약된 라이프타임 이름이 있습니다. 그중 하나가 `'static`입니다. 두 가지 상황에서 이를 마주칠 수 있습니다:"

#: src/scope/lifetime/static_lifetime.md:7
msgid "// A reference with 'static lifetime:\n"
msgstr "// 'static 라이프타임을 가진 참조:\n"

#: src/scope/lifetime/static_lifetime.md:8
msgid "\"hello world\""
msgstr "\"안녕 세상\""

#: src/scope/lifetime/static_lifetime.md:9
msgid "// 'static as part of a trait bound:\n"
msgstr "// 트레이트 바운드의 일부로서의 'static:\n"

#: src/scope/lifetime/static_lifetime.md:14
msgid ""
"Both are related but subtly different and this is a common source for "
"confusion when learning Rust. Here are some examples for each situation:"
msgstr "두 가지는 관련이 있지만 미묘하게 다르며, 이는 Rust를 배울 때 흔한 혼란의 원인이 됩니다. 각 상황에 대한 몇 가지 예시를 소개합니다:"

#: src/scope/lifetime/static_lifetime.md:17
msgid "Reference lifetime"
msgstr "참조 라이프타임"

#: src/scope/lifetime/static_lifetime.md:19
msgid ""
"As a reference lifetime `'static` indicates that the data pointed to by the "
"reference lives for the remaining lifetime of the running program. It can "
"still be coerced to a shorter lifetime."
msgstr "참조 라이프타임으로서 `'static`은 참조가 가리키는 데이터가 실행 중인 프로그램의 남은 수명 동안 살아있음을 나타냅니다. 여전히 더 짧은 라이프타임으로 강제 변환될 수 있습니다."

#: src/scope/lifetime/static_lifetime.md:23
msgid ""
"There are two common ways to make a variable with `'static` lifetime, and "
"both are stored in the read-only memory of the binary:"
msgstr "`'static` 라이프타임을 가진 변수를 만드는 두 가지 일반적인 방법이 있으며, 둘 다 바이너리의 읽기 전용 메모리에 저장됩니다:"

#: src/scope/lifetime/static_lifetime.md:26
msgid "Make a constant with the `static` declaration."
msgstr "`static` 선언으로 상수를 만듭니다."

#: src/scope/lifetime/static_lifetime.md:27
msgid "Make a `string` literal which has type: `&'static str`."
msgstr "`&'static str` 타입을 갖는 `문자열` 리터럴을 만듭니다."

#: src/scope/lifetime/static_lifetime.md:29
msgid "See the following example for a display of each method:"
msgstr "각 방법에 대한 예제는 다음을 참조하세요:"

#: src/scope/lifetime/static_lifetime.md:32
msgid "// Make a constant with `'static` lifetime.\n"
msgstr "// `'static` 라이프타임을 가진 상수를 만듭니다.\n"

#: src/scope/lifetime/static_lifetime.md:34
msgid ""
"// Returns a reference to `NUM` where its `'static`\n"
"// lifetime is coerced to that of the input argument.\n"
msgstr ""
"// `NUM`에 대한 참조를 반환합니다. 여기서 `NUM`의 `'static`\n"
"// 라이프타임은 입력 인자의 라이프타임으로 강제 변환됩니다.\n"

#: src/scope/lifetime/static_lifetime.md:43
msgid "// Make a `string` literal and print it:\n"
msgstr "// `문자열` 리터럴을 만들고 출력합니다:\n"

#: src/scope/lifetime/static_lifetime.md:44
msgid "\"I'm in read-only memory\""
msgstr "\"저는 읽기 전용 메모리에 있습니다\""

#: src/scope/lifetime/static_lifetime.md:45
msgid "\"static_string: {}\""
msgstr "\"static_string: {}\""

#: src/scope/lifetime/static_lifetime.md:47
msgid ""
"// When `static_string` goes out of scope, the reference\n"
"        // can no longer be used, but the data remains in the binary.\n"
msgstr ""
"// `static_string`이 스코프를 벗어나면, 참조는\n"
"// 더 이상 사용할 수 없지만, 데이터는 바이너리에 남아 있습니다.\n"

#: src/scope/lifetime/static_lifetime.md:52
msgid "// Make an integer to use for `coerce_static`:\n"
msgstr "// `coerce_static`에 사용할 정수를 만듭니다:\n"

#: src/scope/lifetime/static_lifetime.md:55
msgid "// Coerce `NUM` to lifetime of `lifetime_num`:\n"
msgstr "// `NUM`을 `lifetime_num`의 라이프타임으로 강제 변환합니다:\n"

#: src/scope/lifetime/static_lifetime.md:58
msgid "\"coerced_static: {}\""
msgstr "\"강제 변환된 static: {}\""

#: src/scope/lifetime/static_lifetime.md:61
msgid "\"NUM: {} stays accessible!\""
msgstr "\"NUM: {} 여전히 접근 가능합니다!\""

#: src/scope/lifetime/static_lifetime.md:65
msgid ""
"Since `'static` references only need to be valid for the _remainder_ of a "
"program's life, they can be created while the program is executed. Just to "
"demonstrate, the below example uses [`Box::leak`](https://doc.rust-lang.org/"
"std/boxed/struct.Box.html#method.leak) to dynamically create `'static` "
"references. In that case it definitely doesn't live for the entire duration, "
"but only from the leaking point onward."
msgstr "`'static` 참조는 프로그램 수명의 _나머지_ 기간 동안만 유효하면 되므로, 프로그램이 실행되는 동안 생성될 수 있습니다. 아래 예제는 [`Box::leak`](https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak)를 사용하여 `'static` 참조를 동적으로 생성하는 방법을 보여줍니다. 이 경우 전체 기간 동안 살아있는 것은 아니지만, 누수 지점부터는 계속 살아있습니다."

#: src/scope/lifetime/static_lifetime.md:90
msgid "Trait bound"
msgstr "트레이트 바운드"

#: src/scope/lifetime/static_lifetime.md:92
msgid ""
"As a trait bound, it means the type does not contain any non-static "
"references. Eg. the receiver can hold on to the type for as long as they "
"want and it will never become invalid until they drop it."
msgstr "트레이트 바운드로서, 이는 해당 타입이 정적이지 않은(non-static) 참조를 포함하지 않음을 의미합니다. 예를 들어, 수신자는 원하는 만큼 해당 타입을 보유할 수 있으며, 드롭할 때까지 절대 유효하지 않게 되지 않습니다."

#: src/scope/lifetime/static_lifetime.md:96
msgid ""
"It's important to understand this means that any owned data always passes a "
"`'static` lifetime bound, but a reference to that owned data generally does "
"not:"
msgstr "이것이 의미하는 바를 이해하는 것이 중요합니다. 모든 소유된 데이터는 항상 `'static` 라이프타임 바운드를 통과하지만, 소유된 데이터에 대한 참조는 일반적으로 그렇지 않습니다:"

#: src/scope/lifetime/static_lifetime.md:104
msgid "\"'static value passed in is: {:?}\""
msgstr "\"'static 값이 전달되었습니다: {:?}\""

#: src/scope/lifetime/static_lifetime.md:108
msgid "// i is owned and contains no references, thus it's 'static:\n"
msgstr "// i는 소유된 데이터이며 참조를 포함하지 않으므로 'static입니다:\n"

#: src/scope/lifetime/static_lifetime.md:112
msgid ""
"// oops, &i only has the lifetime defined by the scope of\n"
"    // main(), so it's not 'static:\n"
msgstr ""
"// 이런, &i는 main()의 스코프에 의해 정의된 라이프타임만\n"
"// 가지므로 'static이 아닙니다:\n"

#: src/scope/lifetime/static_lifetime.md:118
msgid "The compiler will tell you:"
msgstr "컴파일러는 다음과 같이 알려줄 것입니다:"

#: src/scope/lifetime/static_lifetime.md:135
msgid "[`'static` constants](../../custom_types/constants.md)"
msgstr "[`'static` 상수](../../custom_types/constants.md)"

#: src/scope/lifetime/elision.md:3
msgid ""
"Some lifetime patterns are overwhelmingly common and so the borrow checker "
"will allow you to omit them to save typing and to improve readability. This "
"is known as elision. Elision exists in Rust solely because these patterns "
"are common."
msgstr "일부 라이프타임 패턴은 압도적으로 흔해서, 빌림 검사기는 타이핑을 줄이고 가독성을 높이기 위해 이를 생략할 수 있게 해줍니다. 이를 생략(elision)이라고 합니다. 생략은 오직 이러한 패턴이 흔하다는 이유만으로 Rust에 존재합니다."

#: src/scope/lifetime/elision.md:8
msgid ""
"The following code shows a few examples of elision. For a more comprehensive "
"description of elision, see [lifetime elision](https://doc.rust-lang.org/"
"book/ch10-03-lifetime-syntax.html#lifetime-elision) in the book."
msgstr "다음 코드는 생략의 몇 가지 예시를 보여줍니다. 생략에 대한 더 포괄적인 설명은 책의 [라이프타임 생략](https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision)을 참조하세요."

#: src/scope/lifetime/elision.md:12
msgid ""
"// `elided_input` and `annotated_input` essentially have identical "
"signatures\n"
"// because the lifetime of `elided_input` is inferred by the compiler:\n"
msgstr ""
"// `elided_input`과 `annotated_input`은 본질적으로 동일한 시그니처를 가집니다.\n"
"// `elided_input`의 라이프타임이 컴파일러에 의해 추론되기 때문입니다:\n"

#: src/scope/lifetime/elision.md:15
msgid "\"`elided_input`: {}\""
msgstr "\"`elided_input`: {}\""

#: src/scope/lifetime/elision.md:19
msgid "\"`annotated_input`: {}\""
msgstr "\"`annotated_input`: {}\""

#: src/scope/lifetime/elision.md:21
msgid ""
"// Similarly, `elided_pass` and `annotated_pass` have identical signatures\n"
"// because the lifetime is added implicitly to `elided_pass`:\n"
msgstr ""
"// 마찬가지로, `elided_pass`와 `annotated_pass`는 동일한 시그니처를 가집니다.\n"
"// 라이프타임이 `elided_pass`에 암시적으로 추가되기 때문입니다:\n"

#: src/scope/lifetime/elision.md:34
msgid "\"`elided_pass`: {}\""
msgstr "\"`elided_pass`: {}\""

#: src/scope/lifetime/elision.md:35
msgid "\"`annotated_pass`: {}\""
msgstr "\"`annotated_pass`: {}\""

#: src/scope/lifetime/elision.md:41
msgid ""
"[elision](https://doc.rust-lang.org/book/ch10-03-lifetime-"
"syntax.html#lifetime-elision)"
msgstr "[생략](https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision)"

#: src/trait.md:3
msgid ""
"A `trait` is a collection of methods defined for an unknown type: `Self`. "
"They can access other methods declared in the same trait."
msgstr "`trait`는 알 수 없는 타입 `Self`에 대해 정의된 메서드들의 모음입니다. 이들은 동일한 트레이트 내에 선언된 다른 메서드에 접근할 수 있습니다."

#: src/trait.md:6
msgid ""
"Traits can be implemented for any data type. In the example below, we define "
"`Animal`, a group of methods. The `Animal` `trait` is then implemented for "
"the `Sheep` data type, allowing the use of methods from `Animal` with a "
"`Sheep`."
msgstr "트레이트는 모든 데이터 타입에 대해 구현될 수 있습니다. 아래 예제에서는 메서드 그룹인 `Animal`을 정의합니다. 그런 다음 `Animal` `trait`를 `Sheep` 데이터 타입에 대해 구현하여 `Sheep`으로 `Animal`의 메서드를 사용할 수 있게 합니다."

#: src/trait.md:15
msgid ""
"// Associated function signature; `Self` refers to the implementor type.\n"
msgstr "// 연관 함수 시그니처; `Self`는 구현하는 타입을 가리킵니다.\n"

#: src/trait.md:18
msgid "// Method signatures; these will return a string.\n"
msgstr "// 메서드 시그니처; 이들은 문자열을 반환할 것입니다.\n"

#: src/trait.md:22
msgid "// Traits can provide default method definitions.\n"
msgstr "// 트레이트는 기본 메서드 정의를 제공할 수 있습니다.\n"

#: src/trait.md:24
msgid "\"{} says {}\""
msgstr "\"{}가 말하길 {}\""

#: src/trait.md:35
msgid "// Implementor methods can use the implementor's trait methods.\n"
msgstr "// 구현자의 메서드는 구현자의 트레이트 메서드를 사용할 수 있습니다.\n"

#: src/trait.md:36
msgid "\"{} is already naked...\""
msgstr "\"{}는 이미 벌거벗었습니다...\""

#: src/trait.md:38
msgid "\"{} gets a haircut!\""
msgstr "\"{}가 털을 깎습니다!\""

#: src/trait.md:44 src/trait/dyn.md:25
msgid "// Implement the `Animal` trait for `Sheep`.\n"
msgstr "// `Sheep`에 대해 `Animal` 트레이트를 구현합니다.\n"

#: src/trait.md:47
msgid "// `Self` is the implementor type: `Sheep`.\n"
msgstr "// `Self`는 구현하는 타입인 `Sheep`입니다.\n"

#: src/trait.md:58
msgid "\"baaaaah?\""
msgstr "\"메에에에?\""

#: src/trait.md:60 src/trait/dyn.md:29
msgid "\"baaaaah!\""
msgstr "\"메에에에!\""

#: src/trait.md:64
msgid "// Default trait methods can be overridden.\n"
msgstr "// 기본 트레이트 메서드는 재정의(오버라이드)될 수 있습니다.\n"

#: src/trait.md:66
msgid "// For example, we can add some quiet contemplation.\n"
msgstr "// 예를 들어, 조용한 사색을 추가할 수 있습니다.\n"

#: src/trait.md:67
msgid "\"{} pauses briefly... {}\""
msgstr "\"{}가 잠시 멈춥니다... {}\""

#: src/trait.md:72
msgid "// Type annotation is necessary in this case.\n"
msgstr "// 이 경우에는 타입 어노테이션이 필요합니다.\n"

#: src/trait.md:73
msgid "\"Dolly\""
msgstr "\"돌리\""

#: src/trait.md:74
msgid "// TODO ^ Try removing the type annotations.\n"
msgstr "// TODO ^ 타입 어노테이션을 제거해 보세요.\n"

#: src/trait/derive.md:3
msgid ""
"The compiler is capable of providing basic implementations for some traits "
"via the `#[derive]` [attribute](../attribute.md). These traits can still be "
"manually implemented if a more complex behavior is required."
msgstr ""

#: src/trait/derive.md:7
msgid "The following is a list of derivable traits:"
msgstr ""

#: src/trait/derive.md:9
msgid ""
"Comparison traits: [`Eq`](https://doc.rust-lang.org/std/cmp/trait.Eq.html), "
"[`PartialEq`](https://doc.rust-lang.org/std/cmp/trait.PartialEq.html), "
"[`Ord`](https://doc.rust-lang.org/std/cmp/trait.Ord.html), [`PartialOrd`]"
"(https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html)."
msgstr ""

#: src/trait/derive.md:11
msgid ""
"[`Clone`](https://doc.rust-lang.org/std/clone/trait.Clone.html), to create "
"`T` from `&T` via a copy."
msgstr ""

#: src/trait/derive.md:12
msgid ""
"[`Copy`](https://doc.rust-lang.org/core/marker/trait.Copy.html), to give a "
"type 'copy semantics' instead of 'move semantics'."
msgstr ""

#: src/trait/derive.md:13
msgid ""
"[`Hash`](https://doc.rust-lang.org/std/hash/trait.Hash.html), to compute a "
"hash from `&T`."
msgstr ""

#: src/trait/derive.md:14
msgid ""
"[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html), to "
"create an empty instance of a data type."
msgstr ""

#: src/trait/derive.md:15
msgid ""
"[`Debug`](https://doc.rust-lang.org/std/fmt/trait.Debug.html), to format a "
"value using the `{:?}` formatter."
msgstr ""

#: src/trait/derive.md:18
msgid "// `Centimeters`, a tuple struct that can be compared\n"
msgstr ""

#: src/trait/derive.md:21
msgid "// `Inches`, a tuple struct that can be printed\n"
msgstr ""

#: src/trait/derive.md:33
msgid "// `Seconds`, a tuple struct with no additional attributes\n"
msgstr ""

#: src/trait/derive.md:40
msgid ""
"// Error: `Seconds` can't be printed; it doesn't implement the `Debug` "
"trait\n"
"    //println!(\"One second looks like: {:?}\", _one_second);\n"
"    // TODO ^ Try uncommenting this line\n"
msgstr ""

#: src/trait/derive.md:44
msgid ""
"// Error: `Seconds` can't be compared; it doesn't implement the `PartialEq` "
"trait\n"
"    //let _this_is_true = (_one_second == _one_second);\n"
"    // TODO ^ Try uncommenting this line\n"
msgstr ""

#: src/trait/derive.md:50
msgid "\"One foot equals {:?}\""
msgstr ""

#: src/trait/derive.md:56
msgid "\"smaller\""
msgstr ""

#: src/trait/derive.md:58
msgid "\"bigger\""
msgstr ""

#: src/trait/derive.md:61
msgid "\"One foot is {} than one meter.\""
msgstr ""

#: src/trait/derive.md:67
msgid "[`derive`](https://doc.rust-lang.org/reference/attributes.html#derive)"
msgstr ""

#: src/trait/dyn.md:3
msgid ""
"The Rust compiler needs to know how much space every function's return type "
"requires. This means all your functions have to return a concrete type. "
"Unlike other languages, if you have a trait like `Animal`, you can't write a "
"function that returns `Animal`, because its different implementations will "
"need different amounts of memory."
msgstr ""

#: src/trait/dyn.md:8
msgid ""
"However, there's an easy workaround. Instead of returning a trait object "
"directly, our functions return a `Box` which _contains_ some `Animal`. A "
"`box` is just a reference to some memory in the heap. Because a reference "
"has a statically-known size, and the compiler can guarantee it points to a "
"heap-allocated `Animal`, we can return a trait from our function!"
msgstr ""

#: src/trait/dyn.md:13
msgid ""
"Rust tries to be as explicit as possible whenever it allocates memory on the "
"heap. So if your function returns a pointer-to-trait-on-heap in this way, "
"you need to write the return type with the `dyn` keyword, e.g. `Box<dyn "
"Animal>`."
msgstr ""

#: src/trait/dyn.md:22
msgid "// Instance method signature\n"
msgstr ""

#: src/trait/dyn.md:32
msgid "// Implement the `Animal` trait for `Cow`.\n"
msgstr ""

#: src/trait/dyn.md:36
msgid "\"moooooo!\""
msgstr ""

#: src/trait/dyn.md:39
msgid ""
"// Returns some struct that implements Animal, but we don't know which one "
"at compile time.\n"
msgstr ""

#: src/trait/dyn.md:52
msgid "\"You've randomly chosen an animal, and it says {}\""
msgstr ""

#: src/trait/ops.md:3
msgid ""
"In Rust, many of the operators can be overloaded via traits. That is, some "
"operators can be used to accomplish different tasks based on their input "
"arguments. This is possible because operators are syntactic sugar for method "
"calls. For example, the `+` operator in `a + b` calls the `add` method (as "
"in `a.add(b)`). This `add` method is part of the `Add` trait. Hence, the `+` "
"operator can be used by any implementor of the `Add` trait."
msgstr ""

#: src/trait/ops.md:9
msgid ""
"A list of the traits, such as `Add`, that overload operators can be found in "
"[`core::ops`](https://doc.rust-lang.org/core/ops/)."
msgstr ""

#: src/trait/ops.md:22
msgid ""
"// The `std::ops::Add` trait is used to specify the functionality of `+`.\n"
"// Here, we make `Add<Bar>` - the trait for addition with a RHS of type "
"`Bar`.\n"
"// The following block implements the operation: Foo + Bar = FooBar\n"
msgstr ""

#: src/trait/ops.md:30
msgid "\"> Foo.add(Bar) was called\""
msgstr ""

#: src/trait/ops.md:35
msgid ""
"// By reversing the types, we end up implementing non-commutative addition.\n"
"// Here, we make `Add<Foo>` - the trait for addition with a RHS of type "
"`Foo`.\n"
"// This block implements the operation: Bar + Foo = BarFoo\n"
msgstr ""

#: src/trait/ops.md:43
msgid "\"> Bar.add(Foo) was called\""
msgstr ""

#: src/trait/ops.md:50
msgid "\"Foo + Bar = {:?}\""
msgstr ""

#: src/trait/ops.md:51
msgid "\"Bar + Foo = {:?}\""
msgstr ""

#: src/trait/ops.md:55 src/testing.md:16 src/testing/doc_testing.md:105
#: src/testing/dev_dependencies.md:36
msgid "See Also"
msgstr ""

#: src/trait/ops.md:57
msgid ""
"[Add](https://doc.rust-lang.org/core/ops/trait.Add.html), [Syntax Index]"
"(https://doc.rust-lang.org/book/appendix-02-operators.html)"
msgstr ""

#: src/trait/drop.md:3
msgid ""
"The [`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html) trait only "
"has one method: `drop`, which is called automatically when an object goes "
"out of scope. The main use of the `Drop` trait is to free the resources that "
"the implementor instance owns."
msgstr ""

#: src/trait/drop.md:7
msgid ""
"`Box`, `Vec`, `String`, `File`, and `Process` are some examples of types "
"that implement the `Drop` trait to free resources. The `Drop` trait can also "
"be manually implemented for any custom data type."
msgstr ""

#: src/trait/drop.md:11
msgid ""
"The following example adds a print to console to the `drop` function to "
"announce when it is called."
msgstr ""

#: src/trait/drop.md:18
msgid "// This trivial implementation of `drop` adds a print to console.\n"
msgstr ""

#: src/trait/drop.md:22
msgid "\"> Dropping {}\""
msgstr ""

#: src/trait/drop.md:27 src/std_misc/path.md:33 src/std_misc/fs.md:44
#: src/std_misc/fs.md:87
msgid "\"a\""
msgstr ""

#: src/trait/drop.md:29
msgid "// block A\n"
msgstr ""

#: src/trait/drop.md:31 src/std_misc/path.md:33
msgid "\"b\""
msgstr ""

#: src/trait/drop.md:33
msgid "// block B\n"
msgstr ""

#: src/trait/drop.md:35 src/std_misc/path.md:36
msgid "\"c\""
msgstr ""

#: src/trait/drop.md:36
msgid "\"d\""
msgstr ""

#: src/trait/drop.md:38
msgid "\"Exiting block B\""
msgstr ""

#: src/trait/drop.md:40
msgid "\"Just exited block B\""
msgstr ""

#: src/trait/drop.md:42
msgid "\"Exiting block A\""
msgstr ""

#: src/trait/drop.md:44
msgid "\"Just exited block A\""
msgstr ""

#: src/trait/drop.md:46
msgid "// Variable can be manually dropped using the `drop` function\n"
msgstr ""

#: src/trait/drop.md:48
msgid "// TODO ^ Try commenting this line\n"
msgstr ""

#: src/trait/drop.md:50
msgid "\"end of the main function\""
msgstr ""

#: src/trait/drop.md:52
msgid ""
"// `_a` *won't* be `drop`ed again here, because it already has been\n"
"    // (manually) `drop`ed\n"
msgstr ""

#: src/trait/drop.md:57
msgid ""
"For a more practical example, here's how the `Drop` trait can be used to "
"automatically clean up temporary files when they're no longer needed:"
msgstr ""

#: src/trait/drop.md:71
msgid "// Note: File::create() will overwrite existing files\n"
msgstr ""

#: src/trait/drop.md:77
msgid ""
"// When TempFile is dropped:\n"
"// 1. First, our drop implementation will remove the file's name from the "
"filesystem.\n"
"// 2. Then, File's drop will close the file, removing its underlying content "
"from the disk.\n"
msgstr ""

#: src/trait/drop.md:84
msgid "\"Failed to remove temporary file: {}\""
msgstr ""

#: src/trait/drop.md:86
msgid "\"> Dropped temporary file: {:?}\""
msgstr ""

#: src/trait/drop.md:87
msgid ""
"// File's drop is implicitly called here because it is a field of this "
"struct.\n"
msgstr ""

#: src/trait/drop.md:92
msgid "// Create a new scope to demonstrate drop behavior\n"
msgstr ""

#: src/trait/drop.md:94
msgid "\"test.txt\""
msgstr ""

#: src/trait/drop.md:95
msgid "\"Temporary file created\""
msgstr ""

#: src/trait/drop.md:96
msgid "// File will be automatically cleaned up when temp goes out of scope\n"
msgstr ""

#: src/trait/drop.md:98
msgid "\"End of scope - file should be cleaned up\""
msgstr ""

#: src/trait/drop.md:100
msgid "// We can also manually drop if needed\n"
msgstr ""

#: src/trait/drop.md:101
msgid "\"another_test.txt\""
msgstr ""

#: src/trait/drop.md:102
msgid "// Explicitly drop the file\n"
msgstr ""

#: src/trait/drop.md:103
msgid "\"Manually dropped file\""
msgstr ""

#: src/trait/iter.md:3
msgid ""
"The [`Iterator`](https://doc.rust-lang.org/core/iter/trait.Iterator.html) "
"trait is used to implement iterators over collections such as arrays."
msgstr ""

#: src/trait/iter.md:6
msgid ""
"The trait requires only a method to be defined for the `next` element, which "
"may be manually defined in an `impl` block or automatically defined (as in "
"arrays and ranges)."
msgstr ""

#: src/trait/iter.md:10
msgid ""
"As a point of convenience for common situations, the `for` construct turns "
"some collections into iterators using the [`.into_iter()`](https://doc.rust-"
"lang.org/std/iter/trait.IntoIterator.html) method."
msgstr ""

#: src/trait/iter.md:18
msgid ""
"// Implement `Iterator` for `Fibonacci`.\n"
"// The `Iterator` trait only requires a method to be defined for the `next` "
"element,\n"
"// and an `associated type` to declare the return type of the iterator.\n"
msgstr ""

#: src/trait/iter.md:23
msgid "// We can refer to this type using Self::Item\n"
msgstr ""

#: src/trait/iter.md:26
msgid ""
"// Here, we define the sequence using `.curr` and `.next`.\n"
"    // The return type is `Option<T>`:\n"
"    //     * When the `Iterator` is finished, `None` is returned.\n"
"    //     * Otherwise, the next value is wrapped in `Some` and returned.\n"
"    // We use Self::Item in the return type, so we can change\n"
"    // the type without having to update the function signatures.\n"
msgstr ""

#: src/trait/iter.md:38
msgid ""
"// Since there's no endpoint to a Fibonacci sequence, the `Iterator`\n"
"        // will never return `None`, and `Some` is always returned.\n"
msgstr ""

#: src/trait/iter.md:43
msgid "// Returns a Fibonacci sequence generator\n"
msgstr ""

#: src/trait/iter.md:50
msgid "// `0..3` is an `Iterator` that generates: 0, 1, and 2.\n"
msgstr ""

#: src/trait/iter.md:53
msgid "\"Four consecutive `next` calls on 0..3\""
msgstr ""

#: src/trait/iter.md:54 src/trait/iter.md:55 src/trait/iter.md:56
#: src/trait/iter.md:57 src/std_misc/fs.md:90
msgid "\"> {:?}\""
msgstr ""

#: src/trait/iter.md:59
msgid ""
"// `for` works through an `Iterator` until it returns `None`.\n"
"    // Each `Some` value is unwrapped and bound to a variable (here, `i`).\n"
msgstr ""

#: src/trait/iter.md:61
msgid "\"Iterate through 0..3 using `for`\""
msgstr ""

#: src/trait/iter.md:63 src/trait/iter.md:69 src/trait/iter.md:75
#: src/trait/iter.md:83 src/std/vec.md:50 src/std/str.md:22
#: src/std_misc/fs.md:82
msgid "\"> {}\""
msgstr ""

#: src/trait/iter.md:66
msgid "// The `take(n)` method reduces an `Iterator` to its first `n` terms.\n"
msgstr ""

#: src/trait/iter.md:67
msgid "\"The first four terms of the Fibonacci sequence are: \""
msgstr ""

#: src/trait/iter.md:72
msgid ""
"// The `skip(n)` method shortens an `Iterator` by dropping its first `n` "
"terms.\n"
msgstr ""

#: src/trait/iter.md:73
msgid "\"The next four terms of the Fibonacci sequence are: \""
msgstr ""

#: src/trait/iter.md:80
msgid "// The `iter` method produces an `Iterator` over an array/slice.\n"
msgstr ""

#: src/trait/iter.md:81
msgid "\"Iterate the following array {:?}\""
msgstr ""

#: src/trait/impl_trait.md:3
msgid "`impl Trait` can be used in two locations:"
msgstr ""

#: src/trait/impl_trait.md:5
msgid "as an argument type"
msgstr ""

#: src/trait/impl_trait.md:6
msgid "as a return type"
msgstr ""

#: src/trait/impl_trait.md:8
msgid "As an argument type"
msgstr ""

#: src/trait/impl_trait.md:10
msgid ""
"If your function is generic over a trait but you don't mind the specific "
"type, you can simplify the function declaration using `impl Trait` as the "
"type of the argument."
msgstr ""

#: src/trait/impl_trait.md:12
msgid "For example, consider the following code:"
msgstr ""

#: src/trait/impl_trait.md:18 src/trait/impl_trait.md:37
msgid "// For each line in the source\n"
msgstr ""

#: src/trait/impl_trait.md:20 src/trait/impl_trait.md:39
msgid ""
"// If the line was read successfully, process it, if not, return the error\n"
msgstr ""

#: src/trait/impl_trait.md:21 src/trait/impl_trait.md:40 src/std/str.md:41
msgid "','"
msgstr ""

#: src/trait/impl_trait.md:21 src/trait/impl_trait.md:40
msgid "// Split the line separated by commas\n"
msgstr ""

#: src/trait/impl_trait.md:22 src/trait/impl_trait.md:41
msgid "// Remove leading and trailing whitespace\n"
msgstr ""

#: src/trait/impl_trait.md:23 src/trait/impl_trait.md:42
msgid "// Collect all strings in a row into a Vec<String>\n"
msgstr ""

#: src/trait/impl_trait.md:26 src/trait/impl_trait.md:45
msgid "// Collect all lines into a Vec<Vec<String>>\n"
msgstr ""

#: src/trait/impl_trait.md:30
msgid ""
"`parse_csv_document` is generic, allowing it to take any type which "
"implements BufRead, such as `BufReader<File>` or `[u8]`, but it's not "
"important what type `R` is, and `R` is only used to declare the type of "
"`src`, so the function can also be written as:"
msgstr ""

#: src/trait/impl_trait.md:49
msgid ""
"Note that using `impl Trait` as an argument type means that you cannot "
"explicitly state what form of the function you use, i.e. "
"`parse_csv_document::<std::io::Empty>(std::io::empty())` will not work with "
"the second example."
msgstr ""

#: src/trait/impl_trait.md:51
msgid "As a return type"
msgstr ""

#: src/trait/impl_trait.md:53
msgid ""
"If your function returns a type that implements `MyTrait`, you can write its "
"return type as `-> impl MyTrait`. This can help simplify your type "
"signatures quite a lot!"
msgstr ""

#: src/trait/impl_trait.md:59
msgid ""
"// This function combines two `Vec<i32>` and returns an iterator over it.\n"
"// Look how complicated its return type is!\n"
msgstr ""

#: src/trait/impl_trait.md:68
msgid ""
"// This is the exact same function, but its return type uses `impl Trait`.\n"
"// Look how much simpler it is!\n"
msgstr ""

#: src/trait/impl_trait.md:87
msgid "\"all done\""
msgstr ""

#: src/trait/impl_trait.md:91
msgid ""
"More importantly, some Rust types can't be written out. For example, every "
"closure has its own unnamed concrete type. Before `impl Trait` syntax, you "
"had to allocate on the heap in order to return a closure. But now you can do "
"it all statically, like this:"
msgstr ""

#: src/trait/impl_trait.md:97
msgid "// Returns a function that adds `y` to its input\n"
msgstr ""

#: src/trait/impl_trait.md:109
msgid ""
"You can also use `impl Trait` to return an iterator that uses `map` or "
"`filter` closures! This makes using `map` and `filter` easier. Because "
"closure types don't have names, you can't write out an explicit return type "
"if your function returns iterators with closures. But with `impl Trait` you "
"can do this easily:"
msgstr ""

#: src/trait/clone.md:3
msgid ""
"When dealing with resources, the default behavior is to transfer them during "
"assignments or function calls. However, sometimes we need to make a copy of "
"the resource as well."
msgstr ""

#: src/trait/clone.md:7
msgid ""
"The [`Clone`](https://doc.rust-lang.org/std/clone/trait.Clone.html) trait "
"helps us do exactly this. Most commonly, we can use the `.clone()` method "
"defined by the `Clone` trait."
msgstr ""

#: src/trait/clone.md:11
msgid "// A unit struct without resources\n"
msgstr ""

#: src/trait/clone.md:14
msgid "// A tuple struct with resources that implements the `Clone` trait\n"
msgstr ""

#: src/trait/clone.md:20
msgid "// Instantiate `Unit`\n"
msgstr ""

#: src/trait/clone.md:22
msgid "// Copy `Unit`, there are no resources to move\n"
msgstr ""

#: src/trait/clone.md:25
msgid "// Both `Unit`s can be used independently\n"
msgstr ""

#: src/trait/clone.md:26 src/trait/clone.md:31
msgid "\"original: {:?}\""
msgstr ""

#: src/trait/clone.md:27
msgid "\"copy: {:?}\""
msgstr ""

#: src/trait/clone.md:29
msgid "// Instantiate `Pair`\n"
msgstr ""

#: src/trait/clone.md:33
msgid "// Move `pair` into `moved_pair`, moves resources\n"
msgstr ""

#: src/trait/clone.md:35
msgid "\"moved: {:?}\""
msgstr ""

#: src/trait/clone.md:37
msgid ""
"// Error! `pair` has lost its resources\n"
"    //println!(\"original: {:?}\", pair);\n"
"    // TODO ^ Try uncommenting this line\n"
msgstr ""

#: src/trait/clone.md:41
msgid "// Clone `moved_pair` into `cloned_pair` (resources are included)\n"
msgstr ""

#: src/trait/clone.md:43
msgid "// Drop the moved original pair using std::mem::drop\n"
msgstr ""

#: src/trait/clone.md:46
msgid ""
"// Error! `moved_pair` has been dropped\n"
"    //println!(\"moved and dropped: {:?}\", moved_pair);\n"
"    // TODO ^ Try uncommenting this line\n"
msgstr ""

#: src/trait/clone.md:50
msgid "// The result from .clone() can still be used!\n"
msgstr ""

#: src/trait/clone.md:51
msgid "\"clone: {:?}\""
msgstr ""

#: src/trait/supertraits.md:3
msgid ""
"Rust doesn't have \"inheritance\", but you can define a trait as being a "
"superset of another trait. For example:"
msgstr ""

#: src/trait/supertraits.md:10
msgid ""
"// Person is a supertrait of Student.\n"
"// Implementing Student requires you to also impl Person.\n"
msgstr ""

#: src/trait/supertraits.md:20
msgid ""
"// CompSciStudent (computer science student) is a subtrait of both "
"Programmer\n"
"// and Student. Implementing CompSciStudent requires you to impl both "
"supertraits.\n"
msgstr ""

#: src/trait/supertraits.md:29
msgid ""
"\"My name is {} and I attend {}. My favorite language is {}. My Git username "
"is {}\""
msgstr ""

#: src/trait/supertraits.md:42
msgid ""
"[The Rust Programming Language chapter on supertraits](https://doc.rust-"
"lang.org/book/ch19-03-advanced-traits.html#using-supertraits-to-require-one-"
"traits-functionality-within-another-trait)"
msgstr ""

#: src/trait/disambiguating.md:3
msgid ""
"A type can implement many different traits. What if two traits both require "
"the same name for a function? For example, many traits might have a method "
"named `get()`. They might even have different return types!"
msgstr ""

#: src/trait/disambiguating.md:7
msgid ""
"Good news: because each trait implementation gets its own `impl` block, it's "
"clear which trait's `get` method you're implementing."
msgstr ""

#: src/trait/disambiguating.md:10
msgid ""
"What about when it comes time to _call_ those methods? To disambiguate "
"between them, we have to use Fully Qualified Syntax."
msgstr ""

#: src/trait/disambiguating.md:15
msgid "// Get the selected username out of this widget\n"
msgstr ""

#: src/trait/disambiguating.md:20
msgid "// Get the selected age out of this widget\n"
msgstr ""

#: src/trait/disambiguating.md:23
msgid "// A form with both a UsernameWidget and an AgeWidget\n"
msgstr ""

#: src/trait/disambiguating.md:44 src/trait/disambiguating.md:54
msgid "\"rustacean\""
msgstr ""

#: src/trait/disambiguating.md:48
msgid ""
"// If you uncomment this line, you'll get an error saying\n"
"    // \"multiple `get` found\". Because, after all, there are multiple "
"methods\n"
"    // named `get`.\n"
"    // println!(\"{}\", form.get());\n"
msgstr ""

#: src/trait/disambiguating.md:62
msgid ""
"[The Rust Programming Language chapter on Fully Qualified syntax](https://"
"doc.rust-lang.org/book/ch19-03-advanced-traits.html#fully-qualified-syntax-"
"for-disambiguation-calling-methods-with-the-same-name)"
msgstr ""

#: src/macros.md:1
msgid "`macro_rules!`"
msgstr ""

#: src/macros.md:3
msgid ""
"Rust provides a powerful macro system that allows metaprogramming. As you've "
"seen in previous chapters, macros look like functions, except that their "
"name ends with a bang `!`, but instead of generating a function call, macros "
"are expanded into source code that gets compiled with the rest of the "
"program. However, unlike macros in C and other languages, Rust macros are "
"expanded into abstract syntax trees, rather than string preprocessing, so "
"you don't get unexpected precedence bugs."
msgstr ""

#: src/macros.md:11
msgid "Macros are created using the `macro_rules!` macro."
msgstr ""

#: src/macros.md:14
msgid "// This is a simple macro named `say_hello`.\n"
msgstr ""

#: src/macros.md:16
msgid "// `()` indicates that the macro takes no argument.\n"
msgstr ""

#: src/macros.md:18
msgid "// The macro will expand into the contents of this block.\n"
msgstr ""

#: src/macros.md:19
msgid "\"Hello!\""
msgstr ""

#: src/macros.md:24
msgid "// This call will expand into `println!(\"Hello!\")`\n"
msgstr ""

#: src/macros.md:29
msgid "So why are macros useful?"
msgstr ""

#: src/macros.md:31
msgid ""
"Don't repeat yourself. There are many cases where you may need similar "
"functionality in multiple places but with different types. Often, writing a "
"macro is a useful way to avoid repeating code. (More on this later)"
msgstr ""

#: src/macros.md:35
msgid ""
"Domain-specific languages. Macros allow you to define special syntax for a "
"specific purpose. (More on this later)"
msgstr ""

#: src/macros.md:38
msgid ""
"Variadic interfaces. Sometimes you want to define an interface that takes a "
"variable number of arguments. An example is `println!` which could take any "
"number of arguments, depending on the format string. (More on this later)"
msgstr ""

#: src/macros/syntax.md:3
msgid ""
"In following subsections, we will show how to define macros in Rust. There "
"are three basic ideas:"
msgstr ""

#: src/macros/syntax.md:6
msgid "[Patterns and Designators](designators.md)"
msgstr ""

#: src/macros/syntax.md:7
msgid "[Overloading](overload.md)"
msgstr ""

#: src/macros/syntax.md:8
msgid "[Repetition](repeat.md)"
msgstr ""

#: src/macros/designators.md:3
msgid ""
"The arguments of a macro are prefixed by a dollar sign `$` and type "
"annotated with a _designator_:"
msgstr ""

#: src/macros/designators.md:8
msgid ""
"// This macro takes an argument of designator `ident` and\n"
"    // creates a function named `$func_name`.\n"
"    // The `ident` designator is used for variable/function names.\n"
msgstr ""

#: src/macros/designators.md:13
msgid "// The `stringify!` macro converts an `ident` into a string.\n"
msgstr ""

#: src/macros/designators.md:14
msgid "\"You called {:?}()\""
msgstr ""

#: src/macros/designators.md:19
msgid "// Create functions named `foo` and `bar` with the above macro.\n"
msgstr ""

#: src/macros/designators.md:25
msgid ""
"// This macro takes an expression of type `expr` and prints\n"
"    // it as a string along with its result.\n"
"    // The `expr` designator is used for expressions.\n"
msgstr ""

#: src/macros/designators.md:29
msgid "// `stringify!` will convert the expression *as it is* into a string.\n"
msgstr ""

#: src/macros/designators.md:30
msgid "\"{:?} = {:?}\""
msgstr ""

#: src/macros/designators.md:42
msgid "// Recall that blocks are expressions too!\n"
msgstr ""

#: src/macros/designators.md:51
msgid "These are some of the available designators:"
msgstr ""

#: src/macros/designators.md:53
msgid "`block`"
msgstr ""

#: src/macros/designators.md:54
msgid "`expr` is used for expressions"
msgstr ""

#: src/macros/designators.md:55
msgid "`ident` is used for variable/function names"
msgstr ""

#: src/macros/designators.md:56
msgid "`item`"
msgstr ""

#: src/macros/designators.md:57
msgid "`literal` is used for literal constants"
msgstr ""

#: src/macros/designators.md:58
msgid "`pat` (_pattern_)"
msgstr ""

#: src/macros/designators.md:59
msgid "`path`"
msgstr ""

#: src/macros/designators.md:60
msgid "`stmt` (_statement_)"
msgstr ""

#: src/macros/designators.md:61
msgid "`tt` (_token tree_)"
msgstr ""

#: src/macros/designators.md:62
msgid "`ty` (_type_)"
msgstr ""

#: src/macros/designators.md:63
msgid "`vis` (_visibility qualifier_)"
msgstr ""

#: src/macros/designators.md:65
msgid ""
"For a complete list, see the [Rust Reference](https://doc.rust-lang.org/"
"reference/macros-by-example.html)."
msgstr ""

#: src/macros/overload.md:3
msgid ""
"Macros can be overloaded to accept different combinations of arguments. In "
"that regard, `macro_rules!` can work similarly to a match block:"
msgstr ""

#: src/macros/overload.md:7
msgid ""
"// `test!` will compare `$left` and `$right`\n"
"// in different ways depending on how you invoke it:\n"
msgstr ""

#: src/macros/overload.md:10
msgid ""
"// Arguments don't need to be separated by a comma.\n"
"    // Any template can be used!\n"
msgstr ""

#: src/macros/overload.md:13
msgid "\"{:?} and {:?} is {:?}\""
msgstr ""

#: src/macros/overload.md:18
msgid "// ^ each arm must end with a semicolon.\n"
msgstr ""

#: src/macros/overload.md:20
msgid "\"{:?} or {:?} is {:?}\""
msgstr ""

#: src/macros/repeat.md:3
msgid ""
"Macros can use `+` in the argument list to indicate that an argument may "
"repeat at least once, or `*`, to indicate that the argument may repeat zero "
"or more times."
msgstr ""

#: src/macros/repeat.md:7
msgid ""
"In the following example, surrounding the matcher with `$(...),+` will match "
"one or more expression, separated by commas. Also note that the semicolon is "
"optional on the last case."
msgstr ""

#: src/macros/repeat.md:12
msgid "// `find_min!` will calculate the minimum of any number of arguments.\n"
msgstr ""

#: src/macros/repeat.md:14
msgid "// Base case:\n"
msgstr ""

#: src/macros/repeat.md:16
msgid "// `$x` followed by at least one `$y,`\n"
msgstr ""

#: src/macros/repeat.md:18
msgid "// Call `find_min!` on the tail `$y`\n"
msgstr ""

#: src/macros/dry.md:3
msgid ""
"Macros allow writing DRY code by factoring out the common parts of functions "
"and/or test suites. Here is an example that implements and tests the `+=`, "
"`*=` and `-=` operators on `Vec<T>`:"
msgstr ""

#: src/macros/dry.md:11
msgid ""
"// The `tt` (token tree) designator is used for\n"
"    // operators and tokens.\n"
msgstr ""

#: src/macros/dry.md:15
msgid "\"{:?}: dimension mismatch: {:?} {:?} {:?}\""
msgstr ""

#: src/macros/dry.md:30
msgid "// *x = x.$method(*y);\n"
msgstr ""

#: src/macros/dry.md:35
msgid "// Implement `add_assign`, `mul_assign`, and `sub_assign` functions.\n"
msgstr ""

#: src/macros/dry.md:60
msgid "// Test `add_assign`, `mul_assign`, and `sub_assign`.\n"
msgstr ""

#: src/macros/dsl.md:1
msgid "Domain Specific Languages (DSLs)"
msgstr ""

#: src/macros/dsl.md:3
msgid ""
"A DSL is a mini \"language\" embedded in a Rust macro. It is completely "
"valid Rust because the macro system expands into normal Rust constructs, but "
"it looks like a small language. This allows you to define concise or "
"intuitive syntax for some special functionality (within bounds)."
msgstr ""

#: src/macros/dsl.md:8
msgid ""
"Suppose that I want to define a little calculator API. I would like to "
"supply an expression and have the output printed to console."
msgstr ""

#: src/macros/dsl.md:15
msgid "// Force types to be unsigned integers\n"
msgstr ""

#: src/macros/dsl.md:16 src/macros/variadics.md:15
msgid "\"{} = {}\""
msgstr ""

#: src/macros/dsl.md:23
msgid "// hehehe `eval` is _not_ a Rust keyword!\n"
msgstr ""

#: src/macros/dsl.md:32 src/macros/variadics.md:35
msgid "Output:"
msgstr ""

#: src/macros/dsl.md:39
msgid ""
"This was a very simple example, but much more complex interfaces have been "
"developed, such as [`lazy_static`](https://crates.io/crates/lazy_static) or "
"[`clap`](https://crates.io/crates/clap)."
msgstr ""

#: src/macros/dsl.md:43
msgid ""
"Also, note the two pairs of braces in the macro. The outer ones are part of "
"the syntax of `macro_rules!`, in addition to `()` or `[]`."
msgstr ""

#: src/macros/variadics.md:1
msgid "Variadic Interfaces"
msgstr ""

#: src/macros/variadics.md:3
msgid ""
"A _variadic_ interface takes an arbitrary number of arguments. For example, "
"`println!` can take an arbitrary number of arguments, as determined by the "
"format string."
msgstr ""

#: src/macros/variadics.md:7
msgid ""
"We can extend our `calculate!` macro from the previous section to be "
"variadic:"
msgstr ""

#: src/macros/variadics.md:11
msgid "// The pattern for a single `eval`\n"
msgstr ""

#: src/macros/variadics.md:14
msgid "// Force types to be integers\n"
msgstr ""

#: src/macros/variadics.md:19
msgid "// Decompose multiple `eval`s recursively\n"
msgstr ""

#: src/macros/variadics.md:27
msgid "// Look ma! Variadic `calculate!`!\n"
msgstr ""

#: src/error.md:3
msgid ""
"Error handling is the process of handling the possibility of failure. For "
"example, failing to read a file and then continuing to use that _bad_ input "
"would clearly be problematic. Noticing and explicitly managing those errors "
"saves the rest of the program from various pitfalls."
msgstr ""

#: src/error.md:8
msgid ""
"There are various ways to deal with errors in Rust, which are described in "
"the following subchapters. They all have more or less subtle differences and "
"different use cases. As a rule of thumb:"
msgstr ""

#: src/error.md:12
msgid ""
"An explicit `panic` is mainly useful for tests and dealing with "
"unrecoverable errors. For prototyping it can be useful, for example when "
"dealing with functions that haven't been implemented yet, but in those cases "
"the more descriptive `unimplemented` is better. In tests `panic` is a "
"reasonable way to explicitly fail."
msgstr ""

#: src/error.md:17
msgid ""
"The `Option` type is for when a value is optional or when the lack of a "
"value is not an error condition. For example the parent of a directory - `/` "
"and `C:` don't have one. When dealing with `Option`s, `unwrap` is fine for "
"prototyping and cases where it's absolutely certain that there is guaranteed "
"to be a value. However `expect` is more useful since it lets you specify an "
"error message in case something goes wrong anyway."
msgstr ""

#: src/error.md:24
msgid ""
"When there is a chance that things do go wrong and the caller has to deal "
"with the problem, use `Result`. You can `unwrap` and `expect` them as well "
"(please don't do that unless it's a test or quick prototype)."
msgstr ""

#: src/error.md:28
msgid ""
"For a more rigorous discussion of error handling, refer to the error "
"handling section in the [official book](https://doc.rust-lang.org/book/"
"ch09-00-error-handling.html)."
msgstr ""

#: src/error/panic.md:3
msgid ""
"The simplest error handling mechanism we will see is `panic`. It prints an "
"error message, starts unwinding the stack, and usually exits the program. "
"Here, we explicitly call `panic` on our error condition:"
msgstr ""

#: src/error/panic.md:9
msgid "// You shouldn't drink too many sugary beverages.\n"
msgstr ""

#: src/error/panic.md:10 src/error/panic.md:17 src/error/abort_unwind.md:10
#: src/error/abort_unwind.md:23 src/error/abort_unwind.md:41
#: src/error/abort_unwind.md:50 src/error/option_unwrap.md:32
#: src/error/option_unwrap.md:43 src/error/option_unwrap.md:50
msgid "\"lemonade\""
msgstr ""

#: src/error/panic.md:10 src/error/option_unwrap.md:43
msgid "\"AAAaaaaa!!!!\""
msgstr ""

#: src/error/panic.md:12 src/error/abort_unwind.md:17
#: src/error/abort_unwind.md:44
msgid "\"Some refreshing {} is all I need.\""
msgstr ""

#: src/error/panic.md:16 src/error/abort_unwind.md:22
#: src/error/abort_unwind.md:49 src/error/option_unwrap.md:49
msgid "\"water\""
msgstr ""

#: src/error/panic.md:18
msgid "\"still water\""
msgstr ""

#: src/error/panic.md:22
msgid ""
"The first call to `drink` works. The second panics and thus the third is "
"never called."
msgstr ""

#: src/error/abort_unwind.md:1
msgid "`abort` and `unwind`"
msgstr ""

#: src/error/abort_unwind.md:3
msgid ""
"The previous section illustrates the error handling mechanism `panic`.  "
"Different code paths can be conditionally compiled based on the panic "
"setting. The current values available are `unwind` and `abort`."
msgstr ""

#: src/error/abort_unwind.md:5
msgid ""
"Building on the prior lemonade example, we explicitly use the panic strategy "
"to exercise different lines of code."
msgstr ""

#: src/error/abort_unwind.md:9
msgid "// You shouldn't drink too much sugary beverages.\n"
msgstr ""

#: src/error/abort_unwind.md:11
msgid "\"abort\""
msgstr ""

#: src/error/abort_unwind.md:12 src/error/abort_unwind.md:37
msgid "\"This is not your party. Run!!!!\""
msgstr ""

#: src/error/abort_unwind.md:14 src/error/abort_unwind.md:32
msgid "\"Spit it out!!!!\""
msgstr ""

#: src/error/abort_unwind.md:27
msgid ""
"Here is another example focusing on rewriting `drink()` and explicitly use "
"the `unwind` keyword."
msgstr ""

#: src/error/abort_unwind.md:30 src/error/abort_unwind.md:35
msgid "\"unwind\""
msgstr ""

#: src/error/abort_unwind.md:54
msgid ""
"The panic strategy can be set from the command line by using `abort` or "
"`unwind`."
msgstr ""

#: src/error/option_unwrap.md:3
msgid ""
"In the last example, we showed that we can induce program failure at will. "
"We told our program to `panic` if we drink a sugary lemonade. But what if we "
"expect _some_ drink but don't receive one? That case would be just as bad, "
"so it needs to be handled!"
msgstr ""

#: src/error/option_unwrap.md:8
msgid ""
"We _could_ test this against the null string (`\"\"`) as we do with a "
"lemonade. Since we're using Rust, let's instead have the compiler point out "
"cases where there's no drink."
msgstr ""

#: src/error/option_unwrap.md:12
msgid ""
"An `enum` called `Option<T>` in the `std` library is used when absence is a "
"possibility. It manifests itself as one of two \"options\":"
msgstr ""

#: src/error/option_unwrap.md:15
msgid "`Some(T)`: An element of type `T` was found"
msgstr ""

#: src/error/option_unwrap.md:16
msgid "`None`: No element was found"
msgstr ""

#: src/error/option_unwrap.md:18
msgid ""
"These cases can either be explicitly handled via `match` or implicitly with "
"`unwrap`. Implicit handling will either return the inner element or `panic`."
msgstr ""

#: src/error/option_unwrap.md:21
msgid ""
"Note that it's possible to manually customize `panic` with [expect](https://"
"doc.rust-lang.org/std/option/enum.Option.html#method.expect), but `unwrap` "
"otherwise leaves us with a less meaningful output than explicit handling. In "
"the following example, explicit handling yields a more controlled result "
"while retaining the option to `panic` if desired."
msgstr ""

#: src/error/option_unwrap.md:27
msgid ""
"// The adult has seen it all, and can handle any drink well.\n"
"// All drinks are handled explicitly using `match`.\n"
msgstr ""

#: src/error/option_unwrap.md:30
msgid "// Specify a course of action for each case.\n"
msgstr ""

#: src/error/option_unwrap.md:32
msgid "\"Yuck! Too sugary.\""
msgstr ""

#: src/error/option_unwrap.md:33
msgid "\"{}? How nice.\""
msgstr ""

#: src/error/option_unwrap.md:34
msgid "\"No drink? Oh well.\""
msgstr ""

#: src/error/option_unwrap.md:37
msgid ""
"// Others will `panic` before drinking sugary drinks.\n"
"// All drinks are handled implicitly using `unwrap`.\n"
msgstr ""

#: src/error/option_unwrap.md:41
msgid "// `unwrap` returns a `panic` when it receives a `None`.\n"
msgstr ""

#: src/error/option_unwrap.md:45
msgid "\"I love {}s!!!!!\""
msgstr ""

#: src/error/option_unwrap.md:57
msgid "\"coffee\""
msgstr ""

#: src/error/option_unwrap/question_mark.md:3
msgid ""
"You can unpack `Option`s by using `match` statements, but it's often easier "
"to use the `?` operator. If `x` is an `Option`, then evaluating `x?` will "
"return the underlying value if `x` is `Some`, otherwise it will terminate "
"whatever function is being executed and return `None`."
msgstr ""

#: src/error/option_unwrap/question_mark.md:10
msgid ""
"// If `current_age` is `None`, this returns `None`.\n"
"    // If `current_age` is `Some`, the inner `u8` value + 1\n"
"    // gets assigned to `next_age`\n"
msgstr ""

#: src/error/option_unwrap/question_mark.md:14
msgid "\"Next year I will be {}\""
msgstr ""

#: src/error/option_unwrap/question_mark.md:18
msgid "You can chain many `?`s together to make your code much more readable."
msgstr ""

#: src/error/option_unwrap/question_mark.md:38
msgid ""
"// Gets the area code of the phone number of the person's job, if it "
"exists.\n"
msgstr ""

#: src/error/option_unwrap/question_mark.md:40
msgid ""
"// This would need many nested `match` statements without the `?` operator.\n"
"        // It would take a lot more code - try writing it yourself and see "
"which\n"
"        // is easier.\n"
msgstr ""

#: src/error/option_unwrap/map.md:3
msgid ""
"`match` is a valid method for handling `Option`s. However, you may "
"eventually find heavy usage tedious, especially with operations only valid "
"with an input. In these cases, [combinators](https://doc.rust-lang.org/"
"reference/glossary.html#combinator) can be used to manage control flow in a "
"modular fashion."
msgstr ""

#: src/error/option_unwrap/map.md:8
msgid ""
"`Option` has a built in method called `map()`, a combinator for the simple "
"mapping of `Some -> Some` and `None -> None`. Multiple `map()` calls can be "
"chained together for even more flexibility."
msgstr ""

#: src/error/option_unwrap/map.md:12
msgid ""
"In the following example, `process()` replaces all functions previous to it "
"while staying compact."
msgstr ""

#: src/error/option_unwrap/map.md:23
msgid ""
"// Peeling food. If there isn't any, then return `None`.\n"
"// Otherwise, return the peeled food.\n"
msgstr ""

#: src/error/option_unwrap/map.md:32
msgid ""
"// Chopping food. If there isn't any, then return `None`.\n"
"// Otherwise, return the chopped food.\n"
msgstr ""

#: src/error/option_unwrap/map.md:41
msgid ""
"// Cooking food. Here, we showcase `map()` instead of `match` for case "
"handling.\n"
msgstr ""

#: src/error/option_unwrap/map.md:46
msgid ""
"// A function to peel, chop, and cook food all in sequence.\n"
"// We chain multiple uses of `map()` to simplify the code.\n"
msgstr ""

#: src/error/option_unwrap/map.md:54
msgid "// Check whether there's food or not before trying to eat it!\n"
msgstr ""

#: src/error/option_unwrap/map.md:58
msgid "\"Mmm. I love {:?}\""
msgstr ""

#: src/error/option_unwrap/map.md:59
msgid "\"Oh no! It wasn't edible.\""
msgstr ""

#: src/error/option_unwrap/map.md:70
msgid "// Let's try the simpler looking `process()` now.\n"
msgstr ""

#: src/error/option_unwrap/map.md:81
msgid ""
"[closures](../../fn/closures.md), [`Option`](https://doc.rust-lang.org/std/"
"option/enum.Option.html), [`Option::map()`](https://doc.rust-lang.org/std/"
"option/enum.Option.html#method.map)"
msgstr ""

#: src/error/option_unwrap/and_then.md:3
msgid ""
"`map()` was described as a chainable way to simplify `match` statements. "
"However, using `map()` on a function that returns an `Option<T>` results in "
"the nested `Option<Option<T>>`. Chaining multiple calls together can then "
"become confusing. That's where another combinator called `and_then()`, known "
"in some languages as flatmap, comes in."
msgstr ""

#: src/error/option_unwrap/and_then.md:9
msgid ""
"`and_then()` calls its function input with the wrapped value and returns the "
"result. If the `Option` is `None`, then it returns `None` instead."
msgstr ""

#: src/error/option_unwrap/and_then.md:11
msgid ""
"In the following example, `cookable_v3()` results in an `Option<Food>`. "
"Using `map()` instead of `and_then()` would have given an "
"`Option<Option<Food>>`, which is an invalid type for `eat()`."
msgstr ""

#: src/error/option_unwrap/and_then.md:20
msgid "// We don't have the ingredients to make Sushi.\n"
msgstr ""

#: src/error/option_unwrap/and_then.md:28
msgid "// We have the recipe for everything except Cordon Bleu.\n"
msgstr ""

#: src/error/option_unwrap/and_then.md:36
msgid ""
"// To make a dish, we need both the recipe and the ingredients.\n"
"// We can represent the logic with a chain of `match`es:\n"
msgstr ""

#: src/error/option_unwrap/and_then.md:45
msgid ""
"// This can conveniently be rewritten more compactly with `and_then()`:\n"
msgstr ""

#: src/error/option_unwrap/and_then.md:50
msgid ""
"// Otherwise we'd need to `flatten()` an `Option<Option<Food>>`\n"
"// to get an `Option<Food>`:\n"
msgstr ""

#: src/error/option_unwrap/and_then.md:59
msgid "\"Yay! On {:?} we get to eat {:?}.\""
msgstr ""

#: src/error/option_unwrap/and_then.md:60
msgid "\"Oh no. We don't get to eat on {:?}?\""
msgstr ""

#: src/error/option_unwrap/and_then.md:75
msgid ""
"[closures](../../fn/closures.md), [`Option`](https://doc.rust-lang.org/std/"
"option/enum.Option.html), [`Option::and_then()`](https://doc.rust-lang.org/"
"std/option/enum.Option.html#method.and_then), and [`Option::flatten()`]"
"(https://doc.rust-lang.org/std/option/enum.Option.html#method.flatten)"
msgstr ""

#: src/error/option_unwrap/defaults.md:1
msgid "Unpacking options and defaults"
msgstr ""

#: src/error/option_unwrap/defaults.md:3
msgid ""
"There is more than one way to unpack an `Option` and fall back on a default "
"if it is `None`. To choose the one that meets our needs, we need to consider "
"the following:"
msgstr ""

#: src/error/option_unwrap/defaults.md:5
msgid "do we need eager or lazy evaluation?"
msgstr ""

#: src/error/option_unwrap/defaults.md:6
msgid ""
"do we need to keep the original empty value intact, or modify it in place?"
msgstr ""

#: src/error/option_unwrap/defaults.md:8
msgid "`or()` is chainable, evaluates eagerly, keeps empty value intact"
msgstr ""

#: src/error/option_unwrap/defaults.md:10
msgid ""
"`or()`is chainable and eagerly evaluates its argument, as is shown in the "
"following example. Note that because `or`'s arguments are evaluated eagerly, "
"the variable passed to `or` is moved."
msgstr ""

#: src/error/option_unwrap/defaults.md:22
#: src/error/option_unwrap/defaults.md:55
msgid "\"first_available_fruit: {:?}\""
msgstr ""

#: src/error/option_unwrap/defaults.md:23
msgid "// first_available_fruit: Some(Orange)\n"
msgstr ""

#: src/error/option_unwrap/defaults.md:25
msgid ""
"// `or` moves its argument.\n"
"    // In the example above, `or(orange)` returned a `Some`, so `or(apple)` "
"was not invoked.\n"
"    // But the variable named `apple` has been moved regardless, and cannot "
"be used anymore.\n"
"    // println!(\"Variable apple was moved, so this line won't compile: {:?}"
"\", apple);\n"
"    // TODO: uncomment the line above to see the compiler error\n"
msgstr ""

#: src/error/option_unwrap/defaults.md:33
msgid "`or_else()` is chainable, evaluates lazily, keeps empty value intact"
msgstr ""

#: src/error/option_unwrap/defaults.md:35
msgid ""
"Another alternative is to use `or_else`, which is also chainable, and "
"evaluates lazily, as is shown in the following example:"
msgstr ""

#: src/error/option_unwrap/defaults.md:44
msgid "\"Providing kiwi as fallback\""
msgstr ""

#: src/error/option_unwrap/defaults.md:48
#: src/error/option_unwrap/defaults.md:93
msgid "\"Providing lemon as fallback\""
msgstr ""

#: src/error/option_unwrap/defaults.md:56
msgid ""
"// Providing kiwi as fallback\n"
"    // first_available_fruit: Some(Kiwi)\n"
msgstr ""

#: src/error/option_unwrap/defaults.md:61
msgid "`get_or_insert()` evaluates eagerly, modifies empty value in place"
msgstr ""

#: src/error/option_unwrap/defaults.md:63
msgid ""
"To make sure that an `Option` contains a value, we can use `get_or_insert` "
"to modify it in place with a fallback value, as is shown in the following "
"example. Note that `get_or_insert` eagerly evaluates its parameter, so "
"variable `apple` is moved:"
msgstr ""

#: src/error/option_unwrap/defaults.md:73
#: src/error/option_unwrap/defaults.md:98
msgid "\"first_available_fruit is: {:?}\""
msgstr ""

#: src/error/option_unwrap/defaults.md:74
#: src/error/option_unwrap/defaults.md:99
msgid "\"my_fruit is: {:?}\""
msgstr ""

#: src/error/option_unwrap/defaults.md:75
msgid ""
"// first_available_fruit is: Apple\n"
"    // my_fruit is: Some(Apple)\n"
"    //println!(\"Variable named `apple` is moved: {:?}\", apple);\n"
"    // TODO: uncomment the line above to see the compiler error\n"
msgstr ""

#: src/error/option_unwrap/defaults.md:82
msgid "`get_or_insert_with()` evaluates lazily, modifies empty value in place"
msgstr ""

#: src/error/option_unwrap/defaults.md:84
msgid ""
"Instead of explicitly providing a value to fall back on, we can pass a "
"closure to `get_or_insert_with`, as follows:"
msgstr ""

#: src/error/option_unwrap/defaults.md:100
msgid ""
"// Providing lemon as fallback\n"
"    // first_available_fruit is: Lemon\n"
"    // my_fruit is: Some(Lemon)\n"
msgstr ""

#: src/error/option_unwrap/defaults.md:104
msgid ""
"// If the Option has a value, it is left unchanged, and the closure is not "
"invoked\n"
msgstr ""

#: src/error/option_unwrap/defaults.md:107
msgid "\"should_be_apple is: {:?}\""
msgstr ""

#: src/error/option_unwrap/defaults.md:108
msgid "\"my_apple is unchanged: {:?}\""
msgstr ""

#: src/error/option_unwrap/defaults.md:109
msgid ""
"// The output is a follows. Note that the closure `get_lemon_as_fallback` is "
"not invoked\n"
"    // should_be_apple is: Apple\n"
"    // my_apple is unchanged: Some(Apple)\n"
msgstr ""

#: src/error/option_unwrap/defaults.md:117
msgid ""
"[`closures`](https://doc.rust-lang.org/book/ch13-01-closures.html), "
"[`get_or_insert`](https://doc.rust-lang.org/core/option/"
"enum.Option.html#method.get_or_insert), [`get_or_insert_with`](https://"
"doc.rust-lang.org/core/option/enum.Option.html#method.get_or_insert_with), "
"[`moved variables`](https://doc.rust-lang.org/book/ch04-02-references-and-"
"borrowing.html), [`or`](https://doc.rust-lang.org/core/option/"
"enum.Option.html#method.or), [`or_else`](https://doc.rust-lang.org/core/"
"option/enum.Option.html#method.or_else)"
msgstr ""

#: src/error/result.md:3
msgid ""
"[`Result`](https://doc.rust-lang.org/std/result/enum.Result.html) is a "
"richer version of the [`Option`](https://doc.rust-lang.org/std/option/"
"enum.Option.html) type that describes possible _error_ instead of possible "
"_absence_."
msgstr ""

#: src/error/result.md:6
msgid "That is, `Result<T, E>` could have one of two outcomes:"
msgstr ""

#: src/error/result.md:8
msgid "`Ok(T)`: An element `T` was found"
msgstr ""

#: src/error/result.md:9
msgid "`Err(E)`: An error was found with element `E`"
msgstr ""

#: src/error/result.md:11
msgid ""
"By convention, the expected outcome is `Ok` while the unexpected outcome is "
"`Err`."
msgstr ""

#: src/error/result.md:13
msgid ""
"Like `Option`, `Result` has many methods associated with it. `unwrap()`, for "
"example, either yields the element `T` or `panic`s. For case handling, there "
"are many combinators between `Result` and `Option` that overlap."
msgstr ""

#: src/error/result.md:17
msgid ""
"In working with Rust, you will likely encounter methods that return the "
"`Result` type, such as the [`parse()`](https://doc.rust-lang.org/std/"
"primitive.str.html#method.parse) method. It might not always be possible to "
"parse a string into the other type, so `parse()` returns a `Result` "
"indicating possible failure."
msgstr ""

#: src/error/result.md:22
msgid ""
"Let's see what happens when we successfully and unsuccessfully `parse()` a "
"string:"
msgstr ""

#: src/error/result.md:26
msgid "// Let's try using `unwrap()` to get the number out. Will it bite us?\n"
msgstr ""

#: src/error/result.md:33 src/error/result.md:36
#: src/error/result/result_map.md:42 src/error/result/result_map.md:46
#: src/error/result/result_map.md:75 src/error/result/result_map.md:79
#: src/error/result/result_alias.md:36 src/error/result/result_alias.md:37
#: src/error/result/early_returns.md:36 src/error/result/early_returns.md:37
#: src/error/result/enter_question_mark.md:34
#: src/error/result/enter_question_mark.md:35
#: src/error/result/enter_question_mark.md:67
#: src/error/result/enter_question_mark.md:68
msgid "\"2\""
msgstr ""

#: src/error/result.md:34 src/error/result.md:37
msgid "\"double is {}\""
msgstr ""

#: src/error/result.md:36 src/error/result/result_map.md:46
#: src/error/result/result_map.md:79 src/error/result/result_alias.md:37
#: src/error/result/early_returns.md:37
#: src/error/result/enter_question_mark.md:35
#: src/error/result/enter_question_mark.md:68
msgid "\"t\""
msgstr ""

#: src/error/result.md:41
msgid ""
"In the unsuccessful case, `parse()` leaves us with an error for `unwrap()` "
"to `panic` on. Additionally, the `panic` exits our program and provides an "
"unpleasant error message."
msgstr ""

#: src/error/result.md:45
msgid ""
"To improve the quality of our error message, we should be more specific "
"about the return type and consider explicitly handling the error."
msgstr ""

#: src/error/result.md:48
msgid "Using `Result` in `main`"
msgstr ""

#: src/error/result.md:50
msgid ""
"The `Result` type can also be the return type of the `main` function if "
"specified explicitly. Typically the `main` function will be of the form:"
msgstr ""

#: src/error/result.md:59
msgid ""
"However `main` is also able to have a return type of `Result`. If an error "
"occurs within the `main` function it will return an error code and print a "
"debug representation of the error (using the [`Debug`](https://doc.rust-"
"lang.org/std/fmt/trait.Debug.html) trait). The following example shows such "
"a scenario and touches on aspects covered in [the following section](result/"
"early_returns.md)."
msgstr ""

#: src/error/result/result_map.md:3
msgid ""
"Panicking in the previous example's `multiply` does not make for robust "
"code. Generally, we want to return the error to the caller so it can decide "
"what is the right way to respond to errors."
msgstr ""

#: src/error/result/result_map.md:7
msgid ""
"We first need to know what kind of error type we are dealing with. To "
"determine the `Err` type, we look to [`parse()`](https://doc.rust-lang.org/"
"std/primitive.str.html#method.parse), which is implemented with the "
"[`FromStr`](https://doc.rust-lang.org/std/str/trait.FromStr.html) trait for "
"[`i32`](https://doc.rust-lang.org/std/primitive.i32.html). As a result, the "
"`Err` type is specified as [`ParseIntError`](https://doc.rust-lang.org/std/"
"num/struct.ParseIntError.html)."
msgstr ""

#: src/error/result/result_map.md:12
msgid ""
"In the example below, the straightforward `match` statement leads to code "
"that is overall more cumbersome."
msgstr ""

#: src/error/result/result_map.md:17
msgid ""
"// With the return type rewritten, we use pattern matching without "
"`unwrap()`.\n"
msgstr ""

#: src/error/result/result_map.md:35 src/error/result/result_map.md:68
#: src/error/result/result_alias.md:30 src/error/result/early_returns.md:30
#: src/error/result/enter_question_mark.md:28
#: src/error/result/enter_question_mark.md:61
msgid "\"n is {}\""
msgstr ""

#: src/error/result/result_map.md:36 src/error/result/result_map.md:69
#: src/error/result/result_alias.md:31 src/error/result/early_returns.md:31
#: src/error/result/enter_question_mark.md:29
#: src/error/result/enter_question_mark.md:62
#: src/error/multiple_error_types/define_error_type.md:55
#: src/error/multiple_error_types/boxing_errors.md:42
#: src/error/multiple_error_types/reenter_question_mark.md:54
#: src/error/multiple_error_types/wrap_error.md:68
msgid "\"Error: {}\""
msgstr ""

#: src/error/result/result_map.md:41 src/error/result/result_map.md:74
msgid "// This still presents a reasonable answer.\n"
msgstr ""

#: src/error/result/result_map.md:45 src/error/result/result_map.md:78
msgid "// The following now provides a much more helpful error message.\n"
msgstr ""

#: src/error/result/result_map.md:51
msgid ""
"Luckily, `Option`'s `map`, `and_then`, and many other combinators are also "
"implemented for `Result`. [`Result`](https://doc.rust-lang.org/std/result/"
"enum.Result.html) contains a complete listing."
msgstr ""

#: src/error/result/result_map.md:56
msgid ""
"// As with `Option`, we can use combinators such as `map()`.\n"
"// This function is otherwise identical to the one above and reads:\n"
"// Multiply if both values can be parsed from str, otherwise pass on the "
"error.\n"
msgstr ""

#: src/error/result/result_alias.md:3
msgid ""
"How about when we want to reuse a specific `Result` type many times? Recall "
"that Rust allows us to create [aliases](../../types/alias.md). Conveniently, "
"we can define one for the specific `Result` in question."
msgstr ""

#: src/error/result/result_alias.md:7
msgid ""
"At a module level, creating aliases can be particularly helpful. Errors "
"found in a specific module often have the same `Err` type, so a single alias "
"can succinctly define _all_ associated `Results`. This is so useful that the "
"`std` library even supplies one: [`io::Result`](https://doc.rust-lang.org/"
"std/io/type.Result.html)!"
msgstr ""

#: src/error/result/result_alias.md:12
msgid "Here's a quick example to show off the syntax:"
msgstr ""

#: src/error/result/result_alias.md:16
msgid ""
"// Define a generic alias for a `Result` with the error type "
"`ParseIntError`.\n"
msgstr ""

#: src/error/result/result_alias.md:19
msgid "// Use the above alias to refer to our specific `Result` type.\n"
msgstr ""

#: src/error/result/result_alias.md:26
msgid "// Here, the alias again allows us to save some space.\n"
msgstr ""

#: src/error/result/result_alias.md:43
msgid "[`io::Result`](https://doc.rust-lang.org/std/io/type.Result.html)"
msgstr ""

#: src/error/result/early_returns.md:3
msgid ""
"In the previous example, we explicitly handled the errors using combinators. "
"Another way to deal with this case analysis is to use a combination of "
"`match` statements and _early returns_."
msgstr ""

#: src/error/result/early_returns.md:7
msgid ""
"That is, we can simply stop executing the function and return the error if "
"one occurs. For some, this form of code can be easier to both read and "
"write. Consider this version of the previous example, rewritten using early "
"returns:"
msgstr ""

#: src/error/result/early_returns.md:41
msgid ""
"At this point, we've learned to explicitly handle errors using combinators "
"and early returns. While we generally want to avoid panicking, explicitly "
"handling all of our errors is cumbersome."
msgstr ""

#: src/error/result/early_returns.md:45
msgid ""
"In the next section, we'll introduce `?` for the cases where we simply need "
"to `unwrap` without possibly inducing `panic`."
msgstr ""

#: src/error/result/enter_question_mark.md:3
msgid ""
"Sometimes we just want the simplicity of `unwrap` without the possibility of "
"a `panic`. Until now, `unwrap` has forced us to nest deeper and deeper when "
"what we really wanted was to get the variable _out_. This is exactly the "
"purpose of `?`."
msgstr ""

#: src/error/result/enter_question_mark.md:7
msgid "Upon finding an `Err`, there are two valid actions to take:"
msgstr ""

#: src/error/result/enter_question_mark.md:9
msgid "`panic!` which we already decided to try to avoid if possible"
msgstr ""

#: src/error/result/enter_question_mark.md:10
msgid "`return` because an `Err` means it cannot be handled"
msgstr ""

#: src/error/result/enter_question_mark.md:12
msgid ""
"`?` is _almost_[^†] exactly equivalent to an `unwrap` which `return`s "
"instead of `panic`king on `Err`s. Let's see how we can simplify the earlier "
"example that used combinators:"
msgstr ""

#: src/error/result/enter_question_mark.md:39
msgid "The `try!` macro"
msgstr ""

#: src/error/result/enter_question_mark.md:41
msgid ""
"Before there was `?`, the same functionality was achieved with the `try!` "
"macro. The `?` operator is now recommended, but you may still find `try!` "
"when looking at older code. The same `multiply` function from the previous "
"example would look like this using `try!`:"
msgstr ""

#: src/error/result/enter_question_mark.md:47
msgid ""
"// To compile and run this example without errors, while using Cargo, change "
"the value\n"
"// of the `edition` field, in the `[package]` section of the `Cargo.toml` "
"file, to \"2015\".\n"
msgstr ""

#: src/error/result/enter_question_mark.md:72
msgid ""
"See [re-enter ?](../multiple_error_types/reenter_question_mark.md) for more "
"details."
msgstr ""

#: src/error/multiple_error_types.md:3
msgid ""
"The previous examples have always been very convenient; `Result`s interact "
"with other `Result`s and `Option`s interact with other `Option`s."
msgstr ""

#: src/error/multiple_error_types.md:6
msgid ""
"Sometimes an `Option` needs to interact with a `Result`, or a `Result<T, "
"Error1>` needs to interact with a `Result<T, Error2>`. In those cases, we "
"want to manage our different error types in a way that makes them composable "
"and easy to interact with."
msgstr ""

#: src/error/multiple_error_types.md:11
msgid ""
"In the following code, two instances of `unwrap` generate different error "
"types. `Vec::first` returns an `Option`, while `parse::<i32>` returns a "
"`Result<i32, ParseIntError>`:"
msgstr ""

#: src/error/multiple_error_types.md:17
msgid "// Generate error 1\n"
msgstr ""

#: src/error/multiple_error_types.md:18
msgid "// Generate error 2\n"
msgstr ""

#: src/error/multiple_error_types.md:22
#: src/error/multiple_error_types/option_result.md:16
#: src/error/multiple_error_types/option_result.md:45
#: src/error/multiple_error_types/define_error_type.md:60
#: src/error/multiple_error_types/boxing_errors.md:47
#: src/error/multiple_error_types/reenter_question_mark.md:59
#: src/error/multiple_error_types/wrap_error.md:77 src/error/iter_result.md:40
msgid "\"42\""
msgstr ""

#: src/error/multiple_error_types.md:22 src/error/multiple_error_types.md:24
#: src/error/multiple_error_types/option_result.md:16
#: src/error/multiple_error_types/option_result.md:18
#: src/error/multiple_error_types/option_result.md:45
#: src/error/multiple_error_types/option_result.md:47
#: src/error/multiple_error_types/define_error_type.md:60
#: src/error/multiple_error_types/define_error_type.md:62
#: src/error/multiple_error_types/boxing_errors.md:47
#: src/error/multiple_error_types/boxing_errors.md:49
#: src/error/multiple_error_types/reenter_question_mark.md:59
#: src/error/multiple_error_types/reenter_question_mark.md:61
#: src/error/multiple_error_types/wrap_error.md:77
#: src/error/multiple_error_types/wrap_error.md:79 src/error/iter_result.md:7
#: src/error/iter_result.md:24 src/error/iter_result.md:40
#: src/error/iter_result.md:60 src/error/iter_result.md:75
#: src/error/iter_result.md:90
msgid "\"93\""
msgstr ""

#: src/error/multiple_error_types.md:22 src/error/multiple_error_types.md:24
#: src/error/multiple_error_types/option_result.md:16
#: src/error/multiple_error_types/option_result.md:18
#: src/error/multiple_error_types/option_result.md:45
#: src/error/multiple_error_types/option_result.md:47
#: src/error/multiple_error_types/define_error_type.md:60
#: src/error/multiple_error_types/define_error_type.md:62
#: src/error/multiple_error_types/boxing_errors.md:47
#: src/error/multiple_error_types/boxing_errors.md:49
#: src/error/multiple_error_types/reenter_question_mark.md:59
#: src/error/multiple_error_types/reenter_question_mark.md:61
#: src/error/multiple_error_types/wrap_error.md:77
#: src/error/multiple_error_types/wrap_error.md:79 src/error/iter_result.md:7
#: src/error/iter_result.md:24 src/error/iter_result.md:40
#: src/error/iter_result.md:60 src/error/iter_result.md:75
#: src/error/iter_result.md:90
msgid "\"18\""
msgstr ""

#: src/error/multiple_error_types.md:24
#: src/error/multiple_error_types/option_result.md:18
#: src/error/multiple_error_types/option_result.md:47
#: src/error/multiple_error_types/define_error_type.md:62
#: src/error/multiple_error_types/boxing_errors.md:49
#: src/error/multiple_error_types/reenter_question_mark.md:61
#: src/error/multiple_error_types/wrap_error.md:79 src/error/iter_result.md:7
#: src/error/iter_result.md:24 src/error/iter_result.md:40
#: src/error/iter_result.md:60 src/error/iter_result.md:75
#: src/error/iter_result.md:90
msgid "\"tofu\""
msgstr ""

#: src/error/multiple_error_types.md:26 src/error/multiple_error_types.md:28
#: src/error/multiple_error_types.md:31
#: src/error/multiple_error_types/define_error_type.md:54
#: src/error/multiple_error_types/boxing_errors.md:41
#: src/error/multiple_error_types/reenter_question_mark.md:53
#: src/error/multiple_error_types/wrap_error.md:66
msgid "\"The first doubled is {}\""
msgstr ""

#: src/error/multiple_error_types.md:29
#: src/error/multiple_error_types/option_result.md:23
msgid "// Error 1: the input vector is empty\n"
msgstr ""

#: src/error/multiple_error_types.md:32
#: src/error/multiple_error_types/option_result.md:26
msgid "// Error 2: the element doesn't parse to a number\n"
msgstr ""

#: src/error/multiple_error_types.md:36
msgid ""
"Over the next sections, we'll see several strategies for handling these kind "
"of problems."
msgstr ""

#: src/error/multiple_error_types/option_result.md:3
msgid ""
"The most basic way of handling mixed error types is to just embed them in "
"each other."
msgstr ""

#: src/error/multiple_error_types/option_result.md:20
#: src/error/multiple_error_types/option_result.md:22
#: src/error/multiple_error_types/option_result.md:25
#: src/error/multiple_error_types/option_result.md:49
#: src/error/multiple_error_types/option_result.md:50
#: src/error/multiple_error_types/option_result.md:51
msgid "\"The first doubled is {:?}\""
msgstr ""

#: src/error/multiple_error_types/option_result.md:30
msgid ""
"There are times when we'll want to stop processing on errors (like with [`?`]"
"(../result/enter_question_mark.md)) but keep going when the `Option` is "
"`None`. The `transpose` function comes in handy to swap the `Result` and "
"`Option`."
msgstr ""

#: src/error/multiple_error_types/define_error_type.md:3
msgid ""
"Sometimes it simplifies the code to mask all of the different errors with a "
"single type of error.  We'll show this with a custom error."
msgstr ""

#: src/error/multiple_error_types/define_error_type.md:6
msgid ""
"Rust allows us to define our own error types. In general, a \"good\" error "
"type:"
msgstr ""

#: src/error/multiple_error_types/define_error_type.md:8
msgid "Represents different errors with the same type"
msgstr ""

#: src/error/multiple_error_types/define_error_type.md:9
msgid "Presents nice error messages to the user"
msgstr ""

#: src/error/multiple_error_types/define_error_type.md:10
msgid "Is easy to compare with other types"
msgstr ""

#: src/error/multiple_error_types/define_error_type.md:11
msgid "Good: `Err(EmptyVec)`"
msgstr ""

#: src/error/multiple_error_types/define_error_type.md:12
msgid ""
"Bad: `Err(\"Please use a vector with at least one element\".to_owned())`"
msgstr ""

#: src/error/multiple_error_types/define_error_type.md:13
msgid "Can hold information about the error"
msgstr ""

#: src/error/multiple_error_types/define_error_type.md:14
msgid "Good: `Err(BadChar(c, position))`"
msgstr ""

#: src/error/multiple_error_types/define_error_type.md:15
msgid "Bad: `Err(\"+ cannot be used here\".to_owned())`"
msgstr ""

#: src/error/multiple_error_types/define_error_type.md:16
msgid "Composes well with other errors"
msgstr ""

#: src/error/multiple_error_types/define_error_type.md:22
msgid ""
"// Define our error types. These may be customized for our error handling "
"cases.\n"
"// Now we will be able to write our own errors, defer to an underlying "
"error\n"
"// implementation, or do something in between.\n"
msgstr ""

#: src/error/multiple_error_types/define_error_type.md:28
msgid ""
"// Generation of an error is completely separate from how it is displayed.\n"
"// There's no need to be concerned about cluttering complex logic with the "
"display style.\n"
"//\n"
"// Note that we don't store any extra info about the errors. This means we "
"can't state\n"
"// which string failed to parse without modifying our types to carry that "
"information.\n"
msgstr ""

#: src/error/multiple_error_types/define_error_type.md:36
#: src/error/multiple_error_types/boxing_errors.md:23
#: src/error/multiple_error_types/reenter_question_mark.md:37
msgid "\"invalid first item to double\""
msgstr ""

#: src/error/multiple_error_types/define_error_type.md:42
msgid "// Change the error to our new type.\n"
msgstr ""

#: src/error/multiple_error_types/define_error_type.md:46
msgid "// Update to the new error type here also.\n"
msgstr ""

#: src/error/multiple_error_types/boxing_errors.md:3
msgid ""
"A way to write simple code while preserving the original errors is to [`Box`]"
"(https://doc.rust-lang.org/std/boxed/struct.Box.html) them.  The drawback is "
"that the underlying error type is only known at runtime and not [statically "
"determined](https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-"
"objects-perform-dynamic-dispatch)."
msgstr ""

#: src/error/multiple_error_types/boxing_errors.md:7
msgid ""
"The stdlib helps in boxing our errors by having `Box` implement conversion "
"from any type that implements the `Error` trait into the trait object "
"`Box<Error>`, via [`From`](https://doc.rust-lang.org/std/convert/"
"trait.From.html)."
msgstr ""

#: src/error/multiple_error_types/boxing_errors.md:14
#: src/error/multiple_error_types/reenter_question_mark.md:28
msgid "// Change the alias to use `Box<dyn error::Error>`.\n"
msgstr ""

#: src/error/multiple_error_types/boxing_errors.md:31
msgid "// Converts to Box using Into trait.\n"
msgstr ""

#: src/error/multiple_error_types/boxing_errors.md:34
msgid "// Converts to Box using From::from fn pointer.\n"
msgstr ""

#: src/error/multiple_error_types/boxing_errors.md:59
msgid ""
"[Dynamic dispatch](https://doc.rust-lang.org/book/ch17-02-trait-"
"objects.html#trait-objects-perform-dynamic-dispatch) and [`Error` trait]"
"(https://doc.rust-lang.org/std/error/trait.Error.html)"
msgstr ""

#: src/error/multiple_error_types/reenter_question_mark.md:3
msgid ""
"Notice in the previous example that our immediate reaction to calling "
"`parse` is to `map` the error from a library error into a boxed error:"
msgstr ""

#: src/error/multiple_error_types/reenter_question_mark.md:12
msgid ""
"Since this is a simple and common operation, it would be convenient if it "
"could be elided. Alas, because `and_then` is not sufficiently flexible, it "
"cannot. However, we can instead use `?`."
msgstr ""

#: src/error/multiple_error_types/reenter_question_mark.md:16
msgid ""
"`?` was previously explained as either `unwrap` or `return Err(err)`. This "
"is only mostly true. It actually means `unwrap` or `return "
"Err(From::from(err))`. Since `From::from` is a conversion utility between "
"different types, this means that if you `?` where the error is convertible "
"to the return type, it will convert automatically."
msgstr ""

#: src/error/multiple_error_types/reenter_question_mark.md:22
msgid ""
"Here, we rewrite the previous example using `?`. As a result, the `map_err` "
"will go away when `From::from` is implemented for our error type:"
msgstr ""

#: src/error/multiple_error_types/reenter_question_mark.md:42
msgid ""
"// The same structure as before but rather than chain all `Results`\n"
"// and `Options` along, we `?` to get the inner value out immediately.\n"
msgstr ""

#: src/error/multiple_error_types/reenter_question_mark.md:69
msgid ""
"This is actually fairly clean now. Compared with the original `panic`, it is "
"very similar to replacing the `unwrap` calls with `?` except that the return "
"types are `Result`. As a result, they must be destructured at the top level."
msgstr ""

#: src/error/multiple_error_types/reenter_question_mark.md:76
msgid ""
"[`From::from`](https://doc.rust-lang.org/std/convert/trait.From.html) and [`?"
"`](https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-"
"question-mark-operator)"
msgstr ""

#: src/error/multiple_error_types/wrap_error.md:3
msgid "An alternative to boxing errors is to wrap them in your own error type."
msgstr ""

#: src/error/multiple_error_types/wrap_error.md:16
msgid ""
"// We will defer to the parse error implementation for their error.\n"
"    // Supplying extra info requires adding more data to the type.\n"
msgstr ""

#: src/error/multiple_error_types/wrap_error.md:25
msgid "\"please use a vector with at least one element\""
msgstr ""

#: src/error/multiple_error_types/wrap_error.md:26
msgid ""
"// The wrapped error contains additional information and is available\n"
"            // via the source() method.\n"
msgstr ""

#: src/error/multiple_error_types/wrap_error.md:29
msgid "\"the provided string could not be parsed as int\""
msgstr ""

#: src/error/multiple_error_types/wrap_error.md:38
msgid ""
"// The cause is the underlying implementation error type. Is implicitly\n"
"            // cast to the trait object `&error::Error`. This works because "
"the\n"
"            // underlying type already implements the `Error` trait.\n"
msgstr ""

#: src/error/multiple_error_types/wrap_error.md:45
msgid ""
"// Implement the conversion from `ParseIntError` to `DoubleError`.\n"
"// This will be automatically called by `?` if a `ParseIntError`\n"
"// needs to be converted into a `DoubleError`.\n"
msgstr ""

#: src/error/multiple_error_types/wrap_error.md:57
msgid ""
"// Here we implicitly use the `ParseIntError` implementation of `From` "
"(which\n"
"    // we defined above) in order to create a `DoubleError`.\n"
msgstr ""

#: src/error/multiple_error_types/wrap_error.md:70
msgid "\"  Caused by: {}\""
msgstr ""

#: src/error/multiple_error_types/wrap_error.md:87
msgid ""
"This adds a bit more boilerplate for handling errors and might not be needed "
"in all applications. There are some libraries that can take care of the "
"boilerplate for you."
msgstr ""

#: src/error/multiple_error_types/wrap_error.md:93
msgid ""
"[`From::from`](https://doc.rust-lang.org/std/convert/trait.From.html) and "
"[`Enums`](../../custom_types/enum.md)"
msgstr ""

#: src/error/multiple_error_types/wrap_error.md:95
msgid ""
"[`Crates for handling errors`](https://crates.io/keywords/error-handling)"
msgstr ""

#: src/error/iter_result.md:3
msgid "An `Iter::map` operation might fail, for example:"
msgstr ""

#: src/error/iter_result.md:12 src/error/iter_result.md:29
#: src/error/iter_result.md:65
msgid "\"Results: {:?}\""
msgstr ""

#: src/error/iter_result.md:16
msgid "Let's step through strategies for handling this."
msgstr ""

#: src/error/iter_result.md:18
msgid "Ignore the failed items with `filter_map()`"
msgstr ""

#: src/error/iter_result.md:20
msgid ""
"`filter_map` calls a function and filters out the results that are `None`."
msgstr ""

#: src/error/iter_result.md:33
msgid "Collect the failed items with `map_err()` and `filter_map()`"
msgstr ""

#: src/error/iter_result.md:35
msgid ""
"`map_err` calls a function with the error, so by adding that to the previous "
"`filter_map` solution we can save them off to the side while iterating."
msgstr ""

#: src/error/iter_result.md:40
msgid "\"999\""
msgstr ""

#: src/error/iter_result.md:47 src/error/iter_result.md:80
#: src/error/iter_result.md:97
msgid "\"Numbers: {:?}\""
msgstr ""

#: src/error/iter_result.md:48 src/error/iter_result.md:81
#: src/error/iter_result.md:98
msgid "\"Errors: {:?}\""
msgstr ""

#: src/error/iter_result.md:52
msgid "Fail the entire operation with `collect()`"
msgstr ""

#: src/error/iter_result.md:54
msgid ""
"`Result` implements `FromIterator` so that a vector of results "
"(`Vec<Result<T, E>>`) can be turned into a result with a vector "
"(`Result<Vec<T>, E>`). Once an `Result::Err` is found, the iteration will "
"terminate."
msgstr ""

#: src/error/iter_result.md:69
msgid "This same technique can be used with `Option`."
msgstr ""

#: src/error/iter_result.md:71
msgid "Collect all valid values and failures with `partition()`"
msgstr ""

#: src/error/iter_result.md:85
msgid ""
"When you look at the results, you'll note that everything is still wrapped "
"in `Result`.  A little more boilerplate is needed for this."
msgstr ""

#: src/std.md:3
msgid ""
"The `std` library provides many custom types which expands drastically on "
"the `primitives`. Some of these include:"
msgstr ""

#: src/std.md:6
msgid "growable `String`s like: `\"hello world\"`"
msgstr ""

#: src/std.md:7
msgid "growable vectors: `[1, 2, 3]`"
msgstr ""

#: src/std.md:8
msgid "optional types: `Option<i32>`"
msgstr ""

#: src/std.md:9
msgid "error handling types: `Result<i32, i32>`"
msgstr ""

#: src/std.md:10
msgid "heap allocated pointers: `Box<i32>`"
msgstr ""

#: src/std.md:14 src/std_misc.md:14
msgid ""
"[primitives](primitives.md) and [the std library](https://doc.rust-lang.org/"
"std/)"
msgstr ""

#: src/std/box.md:3
msgid ""
"All values in Rust are stack allocated by default. Values can be _boxed_ "
"(allocated on the heap) by creating a `Box<T>`. A box is a smart pointer to "
"a heap allocated value of type `T`. When a box goes out of scope, its "
"destructor is called, the inner object is destroyed, and the memory on the "
"heap is freed."
msgstr ""

#: src/std/box.md:8
msgid ""
"Boxed values can be dereferenced using the `*` operator; this removes one "
"layer of indirection."
msgstr ""

#: src/std/box.md:20
msgid ""
"// A Rectangle can be specified by where its top left and bottom right\n"
"// corners are in space\n"
msgstr ""

#: src/std/box.md:34
msgid "// Allocate this point on the heap, and return a pointer to it\n"
msgstr ""

#: src/std/box.md:39
msgid ""
"// (all the type annotations are superfluous)\n"
"    // Stack allocated variables\n"
msgstr ""

#: src/std/box.md:47
msgid "// Heap allocated rectangle\n"
msgstr ""

#: src/std/box.md:53
msgid "// The output of functions can be boxed\n"
msgstr ""

#: src/std/box.md:56
msgid "// Double indirection\n"
msgstr ""

#: src/std/box.md:59
msgid "\"Point occupies {} bytes on the stack\""
msgstr ""

#: src/std/box.md:61
msgid "\"Rectangle occupies {} bytes on the stack\""
msgstr ""

#: src/std/box.md:64
msgid "// box size == pointer size\n"
msgstr ""

#: src/std/box.md:65
msgid "\"Boxed point occupies {} bytes on the stack\""
msgstr ""

#: src/std/box.md:67
msgid "\"Boxed rectangle occupies {} bytes on the stack\""
msgstr ""

#: src/std/box.md:69
msgid "\"Boxed box occupies {} bytes on the stack\""
msgstr ""

#: src/std/box.md:72
msgid "// Copy the data contained in `boxed_point` into `unboxed_point`\n"
msgstr ""

#: src/std/box.md:74
msgid "\"Unboxed point occupies {} bytes on the stack\""
msgstr ""

#: src/std/vec.md:3
msgid ""
"Vectors are re-sizable arrays. Like slices, their size is not known at "
"compile time, but they can grow or shrink at any time. A vector is "
"represented using 3 parameters:"
msgstr ""

#: src/std/vec.md:7
msgid "pointer to the data"
msgstr ""

#: src/std/vec.md:8
msgid "length"
msgstr ""

#: src/std/vec.md:9
msgid "capacity"
msgstr ""

#: src/std/vec.md:11
msgid ""
"The capacity indicates how much memory is reserved for the vector. The "
"vector can grow as long as the length is smaller than the capacity. When "
"this threshold needs to be surpassed, the vector is reallocated with a "
"larger capacity."
msgstr ""

#: src/std/vec.md:17
msgid "// Iterators can be collected into vectors\n"
msgstr ""

#: src/std/vec.md:19
msgid "\"Collected (0..10) into: {:?}\""
msgstr ""

#: src/std/vec.md:21
msgid "// The `vec!` macro can be used to initialize a vector\n"
msgstr ""

#: src/std/vec.md:23
msgid "\"Initial vector: {:?}\""
msgstr ""

#: src/std/vec.md:25
msgid "// Insert new element at the end of the vector\n"
msgstr ""

#: src/std/vec.md:26
msgid "\"Push 4 into the vector\""
msgstr ""

#: src/std/vec.md:28
msgid "\"Vector: {:?}\""
msgstr ""

#: src/std/vec.md:30
msgid "// Error! Immutable vectors can't grow\n"
msgstr ""

#: src/std/vec.md:34
msgid ""
"// The `len` method yields the number of elements currently stored in a "
"vector\n"
msgstr ""

#: src/std/vec.md:35
msgid "\"Vector length: {}\""
msgstr ""

#: src/std/vec.md:37
msgid "// Indexing is done using the square brackets (indexing starts at 0)\n"
msgstr ""

#: src/std/vec.md:38
msgid "\"Second element: {}\""
msgstr ""

#: src/std/vec.md:40
msgid "// `pop` removes the last element from the vector and returns it\n"
msgstr ""

#: src/std/vec.md:41
msgid "\"Pop last element: {:?}\""
msgstr ""

#: src/std/vec.md:43
msgid "// Out of bounds indexing yields a panic\n"
msgstr ""

#: src/std/vec.md:44
msgid "\"Fourth element: {}\""
msgstr ""

#: src/std/vec.md:47
msgid "// `Vector`s can be easily iterated over\n"
msgstr ""

#: src/std/vec.md:48
msgid "\"Contents of xs:\""
msgstr ""

#: src/std/vec.md:53
msgid ""
"// A `Vector` can also be iterated over while the iteration\n"
"    // count is enumerated in a separate variable (`i`)\n"
msgstr ""

#: src/std/vec.md:56
msgid "\"In position {} we have value {}\""
msgstr ""

#: src/std/vec.md:59
msgid ""
"// Thanks to `iter_mut`, mutable `Vector`s can also be iterated\n"
"    // over in a way that allows modifying each value\n"
msgstr ""

#: src/std/vec.md:64
msgid "\"Updated vector: {:?}\""
msgstr ""

#: src/std/vec.md:68
msgid ""
"More `Vec` methods can be found under the [std::vec](https://doc.rust-"
"lang.org/std/vec/) module"
msgstr ""

#: src/std/str.md:3
msgid "The two most used string types in Rust are `String` and `&str`."
msgstr ""

#: src/std/str.md:5
msgid ""
"A `String` is stored as a vector of bytes (`Vec<u8>`), but guaranteed to "
"always be a valid UTF-8 sequence. `String` is heap allocated, growable and "
"not null terminated."
msgstr ""

#: src/std/str.md:9
msgid ""
"`&str` is a slice (`&[u8]`) that always points to a valid UTF-8 sequence, "
"and can be used to view into a `String`, just like `&[T]` is a view into "
"`Vec<T>`."
msgstr ""

#: src/std/str.md:14
msgid ""
"// (all the type annotations are superfluous)\n"
"    // A reference to a string allocated in read only memory\n"
msgstr ""

#: src/std/str.md:16
msgid "\"the quick brown fox jumps over the lazy dog\""
msgstr ""

#: src/std/str.md:17
msgid "\"Pangram: {}\""
msgstr ""

#: src/std/str.md:19
msgid "// Iterate over words in reverse, no new string is allocated\n"
msgstr ""

#: src/std/str.md:20
msgid "\"Words in reverse\""
msgstr ""

#: src/std/str.md:25
msgid "// Copy chars into a vector, sort and remove duplicates\n"
msgstr ""

#: src/std/str.md:30
msgid "// Create an empty and growable `String`\n"
msgstr ""

#: src/std/str.md:33
msgid "// Insert a char at the end of string\n"
msgstr ""

#: src/std/str.md:35
msgid "// Insert a string at the end of string\n"
msgstr ""

#: src/std/str.md:39
msgid ""
"// The trimmed string is a slice to the original string, hence no new\n"
"    // allocation is performed\n"
msgstr ""

#: src/std/str.md:43
msgid "\"Used characters: {}\""
msgstr ""

#: src/std/str.md:45
msgid "// Heap allocate a string\n"
msgstr ""

#: src/std/str.md:46
msgid "\"I like dogs\""
msgstr ""

#: src/std/str.md:47
msgid "// Allocate new memory and store the modified string there\n"
msgstr ""

#: src/std/str.md:48
msgid "\"dog\""
msgstr ""

#: src/std/str.md:48
msgid "\"cat\""
msgstr ""

#: src/std/str.md:50
msgid "\"Alice says: {}\""
msgstr ""

#: src/std/str.md:51
msgid "\"Bob says: {}\""
msgstr ""

#: src/std/str.md:55
msgid ""
"More `str`/`String` methods can be found under the [std::str](https://"
"doc.rust-lang.org/std/str/) and [std::string](https://doc.rust-lang.org/std/"
"string/) modules"
msgstr ""

#: src/std/str.md:60
msgid "Literals and escapes"
msgstr ""

#: src/std/str.md:62
msgid ""
"There are multiple ways to write string literals with special characters in "
"them. All result in a similar `&str` so it's best to use the form that is "
"the most convenient to write. Similarly there are multiple ways to write "
"byte string literals, which all result in `&[u8; N]`."
msgstr ""

#: src/std/str.md:67
msgid ""
"Generally special characters are escaped with a backslash character: `\\`. "
"This way you can add any character to your string, even unprintable ones and "
"ones that you don't know how to type. If you want a literal backslash, "
"escape it with another one: `\\\\`"
msgstr ""

#: src/std/str.md:72
msgid ""
"String or character literal delimiters occurring within a literal must be "
"escaped: `\"\\\"\"`, `'\\''`."
msgstr ""

#: src/std/str.md:76
msgid "// You can use escapes to write bytes by their hexadecimal values...\n"
msgstr ""

#: src/std/str.md:77
msgid "\"I'm writing \\x52\\x75\\x73\\x74!\""
msgstr ""

#: src/std/str.md:78
msgid "\"What are you doing\\x3F (\\\\x3F means ?) {}\""
msgstr ""

#: src/std/str.md:80
msgid "// ...or Unicode code points.\n"
msgstr ""

#: src/std/str.md:81
msgid "\"\\u{211D}\""
msgstr ""

#: src/std/str.md:82
msgid "\"\\\"DOUBLE-STRUCK CAPITAL R\\\"\""
msgstr ""

#: src/std/str.md:84
msgid "\"Unicode character {} (U+211D) is called {}\""
msgstr ""

#: src/std/str.md:88
msgid ""
"\"String literals\n"
"                        can span multiple lines.\n"
"                        The linebreak and indentation here ->\\\n"
"                        <- can be escaped too!\""
msgstr ""

#: src/std/str.md:96
msgid ""
"Sometimes there are just too many characters that need to be escaped or it's "
"just much more convenient to write a string out as-is. This is where raw "
"string literals come into play."
msgstr ""

#: src/std/str.md:101
msgid "r\"Escapes don't work here: \\x3F \\u{211D}\""
msgstr ""

#: src/std/str.md:104
msgid "// If you need quotes in a raw string, add a pair of #s\n"
msgstr ""

#: src/std/str.md:105
msgid "r#\"And then I said: \"There is no escape!\"\"#"
msgstr ""

#: src/std/str.md:108
msgid ""
"// If you need \"# in your string, just use more #s in the delimiter.\n"
"    // You can use up to 255 #s.\n"
msgstr ""

#: src/std/str.md:110
msgid "r###\"A string with \"# in it. And even \"##!\"###"
msgstr ""

#: src/std/str.md:115
msgid ""
"Want a string that's not UTF-8? (Remember, `str` and `String` must be valid "
"UTF-8). Or maybe you want an array of bytes that's mostly text? Byte strings "
"to the rescue!"
msgstr ""

#: src/std/str.md:122
msgid "// Note that this is not actually a `&str`\n"
msgstr ""

#: src/std/str.md:123
msgid "b\"this is a byte string\""
msgstr ""

#: src/std/str.md:125
msgid ""
"// Byte arrays don't have the `Display` trait, so printing them is a bit "
"limited\n"
msgstr ""

#: src/std/str.md:126
msgid "\"A byte string: {:?}\""
msgstr ""

#: src/std/str.md:128
msgid "// Byte strings can have byte escapes...\n"
msgstr ""

#: src/std/str.md:129
msgid "b\"\\x52\\x75\\x73\\x74 as bytes\""
msgstr ""

#: src/std/str.md:130
msgid ""
"// ...but no unicode escapes\n"
"    // let escaped = b\"\\u{211D} is not allowed\";\n"
msgstr ""

#: src/std/str.md:132
msgid "\"Some escaped bytes: {:?}\""
msgstr ""

#: src/std/str.md:135
msgid "// Raw byte strings work just like raw strings\n"
msgstr ""

#: src/std/str.md:136
msgid "br\"\\u{211D} is not escaped here\""
msgstr ""

#: src/std/str.md:139
msgid "// Converting a byte array to `str` can fail\n"
msgstr ""

#: src/std/str.md:141
msgid "\"And the same as text: '{}'\""
msgstr ""

#: src/std/str.md:144
msgid ""
"br#\"You can also use \"fancier\" formatting, \\\n"
"                    like with normal raw strings\"#"
msgstr ""

#: src/std/str.md:147
msgid "// Byte strings don't have to be UTF-8\n"
msgstr ""

#: src/std/str.md:148
msgid "b\"\\x82\\xe6\\x82\\xa8\\x82\\xb1\\x82\\xbb\""
msgstr ""

#: src/std/str.md:148
msgid "// \"ようこそ\" in SHIFT-JIS\n"
msgstr ""

#: src/std/str.md:150
msgid "// But then they can't always be converted to `str`\n"
msgstr ""

#: src/std/str.md:152
msgid "\"Conversion successful: '{}'\""
msgstr ""

#: src/std/str.md:153
msgid "\"Conversion failed: {:?}\""
msgstr ""

#: src/std/str.md:158
msgid ""
"For conversions between character encodings check out the [encoding](https://"
"crates.io/crates/encoding) crate."
msgstr ""

#: src/std/str.md:160
msgid ""
"A more detailed listing of the ways to write string literals and escape "
"characters is given in the ['Tokens' chapter](https://doc.rust-lang.org/"
"reference/tokens.html) of the Rust Reference."
msgstr ""

#: src/std/option.md:3
msgid ""
"Sometimes it's desirable to catch the failure of some parts of a program "
"instead of calling `panic!`; this can be accomplished using the `Option` "
"enum."
msgstr ""

#: src/std/option.md:6
msgid "The `Option<T>` enum has two variants:"
msgstr ""

#: src/std/option.md:8
msgid "`None`, to indicate failure or lack of value, and"
msgstr ""

#: src/std/option.md:9
msgid "`Some(value)`, a tuple struct that wraps a `value` with type `T`."
msgstr ""

#: src/std/option.md:12
msgid "// An integer division that doesn't `panic!`\n"
msgstr ""

#: src/std/option.md:15
msgid "// Failure is represented as the `None` variant\n"
msgstr ""

#: src/std/option.md:18
msgid "// Result is wrapped in a `Some` variant\n"
msgstr ""

#: src/std/option.md:22
msgid "// This function handles a division that may not succeed\n"
msgstr ""

#: src/std/option.md:25
msgid "// `Option` values can be pattern matched, just like other enums\n"
msgstr ""

#: src/std/option.md:27
msgid "\"{} / {} failed!\""
msgstr ""

#: src/std/option.md:29
msgid "\"{} / {} = {}\""
msgstr ""

#: src/std/option.md:38
msgid "// Binding `None` to a variable needs to be type annotated\n"
msgstr ""

#: src/std/option.md:44
msgid "// Unwrapping a `Some` variant will extract the value wrapped.\n"
msgstr ""

#: src/std/option.md:45 src/std/option.md:48
msgid "\"{:?} unwraps to {:?}\""
msgstr ""

#: src/std/option.md:47
msgid "// Unwrapping a `None` variant will `panic!`\n"
msgstr ""

#: src/std/result.md:3
msgid ""
"We've seen that the `Option` enum can be used as a return value from "
"functions that may fail, where `None` can be returned to indicate failure. "
"However, sometimes it is important to express _why_ an operation failed. To "
"do this we have the `Result` enum."
msgstr ""

#: src/std/result.md:8
msgid "The `Result<T, E>` enum has two variants:"
msgstr ""

#: src/std/result.md:10
msgid ""
"`Ok(value)` which indicates that the operation succeeded, and wraps the "
"`value` returned by the operation. (`value` has type `T`)"
msgstr ""

#: src/std/result.md:12
msgid ""
"`Err(why)`, which indicates that the operation failed, and wraps `why`, "
"which (hopefully) explains the cause of the failure. (`why` has type `E`)"
msgstr ""

#: src/std/result.md:17
msgid "// Mathematical \"errors\" we want to catch\n"
msgstr ""

#: src/std/result.md:29
msgid ""
"// This operation would `fail`, instead let's return the reason of\n"
"            // the failure wrapped in `Err`\n"
msgstr ""

#: src/std/result.md:33
msgid "// This operation is valid, return the result wrapped in `Ok`\n"
msgstr ""

#: src/std/result.md:54
msgid "// `op(x, y)` === `sqrt(ln(x / y))`\n"
msgstr ""

#: src/std/result.md:57
msgid "// This is a three level match pyramid!\n"
msgstr ""

#: src/std/result.md:71
msgid "// Will this fail?\n"
msgstr ""

#: src/std/result/question_mark.md:3
msgid ""
"Chaining results using match can get pretty untidy; luckily, the `?` "
"operator can be used to make things pretty again. `?` is used at the end of "
"an expression returning a `Result`, and is equivalent to a match expression, "
"where the `Err(err)` branch expands to an early `return "
"Err(From::from(err))`, and the `Ok(ok)` branch expands to an `ok` expression."
msgstr ""

#: src/std/result/question_mark.md:44
msgid "// Intermediate function\n"
msgstr ""

#: src/std/result/question_mark.md:46
msgid "// if `div` \"fails\", then `DivisionByZero` will be `return`ed\n"
msgstr ""

#: src/std/result/question_mark.md:49
msgid "// if `ln` \"fails\", then `NonPositiveLogarithm` will be `return`ed\n"
msgstr ""

#: src/std/result/question_mark.md:59
msgid "\"logarithm of non-positive number\""
msgstr ""

#: src/std/result/question_mark.md:61 src/std/panic.md:15
msgid "\"division by zero\""
msgstr ""

#: src/std/result/question_mark.md:63
msgid "\"square root of negative number\""
msgstr ""

#: src/std/result/question_mark.md:75
msgid ""
"Be sure to check the [documentation](https://doc.rust-lang.org/std/result/"
"index.html), as there are many methods to map/compose `Result`."
msgstr ""

#: src/std/panic.md:3
msgid ""
"The `panic!` macro can be used to generate a panic and start unwinding its "
"stack. While unwinding, the runtime will take care of freeing all the "
"resources _owned_ by the thread by calling the destructor of all its objects."
msgstr ""

#: src/std/panic.md:7
msgid ""
"Since we are dealing with programs with only one thread, `panic!` will cause "
"the program to report the panic message and exit."
msgstr ""

#: src/std/panic.md:11
msgid "// Re-implementation of integer division (/)\n"
msgstr ""

#: src/std/panic.md:14
msgid "// Division by zero triggers a panic\n"
msgstr ""

#: src/std/panic.md:20
msgid "// The `main` task\n"
msgstr ""

#: src/std/panic.md:23
msgid "// Heap allocated integer\n"
msgstr ""

#: src/std/panic.md:26
msgid "// This operation will trigger a task failure\n"
msgstr ""

#: src/std/panic.md:29
msgid "\"This point won't be reached!\""
msgstr ""

#: src/std/panic.md:31
msgid "// `_x` should get destroyed at this point\n"
msgstr ""

#: src/std/panic.md:35
msgid "Let's check that `panic!` doesn't leak memory."
msgstr ""

#: src/std/hash.md:3
msgid ""
"Where vectors store values by an integer index, `HashMap`s store values by "
"key. `HashMap` keys can be booleans, integers, strings, or any other type "
"that implements the `Eq` and `Hash` traits. More on this in the next section."
msgstr ""

#: src/std/hash.md:8
msgid ""
"Like vectors, `HashMap`s are growable, but HashMaps can also shrink "
"themselves when they have excess space. You can create a HashMap with a "
"certain starting capacity using `HashMap::with_capacity(uint)`, or use "
"`HashMap::new()` to get a HashMap with a default initial capacity "
"(recommended)."
msgstr ""

#: src/std/hash.md:19 src/std/hash.md:30
msgid "\"798-1364\""
msgstr ""

#: src/std/hash.md:19
msgid ""
"\"We're sorry, the call cannot be completed as dialed.\n"
"            Please hang up and try again.\""
msgstr ""

#: src/std/hash.md:21 src/std/hash.md:31
msgid "\"645-7689\""
msgstr ""

#: src/std/hash.md:21
msgid ""
"\"Hello, this is Mr. Awesome's Pizza. My name is Fred.\n"
"            What can I get for you today?\""
msgstr ""

#: src/std/hash.md:23
msgid "\"Hi! Who is this again?\""
msgstr ""

#: src/std/hash.md:30 src/std/hash.md:36 src/std/hash.md:43
msgid "\"Daniel\""
msgstr ""

#: src/std/hash.md:31 src/std/hash.md:45 src/std/hash.md:50
msgid "\"Ashley\""
msgstr ""

#: src/std/hash.md:32
msgid "\"Katie\""
msgstr ""

#: src/std/hash.md:32
msgid "\"435-8291\""
msgstr ""

#: src/std/hash.md:33
msgid "\"Robert\""
msgstr ""

#: src/std/hash.md:33
msgid "\"956-1745\""
msgstr ""

#: src/std/hash.md:35
msgid "// Takes a reference and returns Option<&V>\n"
msgstr ""

#: src/std/hash.md:37
msgid "\"Calling Daniel: {}\""
msgstr ""

#: src/std/hash.md:38
msgid "\"Don't have Daniel's number.\""
msgstr ""

#: src/std/hash.md:41
msgid ""
"// `HashMap::insert()` returns `None`\n"
"    // if the inserted value is new, `Some(value)` otherwise\n"
msgstr ""

#: src/std/hash.md:43
msgid "\"164-6743\""
msgstr ""

#: src/std/hash.md:46
msgid "\"Calling Ashley: {}\""
msgstr ""

#: src/std/hash.md:47
msgid "\"Don't have Ashley's number.\""
msgstr ""

#: src/std/hash.md:52
msgid ""
"// `HashMap::iter()` returns an iterator that yields\n"
"    // (&'a key, &'a value) pairs in arbitrary order.\n"
msgstr ""

#: src/std/hash.md:55
msgid "\"Calling {}: {}\""
msgstr ""

#: src/std/hash.md:60
msgid ""
"For more information on how hashing and hash maps (sometimes called hash "
"tables) work, have a look at [Hash Table Wikipedia](https://en.wikipedia.org/"
"wiki/Hash_table)"
msgstr ""

#: src/std/hash/alt_key_types.md:3
msgid ""
"Any type that implements the `Eq` and `Hash` traits can be a key in "
"`HashMap`. This includes:"
msgstr ""

#: src/std/hash/alt_key_types.md:6
msgid "`bool` (though not very useful since there are only two possible keys)"
msgstr ""

#: src/std/hash/alt_key_types.md:7
msgid "`int`, `uint`, and all variations thereof"
msgstr ""

#: src/std/hash/alt_key_types.md:8
msgid ""
"`String` and `&str` (protip: you can have a `HashMap` keyed by `String` and "
"call `.get()` with an `&str`)"
msgstr ""

#: src/std/hash/alt_key_types.md:11
msgid ""
"Note that `f32` and `f64` do _not_ implement `Hash`, likely because "
"[floating-point precision errors](https://en.wikipedia.org/wiki/"
"Floating_point#Accuracy_problems) would make using them as hashmap keys "
"horribly error-prone."
msgstr ""

#: src/std/hash/alt_key_types.md:15
msgid ""
"All collection classes implement `Eq` and `Hash` if their contained type "
"also respectively implements `Eq` and `Hash`. For example, `Vec<T>` will "
"implement `Hash` if `T` implements `Hash`."
msgstr ""

#: src/std/hash/alt_key_types.md:19
msgid ""
"You can easily implement `Eq` and `Hash` for a custom type with just one "
"line: `#[derive(PartialEq, Eq, Hash)]`"
msgstr ""

#: src/std/hash/alt_key_types.md:22
msgid ""
"The compiler will do the rest. If you want more control over the details, "
"you can implement `Eq` and/or `Hash` yourself. This guide will not cover the "
"specifics of implementing `Hash`."
msgstr ""

#: src/std/hash/alt_key_types.md:26
msgid ""
"To play around with using a `struct` in `HashMap`, let's try making a very "
"simple user logon system:"
msgstr ""

#: src/std/hash/alt_key_types.md:31
msgid "// Eq requires that you derive PartialEq on the type.\n"
msgstr ""

#: src/std/hash/alt_key_types.md:48
msgid "\"Username: {}\""
msgstr ""

#: src/std/hash/alt_key_types.md:49
msgid "\"Password: {}\""
msgstr ""

#: src/std/hash/alt_key_types.md:50
msgid "\"Attempting logon...\""
msgstr ""

#: src/std/hash/alt_key_types.md:59
msgid "\"Successful logon!\""
msgstr ""

#: src/std/hash/alt_key_types.md:60
msgid "\"Name: {}\""
msgstr ""

#: src/std/hash/alt_key_types.md:61
msgid "\"Email: {}\""
msgstr ""

#: src/std/hash/alt_key_types.md:63
msgid "\"Login failed!\""
msgstr ""

#: src/std/hash/alt_key_types.md:71 src/std/hash/alt_key_types.md:82
#: src/std/hash/alt_key_types.md:84
msgid "\"j.everyman\""
msgstr ""

#: src/std/hash/alt_key_types.md:72 src/std/hash/alt_key_types.md:84
msgid "\"password123\""
msgstr ""

#: src/std/hash/alt_key_types.md:76
msgid "\"John Everyman\""
msgstr ""

#: src/std/hash/alt_key_types.md:77
msgid "\"j.everyman@email.com\""
msgstr ""

#: src/std/hash/alt_key_types.md:82
msgid "\"psasword123\""
msgstr ""

#: src/std/hash/hashset.md:3
msgid ""
"Consider a `HashSet` as a `HashMap` where we just care about the keys "
"( `HashSet<T>` is, in actuality, just a wrapper around `HashMap<T, ()>`)."
msgstr ""

#: src/std/hash/hashset.md:6
msgid ""
"\"What's the point of that?\" you ask. \"I could just store the keys in a "
"`Vec`.\""
msgstr ""

#: src/std/hash/hashset.md:8
msgid ""
"A `HashSet`'s unique feature is that it is guaranteed to not have duplicate "
"elements. That's the contract that any set collection fulfills. `HashSet` is "
"just one implementation. (see also: [`BTreeSet`](https://doc.rust-lang.org/"
"std/collections/struct.BTreeSet.html))"
msgstr ""

#: src/std/hash/hashset.md:13
msgid ""
"If you insert a value that is already present in the `HashSet`, (i.e. the "
"new value is equal to the existing and they both have the same hash), then "
"the new value will replace the old."
msgstr ""

#: src/std/hash/hashset.md:17
msgid ""
"This is great for when you never want more than one of something, or when "
"you want to know if you've already got something."
msgstr ""

#: src/std/hash/hashset.md:20
msgid "But sets can do more than that."
msgstr ""

#: src/std/hash/hashset.md:22
msgid ""
"Sets have 4 primary operations (all of the following calls return an "
"iterator):"
msgstr ""

#: src/std/hash/hashset.md:24
msgid "`union`: get all the unique elements in both sets."
msgstr ""

#: src/std/hash/hashset.md:26
msgid ""
"`difference`: get all the elements that are in the first set but not the "
"second."
msgstr ""

#: src/std/hash/hashset.md:28
msgid "`intersection`: get all the elements that are only in _both_ sets."
msgstr ""

#: src/std/hash/hashset.md:30
msgid ""
"`symmetric_difference`: get all the elements that are in one set or the "
"other, but _not_ both."
msgstr ""

#: src/std/hash/hashset.md:33
msgid "Try all of these in the following example:"
msgstr ""

#: src/std/hash/hashset.md:45
msgid ""
"// `HashSet::insert()` returns false if\n"
"    // there was a value already present.\n"
msgstr ""

#: src/std/hash/hashset.md:47
msgid "\"Value 4 is already in set B!\""
msgstr ""

#: src/std/hash/hashset.md:52
msgid ""
"// If a collection's element type implements `Debug`,\n"
"    // then the collection implements `Debug`.\n"
"    // It usually prints its elements in the format `[elem1, elem2, ...]`\n"
msgstr ""

#: src/std/hash/hashset.md:55
msgid "\"A: {:?}\""
msgstr ""

#: src/std/hash/hashset.md:56
msgid "\"B: {:?}\""
msgstr ""

#: src/std/hash/hashset.md:58
msgid "// Print [1, 2, 3, 4, 5] in arbitrary order\n"
msgstr ""

#: src/std/hash/hashset.md:59
msgid "\"Union: {:?}\""
msgstr ""

#: src/std/hash/hashset.md:61
msgid "// This should print [1]\n"
msgstr ""

#: src/std/hash/hashset.md:62
msgid "\"Difference: {:?}\""
msgstr ""

#: src/std/hash/hashset.md:64
msgid "// Print [2, 3, 4] in arbitrary order.\n"
msgstr ""

#: src/std/hash/hashset.md:65
msgid "\"Intersection: {:?}\""
msgstr ""

#: src/std/hash/hashset.md:67
msgid "// Print [1, 5]\n"
msgstr ""

#: src/std/hash/hashset.md:68
msgid "\"Symmetric Difference: {:?}\""
msgstr ""

#: src/std/hash/hashset.md:73
msgid ""
"(Examples are adapted from the [documentation.](https://doc.rust-lang.org/"
"std/collections/struct.HashSet.html#method.difference))"
msgstr ""

#: src/std/rc.md:3
msgid ""
"When multiple ownership is needed, `Rc`(Reference Counting) can be used. "
"`Rc` keeps track of the number of the references which means the number of "
"owners of the value wrapped inside an `Rc`."
msgstr ""

#: src/std/rc.md:7
msgid ""
"Reference count of an `Rc` increases by 1 whenever an `Rc` is cloned, and "
"decreases by 1 whenever one cloned `Rc` is dropped out of the scope. When an "
"`Rc`'s reference count becomes zero (which means there are no remaining "
"owners), both the `Rc` and the value are all dropped."
msgstr ""

#: src/std/rc.md:12
msgid ""
"Cloning an `Rc` never performs a deep copy. Cloning creates just another "
"pointer to the wrapped value, and increments the count."
msgstr ""

#: src/std/rc.md:19
msgid "\"Rc examples\""
msgstr ""

#: src/std/rc.md:21
msgid "\"--- rc_a is created ---\""
msgstr ""

#: src/std/rc.md:24 src/std/rc.md:31 src/std/rc.md:43
msgid "\"Reference Count of rc_a: {}\""
msgstr ""

#: src/std/rc.md:27
msgid "\"--- rc_a is cloned to rc_b ---\""
msgstr ""

#: src/std/rc.md:30
msgid "\"Reference Count of rc_b: {}\""
msgstr ""

#: src/std/rc.md:33
msgid "// Two `Rc`s are equal if their inner values are equal\n"
msgstr ""

#: src/std/rc.md:34
msgid "\"rc_a and rc_b are equal: {}\""
msgstr ""

#: src/std/rc.md:36
msgid "// We can use methods of a value directly\n"
msgstr ""

#: src/std/rc.md:37
msgid "\"Length of the value inside rc_a: {}\""
msgstr ""

#: src/std/rc.md:38
msgid "\"Value of rc_b: {}\""
msgstr ""

#: src/std/rc.md:40
msgid "\"--- rc_b is dropped out of scope ---\""
msgstr ""

#: src/std/rc.md:45
msgid "\"--- rc_a is dropped out of scope ---\""
msgstr ""

#: src/std/rc.md:48
msgid ""
"// Error! `rc_examples` already moved into `rc_a`\n"
"    // And when `rc_a` is dropped, `rc_examples` is dropped together\n"
"    // println!(\"rc_examples: {}\", rc_examples);\n"
"    // TODO ^ Try uncommenting this line\n"
msgstr ""

#: src/std/rc.md:57
msgid ""
"[std::rc](https://doc.rust-lang.org/std/rc/index.html) and [std::sync::arc]"
"(https://doc.rust-lang.org/std/sync/struct.Arc.html)."
msgstr ""

#: src/std/arc.md:1
msgid "Arc"
msgstr ""

#: src/std/arc.md:3
msgid ""
"When shared ownership between threads is needed, `Arc`(Atomically Reference "
"Counted) can be used. This struct, via the `Clone` implementation can create "
"a reference pointer for the location of a value in the memory heap while "
"increasing the reference counter. As it shares ownership between threads, "
"when the last reference pointer to a value is out of scope, the variable is "
"dropped."
msgstr ""

#: src/std/arc.md:15
msgid "// This variable declaration is where its value is specified.\n"
msgstr ""

#: src/std/arc.md:16
msgid "\"the same apple\""
msgstr ""

#: src/std/arc.md:19
msgid ""
"// Here there is no value specification as it is a pointer to a\n"
"        // reference in the memory heap.\n"
msgstr ""

#: src/std/arc.md:24
msgid ""
"// As Arc was used, threads can be spawned using the value allocated\n"
"            // in the Arc variable pointer's location.\n"
msgstr ""

#: src/std/arc.md:30
msgid "// Make sure all Arc instances are printed from spawned threads.\n"
msgstr ""

#: src/std_misc.md:3
msgid ""
"Many other types are provided by the std library to support things such as:"
msgstr ""

#: src/std_misc.md:10
msgid "These expand beyond what the [primitives](primitives.md) provide."
msgstr ""

#: src/std_misc/threads.md:3
msgid ""
"Rust provides a mechanism for spawning native OS threads via the `spawn` "
"function, the argument of this function is a moving closure."
msgstr ""

#: src/std_misc/threads.md:10 src/std_misc/threads/testcase_mapreduce.md:28
msgid "// This is the `main` thread\n"
msgstr ""

#: src/std_misc/threads.md:13
msgid "// Make a vector to hold the children which are spawned.\n"
msgstr ""

#: src/std_misc/threads.md:17
msgid "// Spin up another thread\n"
msgstr ""

#: src/std_misc/threads.md:19
msgid "\"this is thread number {}\""
msgstr ""

#: src/std_misc/threads.md:24
msgid "// Wait for the thread to finish. Returns a result.\n"
msgstr ""

#: src/std_misc/threads.md:30
msgid "These threads will be scheduled by the OS."
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:3
msgid ""
"Rust makes it very easy to parallelize data processing, without many of the "
"headaches traditionally associated with such an attempt."
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:5
msgid ""
"The standard library provides great threading primitives out of the box. "
"These, combined with Rust's concept of Ownership and aliasing rules, "
"automatically prevent data races."
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:9
msgid ""
"The aliasing rules (one writable reference XOR many readable references) "
"automatically prevent you from manipulating state that is visible to other "
"threads. (Where synchronization is needed, there are synchronization "
"primitives like `Mutex`es or `Channel`s.)"
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:14
msgid ""
"In this example, we will calculate the sum of all digits in a block of "
"numbers. We will do this by parcelling out chunks of the block into "
"different threads. Each thread will sum its tiny block of digits, and "
"subsequently we will sum the intermediate sums produced by each thread."
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:19
msgid ""
"Note that, although we're passing references across thread boundaries, Rust "
"understands that we're only passing read-only references, and that thus no "
"unsafety or data races can occur. Also because the references we're passing "
"have `'static` lifetimes, Rust understands that our data won't be destroyed "
"while these threads are still running. (When you need to share non-`static` "
"data between threads, you can use a smart pointer like `Arc` to keep the "
"data alive and avoid non-`static` lifetimes.)"
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:32
msgid ""
"// This is our data to process.\n"
"    // We will calculate the sum of all digits via a threaded map-reduce "
"algorithm.\n"
"    // Each whitespace separated chunk will be handled in a different "
"thread.\n"
"    //\n"
"    // TODO: see what happens to the output if you insert spaces!\n"
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:37
msgid ""
"\"86967897737416471853297327050364959\n"
"11861322575564723963297542624962850\n"
"70856234701860851907960690014725639\n"
"38397966707106094172783238747669219\n"
"52380795257888236525459303330302837\n"
"58495327135744041048897885734297812\n"
"69920216438980873548808413720956532\n"
"16278424637452589860345374828574668\""
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:46
msgid "// Make a vector to hold the child-threads which we will spawn.\n"
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:49
msgid ""
"/*************************************************************************\n"
"     * \"Map\" phase\n"
"     *\n"
"     * Divide our data into segments, and apply initial processing\n"
"     ************************************************************************/"
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:55
msgid ""
"// split our data into segments for individual calculation\n"
"    // each chunk will be a reference (&str) into the actual data\n"
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:59
msgid ""
"// Iterate over the data segments.\n"
"    // .enumerate() adds the current loop index to whatever is iterated\n"
"    // the resulting tuple \"(index, element)\" is then immediately\n"
"    // \"destructured\" into two variables, \"i\" and \"data_segment\" with "
"a\n"
"    // \"destructuring assignment\"\n"
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:65
msgid "\"data segment {} is \\\"{}\\\"\""
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:67
msgid ""
"// Process each data segment in a separate thread\n"
"        //\n"
"        // spawn() returns a handle to the new thread,\n"
"        // which we MUST keep to access the returned value\n"
"        //\n"
"        // 'move || -> u32' is syntax for a closure that:\n"
"        // * takes no arguments ('||')\n"
"        // * takes ownership of its captured variables ('move') and\n"
"        // * returns an unsigned 32-bit integer ('-> u32')\n"
"        //\n"
"        // Rust is smart enough to infer the '-> u32' from\n"
"        // the closure itself so we could have left that out.\n"
"        //\n"
"        // TODO: try removing the 'move' and see what happens\n"
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:82
msgid "// Calculate the intermediate sum of this segment:\n"
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:84
msgid "// iterate over the characters of our segment..\n"
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:86
msgid "// .. convert text-characters to their number value..\n"
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:87
msgid "\"should be a digit\""
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:88
msgid "// .. and sum the resulting iterator of numbers\n"
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:91
msgid "// println! locks stdout, so no text-interleaving occurs\n"
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:92
msgid "\"processed segment {}, result={}\""
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:94
msgid ""
"// \"return\" not needed, because Rust is an \"expression language\", the\n"
"            // last evaluated expression in each block is automatically its "
"value.\n"
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:102
msgid ""
"/*************************************************************************\n"
"     * \"Reduce\" phase\n"
"     *\n"
"     * Collect our intermediate results, and combine them into a final "
"result\n"
"     ************************************************************************/"
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:108
msgid ""
"// combine each thread's intermediate results into a single final sum.\n"
"    //\n"
"    // we use the \"turbofish\" ::<> to provide sum() with a type hint.\n"
"    //\n"
"    // TODO: try without the turbofish, by instead explicitly\n"
"    // specifying the type of final_result\n"
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:116
msgid "\"Final sum result: {}\""
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:120
msgid "Assignments"
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:122
msgid ""
"It is not wise to let our number of threads depend on user inputted data. "
"What if the user decides to insert a lot of spaces? Do we _really_ want to "
"spawn 2,000 threads? Modify the program so that the data is always chunked "
"into a limited number of chunks, defined by a static constant at the "
"beginning of the program."
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:129
msgid "[Threads](../threads.md)"
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:130
msgid "[vectors](../../std/vec.md) and [iterators](../../trait/iter.md)"
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:131
msgid ""
"[closures](../../fn/closures.md), [move](../../scope/move.md) semantics and "
"[`move` closures](https://doc.rust-lang.org/book/ch13-01-"
"closures.html#closures-can-capture-their-environment)"
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:132
msgid ""
"[destructuring](https://doc.rust-lang.org/book/ch18-03-pattern-"
"syntax.html#destructuring-to-break-apart-values) assignments"
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:133
msgid ""
"[turbofish notation](https://doc.rust-lang.org/book/appendix-02-"
"operators.html?highlight=turbofish) to help type inference"
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:134
msgid "[unwrap vs. expect](../../error/option_unwrap.md)"
msgstr ""

#: src/std_misc/threads/testcase_mapreduce.md:135
msgid "[enumerate](https://doc.rust-lang.org/book/loops.html#enumerate)"
msgstr ""

#: src/std_misc/channels.md:3
msgid ""
"Rust provides asynchronous `channels` for communication between threads. "
"Channels allow a unidirectional flow of information between two end-points: "
"the `Sender` and the `Receiver`."
msgstr ""

#: src/std_misc/channels.md:15
msgid ""
"// Channels have two endpoints: the `Sender<T>` and the `Receiver<T>`,\n"
"    // where `T` is the type of the message to be transferred\n"
"    // (type annotation is superfluous)\n"
msgstr ""

#: src/std_misc/channels.md:22
msgid "// The sender endpoint can be copied\n"
msgstr ""

#: src/std_misc/channels.md:25
msgid "// Each thread will send its id via the channel\n"
msgstr ""

#: src/std_misc/channels.md:27
msgid ""
"// The thread takes ownership over `thread_tx`\n"
"            // Each thread queues a message in the channel\n"
msgstr ""

#: src/std_misc/channels.md:31
msgid ""
"// Sending is a non-blocking operation, the thread will continue\n"
"            // immediately after sending its message\n"
msgstr ""

#: src/std_misc/channels.md:33
msgid "\"thread {} finished\""
msgstr ""

#: src/std_misc/channels.md:39
msgid "// Here, all the messages are collected\n"
msgstr ""

#: src/std_misc/channels.md:42
msgid ""
"// The `recv` method picks a message from the channel\n"
"        // `recv` will block the current thread if there are no messages "
"available\n"
msgstr ""

#: src/std_misc/channels.md:47
msgid "// Wait for the threads to complete any remaining work\n"
msgstr ""

#: src/std_misc/channels.md:49
msgid "\"oops! the child thread panicked\""
msgstr ""

#: src/std_misc/channels.md:52
msgid "// Show the order in which the messages were sent\n"
msgstr ""

#: src/std_misc/path.md:3
msgid ""
"The `Path` type represents file paths in the underlying filesystem. Across "
"all platforms there is a single `std::path::Path` that abstracts over "
"platform-specific path semantics and separators. Bring it into scope with "
"`use std::path::Path;` when needed."
msgstr ""

#: src/std_misc/path.md:8
msgid ""
"A `Path` can be created from an `OsStr`, and provides several methods to get "
"information from the file/directory the path points to."
msgstr ""

#: src/std_misc/path.md:11
msgid ""
"A `Path` is immutable. The owned version of `Path` is `PathBuf`. The "
"relation between `Path` and `PathBuf` is similar to that of `str` and "
"`String`: a `PathBuf` can be mutated in-place, and can be dereferenced to a "
"`Path`."
msgstr ""

#: src/std_misc/path.md:15
msgid ""
"Note that a `Path` is _not_ internally represented as an UTF-8 string, but "
"instead is stored as an `OsString`. Therefore, converting a `Path` to a "
"`&str` is _not_ free and may fail (an `Option` is returned). However, a "
"`Path` can be freely converted to an `OsString` or `&OsStr` using "
"`into_os_string` and `as_os_str`, respectively."
msgstr ""

#: src/std_misc/path.md:25
msgid "// Create a `Path` from an `&'static str`\n"
msgstr ""

#: src/std_misc/path.md:26
msgid "\".\""
msgstr ""

#: src/std_misc/path.md:28
msgid "// The `display` method returns a `Display`able structure\n"
msgstr ""

#: src/std_misc/path.md:31
msgid ""
"// `join` merges a path with a byte container using the OS specific\n"
"    // separator, and returns a `PathBuf`\n"
msgstr ""

#: src/std_misc/path.md:35
msgid "// `push` extends the `PathBuf` with a `&Path`\n"
msgstr ""

#: src/std_misc/path.md:37
msgid "\"myfile.tar.gz\""
msgstr ""

#: src/std_misc/path.md:39
msgid "// `set_file_name` updates the file name of the `PathBuf`\n"
msgstr ""

#: src/std_misc/path.md:40
msgid "\"package.tgz\""
msgstr ""

#: src/std_misc/path.md:42
msgid "// Convert the `PathBuf` into a string slice\n"
msgstr ""

#: src/std_misc/path.md:44
msgid "\"new path is not a valid UTF-8 sequence\""
msgstr ""

#: src/std_misc/path.md:45
msgid "\"new path is {}\""
msgstr ""

#: src/std_misc/path.md:50
msgid "Be sure to check other `Path` methods and the `Metadata` struct."
msgstr ""

#: src/std_misc/path.md:54
msgid ""
"[OsStr](https://doc.rust-lang.org/std/ffi/struct.OsStr.html) and [Metadata]"
"(https://doc.rust-lang.org/std/fs/struct.Metadata.html)."
msgstr ""

#: src/std_misc/file.md:3
msgid ""
"The `File` struct represents a file that has been opened (it wraps a file "
"descriptor), and gives read and/or write access to the underlying file."
msgstr ""

#: src/std_misc/file.md:6
msgid ""
"Since many things can go wrong when doing file I/O, all the `File` methods "
"return the `io::Result<T>` type, which is an alias for `Result<T, "
"io::Error>`."
msgstr ""

#: src/std_misc/file.md:9
msgid ""
"This makes the failure of all I/O operations _explicit_. Thanks to this, the "
"programmer can see all the failure paths, and is encouraged to handle them "
"in a proactive manner."
msgstr ""

#: src/std_misc/file/open.md:3
msgid "The `open` function can be used to open a file in read-only mode."
msgstr ""

#: src/std_misc/file/open.md:5
msgid ""
"A `File` owns a resource, the file descriptor and takes care of closing the "
"file when it is `drop`ed."
msgstr ""

#: src/std_misc/file/open.md:14
msgid "// Create a path to the desired file\n"
msgstr ""

#: src/std_misc/file/open.md:15
msgid "\"hello.txt\""
msgstr ""

#: src/std_misc/file/open.md:18
msgid "// Open the path in read-only mode, returns `io::Result<File>`\n"
msgstr ""

#: src/std_misc/file/open.md:20
msgid "\"couldn't open {}: {}\""
msgstr ""

#: src/std_misc/file/open.md:24
msgid "// Read the file contents into a string, returns `io::Result<usize>`\n"
msgstr ""

#: src/std_misc/file/open.md:27
msgid "\"couldn't read {}: {}\""
msgstr ""

#: src/std_misc/file/open.md:28
msgid "\"{} contains:\\n{}\""
msgstr ""

#: src/std_misc/file/open.md:31
msgid "// `file` goes out of scope, and the \"hello.txt\" file gets closed\n"
msgstr ""

#: src/std_misc/file/open.md:35 src/std_misc/file/create.md:39
#: src/std_misc/fs.md:108
msgid "Here's the expected successful output:"
msgstr ""

#: src/std_misc/file/open.md:37
msgid ""
"```shell\n"
"$ echo \"Hello World!\" > hello.txt\n"
"$ rustc open.rs && ./open\n"
"hello.txt contains:\n"
"Hello World!\n"
"```"
msgstr ""

#: src/std_misc/file/open.md:44
msgid ""
"(You are encouraged to test the previous example under different failure "
"conditions: `hello.txt` doesn't exist, or `hello.txt` is not readable, etc.)"
msgstr ""

#: src/std_misc/file/create.md:3
msgid ""
"The `create` function opens a file in write-only mode. If the file already "
"existed, the old content is destroyed. Otherwise, a new file is created."
msgstr ""

#: src/std_misc/file/create.md:9
msgid ""
"\"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod\n"
"tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim "
"veniam,\n"
"quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo\n"
"consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse\n"
"cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat "
"non\n"
"proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"
"\""
msgstr ""

#: src/std_misc/file/create.md:22
msgid "\"lorem_ipsum.txt\""
msgstr ""

#: src/std_misc/file/create.md:25
msgid "// Open a file in write-only mode, returns `io::Result<File>`\n"
msgstr ""

#: src/std_misc/file/create.md:27
msgid "\"couldn't create {}: {}\""
msgstr ""

#: src/std_misc/file/create.md:31
msgid "// Write the `LOREM_IPSUM` string to `file`, returns `io::Result<()>`\n"
msgstr ""

#: src/std_misc/file/create.md:33
msgid "\"couldn't write to {}: {}\""
msgstr ""

#: src/std_misc/file/create.md:34
msgid "\"successfully wrote to {}\""
msgstr ""

#: src/std_misc/file/create.md:54
msgid ""
"(As in the previous example, you are encouraged to test this example under "
"failure conditions.)"
msgstr ""

#: src/std_misc/file/create.md:57
msgid ""
"The [`OpenOptions`](https://doc.rust-lang.org/std/fs/"
"struct.OpenOptions.html) struct can be used to configure how a file is "
"opened."
msgstr ""

#: src/std_misc/file/read_lines.md:3
msgid "A naive approach"
msgstr ""

#: src/std_misc/file/read_lines.md:5
msgid ""
"This might be a reasonable first attempt for a beginner's first "
"implementation for reading lines from a file."
msgstr ""

#: src/std_misc/file/read_lines.md:22
msgid ""
"Since the method `lines()` returns an iterator over the lines in the file, "
"we can also perform a map inline and collect the results, yielding a more "
"concise and fluent expression."
msgstr ""

#: src/std_misc/file/read_lines.md:31
msgid "// panic on possible file-reading errors\n"
msgstr ""

#: src/std_misc/file/read_lines.md:32
msgid "// split the string into an iterator of string slices\n"
msgstr ""

#: src/std_misc/file/read_lines.md:33
msgid "// make each slice into a string\n"
msgstr ""

#: src/std_misc/file/read_lines.md:34
msgid "// gather them together into a vector\n"
msgstr ""

#: src/std_misc/file/read_lines.md:38
msgid ""
"Note that in both examples above, we must convert the `&str` reference "
"returned from `lines()` to the owned type `String`, using `.to_string()` and "
"`String::from` respectively."
msgstr ""

#: src/std_misc/file/read_lines.md:42
msgid "A more efficient approach"
msgstr ""

#: src/std_misc/file/read_lines.md:44
msgid ""
"Here we pass ownership of the open `File` to a `BufReader` struct. "
"`BufReader` uses an internal buffer to reduce intermediate allocations."
msgstr ""

#: src/std_misc/file/read_lines.md:47
msgid ""
"We also update `read_lines` to return an iterator instead of allocating new "
"`String` objects in memory for each line."
msgstr ""

#: src/std_misc/file/read_lines.md:56
msgid "// File hosts.txt must exist in the current path\n"
msgstr ""

#: src/std_misc/file/read_lines.md:57
msgid "\"./hosts.txt\""
msgstr ""

#: src/std_misc/file/read_lines.md:58
msgid "// Consumes the iterator, returns an (Optional) String\n"
msgstr ""

#: src/std_misc/file/read_lines.md:64
msgid ""
"// The output is wrapped in a Result to allow matching on errors.\n"
"// Returns an Iterator to the Reader of the lines of the file.\n"
msgstr ""

#: src/std_misc/file/read_lines.md:74
msgid "Running this program simply prints the lines individually."
msgstr ""

#: src/std_misc/file/read_lines.md:76
msgid ""
"```shell\n"
"$ echo -e \"127.0.0.1\\n192.168.0.1\\n\" > hosts.txt\n"
"$ rustc read_lines.rs && ./read_lines\n"
"127.0.0.1\n"
"192.168.0.1\n"
"```"
msgstr ""

#: src/std_misc/file/read_lines.md:83
msgid ""
"(Note that since `File::open` expects a generic `AsRef<Path>` as argument, "
"we define our generic `read_lines()` method with the same generic "
"constraint, using the `where` keyword.)"
msgstr ""

#: src/std_misc/file/read_lines.md:86
msgid ""
"This process is more efficient than creating a `String` in memory with all "
"of the file's contents. This can especially cause performance issues when "
"working with larger files."
msgstr ""

#: src/std_misc/process.md:3
msgid ""
"The `process::Output` struct represents the output of a finished child "
"process, and the `process::Command` struct is a process builder."
msgstr ""

#: src/std_misc/process.md:10
msgid "\"rustc\""
msgstr ""

#: src/std_misc/process.md:11
msgid "\"--version\""
msgstr ""

#: src/std_misc/process.md:13
msgid "\"failed to execute process: {}\""
msgstr ""

#: src/std_misc/process.md:19
msgid "\"rustc succeeded and stdout was:\\n{}\""
msgstr ""

#: src/std_misc/process.md:23
msgid "\"rustc failed and stderr was:\\n{}\""
msgstr ""

#: src/std_misc/process.md:28
msgid ""
"(You are encouraged to try the previous example with an incorrect flag "
"passed to `rustc`)"
msgstr ""

#: src/std_misc/process/pipe.md:3
msgid ""
"The `std::process::Child` struct represents a child process, and exposes the "
"`stdin`, `stdout` and `stderr` handles for interaction with the underlying "
"process via pipes."
msgstr ""

#: src/std_misc/process/pipe.md:11
msgid "\"the quick brown fox jumps over the lazy dog\\n\""
msgstr ""

#: src/std_misc/process/pipe.md:15
msgid "// Spawn the `wc` command\n"
msgstr ""

#: src/std_misc/process/pipe.md:16 src/std_misc/fs.md:12 src/std_misc/fs.md:73
#: src/std_misc/ffi.md:11
msgid "\"windows\""
msgstr ""

#: src/std_misc/process/pipe.md:17
msgid "\"powershell\""
msgstr ""

#: src/std_misc/process/pipe.md:18
msgid "\"-Command\""
msgstr ""

#: src/std_misc/process/pipe.md:18
msgid "\"$input | Measure-Object -Line -Word -Character\""
msgstr ""

#: src/std_misc/process/pipe.md:21
msgid "\"wc\""
msgstr ""

#: src/std_misc/process/pipe.md:27
msgid "\"couldn't spawn wc: {}\""
msgstr ""

#: src/std_misc/process/pipe.md:31
msgid ""
"// Write a string to the `stdin` of `wc`.\n"
"    //\n"
"    // `stdin` has type `Option<ChildStdin>`, but since we know this "
"instance\n"
"    // must have one, we can directly `unwrap` it.\n"
msgstr ""

#: src/std_misc/process/pipe.md:36
msgid "\"couldn't write to wc stdin: {}\""
msgstr ""

#: src/std_misc/process/pipe.md:37
msgid "\"sent pangram to wc\""
msgstr ""

#: src/std_misc/process/pipe.md:40
msgid ""
"// Because `stdin` does not live after the above calls, it is `drop`ed,\n"
"    // and the pipe is closed.\n"
"    //\n"
"    // This is very important, otherwise `wc` wouldn't start processing the\n"
"    // input we just sent.\n"
msgstr ""

#: src/std_misc/process/pipe.md:46
msgid ""
"// The `stdout` field also has type `Option<ChildStdout>` so must be "
"unwrapped.\n"
msgstr ""

#: src/std_misc/process/pipe.md:49
msgid "\"couldn't read wc stdout: {}\""
msgstr ""

#: src/std_misc/process/pipe.md:50
msgid "\"wc responded with:\\n{}\""
msgstr ""

#: src/std_misc/process/wait.md:3
msgid ""
"If you'd like to wait for a `process::Child` to finish, you must call "
"`Child::wait`, which will return a `process::ExitStatus`."
msgstr ""

#: src/std_misc/process/wait.md:10
msgid "\"sleep\""
msgstr ""

#: src/std_misc/process/wait.md:13
msgid "\"reached end of main\""
msgstr ""

#: src/std_misc/process/wait.md:18
msgid ""
"# `wait` keeps running for 5 seconds until the `sleep 5` command finishes\n"
msgstr ""

#: src/std_misc/fs.md:3
msgid ""
"The `std::fs` module contains several functions that deal with the "
"filesystem."
msgstr ""

#: src/std_misc/fs.md:10 src/std_misc/fs.md:68 src/std_misc/ffi.md:20
msgid "\"unix\""
msgstr ""

#: src/std_misc/fs.md:15
msgid "// A simple implementation of `% cat path`\n"
msgstr ""

#: src/std_misc/fs.md:25
msgid "// A simple implementation of `% echo s > path`\n"
msgstr ""

#: src/std_misc/fs.md:32
msgid "// A simple implementation of `% touch path` (ignores existing files)\n"
msgstr ""

#: src/std_misc/fs.md:42
msgid "\"`mkdir a`\""
msgstr ""

#: src/std_misc/fs.md:43
msgid "// Create a directory, returns `io::Result<()>`\n"
msgstr ""

#: src/std_misc/fs.md:45 src/std_misc/fs.md:52 src/std_misc/fs.md:58
#: src/std_misc/fs.md:63 src/std_misc/fs.md:70 src/std_misc/fs.md:75
#: src/std_misc/fs.md:81 src/std_misc/fs.md:88 src/std_misc/fs.md:97
#: src/std_misc/fs.md:103
msgid "\"! {:?}\""
msgstr ""

#: src/std_misc/fs.md:49
msgid "\"`echo hello > a/b.txt`\""
msgstr ""

#: src/std_misc/fs.md:50
msgid ""
"// The previous match can be simplified using the `unwrap_or_else` method\n"
msgstr ""

#: src/std_misc/fs.md:51
msgid "\"a/b.txt\""
msgstr ""

#: src/std_misc/fs.md:55
msgid "\"`mkdir -p a/c/d`\""
msgstr ""

#: src/std_misc/fs.md:56
msgid "// Recursively create a directory, returns `io::Result<()>`\n"
msgstr ""

#: src/std_misc/fs.md:57 src/std_misc/fs.md:102
msgid "\"a/c/d\""
msgstr ""

#: src/std_misc/fs.md:61
msgid "\"`touch a/c/e.txt`\""
msgstr ""

#: src/std_misc/fs.md:62 src/std_misc/fs.md:96
msgid "\"a/c/e.txt\""
msgstr ""

#: src/std_misc/fs.md:66
msgid "\"`ln -s ../b.txt a/c/b.txt`\""
msgstr ""

#: src/std_misc/fs.md:67
msgid "// Create a symbolic link, returns `io::Result<()>`\n"
msgstr ""

#: src/std_misc/fs.md:69 src/std_misc/fs.md:74
msgid "\"../b.txt\""
msgstr ""

#: src/std_misc/fs.md:69 src/std_misc/fs.md:74 src/std_misc/fs.md:80
msgid "\"a/c/b.txt\""
msgstr ""

#: src/std_misc/fs.md:79
msgid "\"`cat a/c/b.txt`\""
msgstr ""

#: src/std_misc/fs.md:85
msgid "\"`ls a`\""
msgstr ""

#: src/std_misc/fs.md:86
msgid "// Read the contents of a directory, returns `io::Result<Vec<Path>>`\n"
msgstr ""

#: src/std_misc/fs.md:94
msgid "\"`rm a/c/e.txt`\""
msgstr ""

#: src/std_misc/fs.md:95
msgid "// Remove a file, returns `io::Result<()>`\n"
msgstr ""

#: src/std_misc/fs.md:100
msgid "\"`rmdir a/c/d`\""
msgstr ""

#: src/std_misc/fs.md:101
msgid "// Remove an empty directory, returns `io::Result<()>`\n"
msgstr ""

#: src/std_misc/fs.md:110
msgid ""
"```shell\n"
"$ rustc fs.rs && ./fs\n"
"`mkdir a`\n"
"`echo hello > a/b.txt`\n"
"`mkdir -p a/c/d`\n"
"`touch a/c/e.txt`\n"
"`ln -s ../b.txt a/c/b.txt`\n"
"`cat a/c/b.txt`\n"
"> hello\n"
"`ls a`\n"
"> \"a/b.txt\"\n"
"> \"a/c\"\n"
"`rm a/c/e.txt`\n"
"`rmdir a/c/d`\n"
"```"
msgstr ""

#: src/std_misc/fs.md:126
msgid "And the final state of the `a` directory is:"
msgstr ""

#: src/std_misc/fs.md:138
msgid "An alternative way to define the function `cat` is with `?` notation:"
msgstr ""

#: src/std_misc/fs.md:151
msgid "[`cfg!`](../attribute/cfg.md)"
msgstr ""

#: src/std_misc/arg.md:3
msgid "Standard Library"
msgstr ""

#: src/std_misc/arg.md:5
msgid ""
"The command line arguments can be accessed using `std::env::args`, which "
"returns an iterator that yields a `String` for each argument:"
msgstr ""

#: src/std_misc/arg.md:14
msgid "// The first argument is the path that was used to call the program.\n"
msgstr ""

#: src/std_misc/arg.md:15
msgid "\"My path is {}.\""
msgstr ""

#: src/std_misc/arg.md:17
msgid ""
"// The rest of the arguments are the passed command line parameters.\n"
"    // Call the program like this:\n"
"    //   $ ./args arg1 arg2\n"
msgstr ""

#: src/std_misc/arg.md:20
msgid "\"I got {:?} arguments: {:?}.\""
msgstr ""

#: src/std_misc/arg.md:24
msgid ""
"```shell\n"
"$ ./args 1 2 3\n"
"My path is ./args.\n"
"I got 3 arguments: [\"1\", \"2\", \"3\"].\n"
"```"
msgstr ""

#: src/std_misc/arg.md:32
msgid ""
"Alternatively, there are numerous crates that can provide extra "
"functionality when creating command-line applications. One of the more "
"popular command line argument crates being [`clap`](https://rust-"
"cli.github.io/book/tutorial/cli-args.html#parsing-cli-arguments-with-clap)."
msgstr ""

#: src/std_misc/arg/matching.md:3
msgid "Matching can be used to parse simple arguments:"
msgstr ""

#: src/std_misc/arg/matching.md:17
msgid ""
"\"usage:\n"
"match_args <string>\n"
"    Check whether given string is the answer.\n"
"match_args {{increase|decrease}} <integer>\n"
"    Increase or decrease given integer by one.\""
msgstr ""

#: src/std_misc/arg/matching.md:28
msgid "// no arguments passed\n"
msgstr ""

#: src/std_misc/arg/matching.md:30
msgid "\"My name is 'match_args'. Try passing some arguments!\""
msgstr ""

#: src/std_misc/arg/matching.md:32
msgid "// one argument passed\n"
msgstr ""

#: src/std_misc/arg/matching.md:35
msgid "\"This is the answer!\""
msgstr ""

#: src/std_misc/arg/matching.md:36
msgid "\"This is not the answer.\""
msgstr ""

#: src/std_misc/arg/matching.md:39
msgid "// one command and one argument passed\n"
msgstr ""

#: src/std_misc/arg/matching.md:43
msgid "// parse the number\n"
msgstr ""

#: src/std_misc/arg/matching.md:49
msgid "\"error: second argument not an integer\""
msgstr ""

#: src/std_misc/arg/matching.md:54
msgid "// parse the command\n"
msgstr ""

#: src/std_misc/arg/matching.md:56
msgid "\"increase\""
msgstr ""

#: src/std_misc/arg/matching.md:57
msgid "\"decrease\""
msgstr ""

#: src/std_misc/arg/matching.md:59
msgid "\"error: invalid command\""
msgstr ""

#: src/std_misc/arg/matching.md:64
msgid "// all the other cases\n"
msgstr ""

#: src/std_misc/arg/matching.md:66
msgid "// show a help message\n"
msgstr ""

#: src/std_misc/arg/matching.md:73
msgid ""
"If you named your program `match_args.rs` and compile it like this `rustc "
"match_args.rs`, you can execute it as follows:"
msgstr ""

#: src/std_misc/ffi.md:3
msgid ""
"Rust provides a Foreign Function Interface (FFI) to C libraries. Foreign "
"functions must be declared inside an `extern` block annotated with a "
"`#[link]` attribute containing the name of the foreign library."
msgstr ""

#: src/std_misc/ffi.md:9
msgid "// this extern block links to the libm library\n"
msgstr ""

#: src/std_misc/ffi.md:12
msgid "\"msvcrt\""
msgstr ""

#: src/std_misc/ffi.md:14 src/std_misc/ffi.md:23
msgid ""
"// this is a foreign function\n"
"    // that computes the square root of a single precision complex number\n"
msgstr ""

#: src/std_misc/ffi.md:21
msgid "\"m\""
msgstr ""

#: src/std_misc/ffi.md:29
msgid ""
"// Since calling foreign functions is considered unsafe,\n"
"// it's common to write safe wrappers around them.\n"
msgstr ""

#: src/std_misc/ffi.md:37
msgid "// z = -1 + 0i\n"
msgstr ""

#: src/std_misc/ffi.md:40
msgid "// calling a foreign function is an unsafe operation\n"
msgstr ""

#: src/std_misc/ffi.md:43
msgid "\"the square root of {:?} is {:?}\""
msgstr ""

#: src/std_misc/ffi.md:45
msgid "// calling safe API wrapped around unsafe operation\n"
msgstr ""

#: src/std_misc/ffi.md:46
msgid "\"cos({:?}) = {:?}\""
msgstr ""

#: src/std_misc/ffi.md:48
msgid "// Minimal implementation of single precision complex numbers\n"
msgstr ""

#: src/std_misc/ffi.md:60
msgid "\"{}-{}i\""
msgstr ""

#: src/std_misc/ffi.md:62
msgid "\"{}+{}i\""
msgstr ""

#: src/testing.md:3
msgid ""
"Rust is a programming language that cares a lot about correctness and it "
"includes support for writing software tests within the language itself."
msgstr ""

#: src/testing.md:6
msgid "Testing comes in three styles:"
msgstr ""

#: src/testing.md:8
msgid "[Unit](testing/unit_testing.md) testing."
msgstr ""

#: src/testing.md:9
msgid "[Doc](testing/doc_testing.md) testing."
msgstr ""

#: src/testing.md:10
msgid "[Integration](testing/integration_testing.md) testing."
msgstr ""

#: src/testing.md:12
msgid "Also Rust has support for specifying additional dependencies for tests:"
msgstr ""

#: src/testing.md:14
msgid "[Dev-dependencies](testing/dev_dependencies.md)"
msgstr ""

#: src/testing.md:18
msgid ""
"[The Book](https://doc.rust-lang.org/book/ch11-00-testing.html) chapter on "
"testing"
msgstr ""

#: src/testing.md:19
msgid ""
"[API Guidelines](https://rust-lang-nursery.github.io/api-guidelines/"
"documentation.html) on doc-testing"
msgstr ""

#: src/testing/unit_testing.md:3
msgid ""
"Tests are Rust functions that verify that the non-test code is functioning "
"in the expected manner. The bodies of test functions typically perform some "
"setup, run the code we want to test, then assert whether the results are "
"what we expect."
msgstr ""

#: src/testing/unit_testing.md:8
msgid ""
"Most unit tests go into a `tests` [mod](../mod.md) with the `#[cfg(test)]` "
"[attribute](../attribute.md). Test functions are marked with the `#[test]` "
"attribute."
msgstr ""

#: src/testing/unit_testing.md:11
msgid ""
"Tests fail when something in the test function [panics](../std/panic.md). "
"There are some helper [macros](../macros.md):"
msgstr ""

#: src/testing/unit_testing.md:14
msgid "`assert!(expression)` - panics if expression evaluates to `false`."
msgstr ""

#: src/testing/unit_testing.md:15
msgid ""
"`assert_eq!(left, right)` and `assert_ne!(left, right)` - testing left and "
"right expressions for equality and inequality respectively."
msgstr ""

#: src/testing/unit_testing.md:22
msgid ""
"// This is a really bad adding function, its purpose is to fail in this\n"
"// example.\n"
msgstr ""

#: src/testing/unit_testing.md:32
msgid ""
"// Note this useful idiom: importing names from outer (for mod tests) "
"scope.\n"
msgstr ""

#: src/testing/unit_testing.md:42
msgid ""
"// This assert would fire and test will fail.\n"
"        // Please note, that private functions can be tested too!\n"
msgstr ""

#: src/testing/unit_testing.md:49
msgid "Tests can be run with `cargo test`."
msgstr ""

#: src/testing/unit_testing.md:73
msgid "Tests and `?`"
msgstr ""

#: src/testing/unit_testing.md:75
msgid ""
"None of the previous unit test examples had a return type. But in Rust 2018, "
"your unit tests can return `Result<()>`, which lets you use `?` in them! "
"This can make them much more concise."
msgstr ""

#: src/testing/unit_testing.md:84
msgid "\"negative floats don't have square roots\""
msgstr ""

#: src/testing/unit_testing.md:101
msgid ""
"See [\"The Edition Guide\"](https://doc.rust-lang.org/edition-guide/"
"rust-2018/error-handling-and-panics/question-mark-in-main-and-tests.html) "
"for more details."
msgstr ""

#: src/testing/unit_testing.md:103
msgid "Testing panics"
msgstr ""

#: src/testing/unit_testing.md:105
msgid ""
"To check functions that should panic under certain circumstances, use "
"attribute `#[should_panic]`. This attribute accepts optional parameter "
"`expected = ` with the text of the panic message. If your function can panic "
"in multiple ways, it helps make sure your test is testing the correct panic."
msgstr ""

#: src/testing/unit_testing.md:110
msgid ""
"**Note**: Rust also allows a shorthand form `#[should_panic = \"message\"]`, "
"which works exactly like `#[should_panic(expected = \"message\")]`. Both are "
"valid; the latter is more commonly used and is considered more explicit."
msgstr ""

#: src/testing/unit_testing.md:117 src/testing/doc_testing.md:46
msgid "\"Divide-by-zero error\""
msgstr ""

#: src/testing/unit_testing.md:119 src/testing/unit_testing.md:140
#: src/testing/unit_testing.md:146
msgid "\"Divide result is zero\""
msgstr ""

#: src/testing/unit_testing.md:146
msgid "// This also works\n"
msgstr ""

#: src/testing/unit_testing.md:153
msgid "Running these tests gives us:"
msgstr ""

#: src/testing/unit_testing.md:173
msgid "Running specific tests"
msgstr ""

#: src/testing/unit_testing.md:175
msgid ""
"To run specific tests one may specify the test name to `cargo test` command."
msgstr ""

#: src/testing/unit_testing.md:191
msgid ""
"To run multiple tests one may specify part of a test name that matches all "
"the tests that should be run."
msgstr ""

#: src/testing/unit_testing.md:210
msgid "Ignoring tests"
msgstr ""

#: src/testing/unit_testing.md:212
msgid ""
"Tests can be marked with the `#[ignore]` attribute to exclude some tests. Or "
"to run them with command `cargo test -- --ignored`"
msgstr ""

#: src/testing/doc_testing.md:3
msgid ""
"The primary way of documenting a Rust project is through annotating the "
"source code. Documentation comments are written in [CommonMark Markdown "
"specification](https://commonmark.org/) and support code blocks in them. "
"Rust takes care about correctness, so these code blocks are compiled and "
"used as documentation tests."
msgstr ""

#: src/testing/doc_testing.md:10
msgid ""
"/// First line is a short summary describing function.\n"
"///\n"
"/// The next lines present detailed documentation. Code blocks start with\n"
"/// triple backquotes and have implicit `fn main()` inside\n"
"/// and `extern crate <cratename>`. Assume we're testing a `playground` "
"library\n"
"/// crate or using the Playground's Test action:\n"
"///\n"
"/// ```\n"
"/// let result = playground::add(2, 3);\n"
"/// assert_eq!(result, 5);\n"
"/// ```\n"
msgstr ""

#: src/testing/doc_testing.md:24
msgid ""
"/// Usually doc comments may include sections \"Examples\", \"Panics\" and "
"\"Failures\".\n"
"///\n"
"/// The next function divides two numbers.\n"
"///\n"
"/// # Examples\n"
"///\n"
"/// ```\n"
"/// let result = playground::div(10, 2);\n"
"/// assert_eq!(result, 5);\n"
"/// ```\n"
"///\n"
"/// # Panics\n"
"///\n"
"/// The function panics if the second argument is zero.\n"
"///\n"
"/// ```rust,should_panic\n"
"/// // panics on division by zero\n"
"/// playground::div(10, 0);\n"
"/// ```\n"
msgstr ""

#: src/testing/doc_testing.md:53
msgid ""
"Code blocks in documentation are automatically tested when running the "
"regular `cargo test` command:"
msgstr ""

#: src/testing/doc_testing.md:72
msgid "Motivation behind documentation tests"
msgstr ""

#: src/testing/doc_testing.md:74
msgid ""
"The main purpose of documentation tests is to serve as examples that "
"exercise the functionality, which is one of the most important [guidelines]"
"(https://rust-lang-nursery.github.io/api-guidelines/"
"documentation.html#examples-use--not-try-not-unwrap-c-question-mark). It "
"allows using examples from docs as complete code snippets. But using `?` "
"makes compilation fail since `main` returns `unit`. The ability to hide some "
"source lines from documentation comes to the rescue: one may write `fn "
"try_main() -> Result<(), ErrorType>`, hide it and `unwrap` it in hidden "
"`main`. Sounds complicated? Here's an example:"
msgstr ""

#: src/testing/doc_testing.md:83
msgid ""
"/// Using hidden `try_main` in doc tests.\n"
"///\n"
"/// ```\n"
"/// # // hidden lines start with `#` symbol, but they're still compilable!\n"
"/// # fn try_main() -> Result<(), String> { // line that wraps the body "
"shown in doc\n"
"/// let res = playground::try_div(10, 2)?;\n"
"/// # Ok(()) // returning from try_main\n"
"/// # }\n"
"/// # fn main() { // starting main that'll unwrap()\n"
"/// #    try_main().unwrap(); // calling try_main and unwrapping\n"
"/// #                         // so that test will panic in case of error\n"
"/// # }\n"
"/// ```\n"
msgstr ""

#: src/testing/doc_testing.md:98
msgid "\"Divide-by-zero\""
msgstr ""

#: src/testing/doc_testing.md:107
msgid ""
"[RFC505](https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-"
"conventions.md) on documentation style"
msgstr ""

#: src/testing/doc_testing.md:108
msgid ""
"[API Guidelines](https://rust-lang-nursery.github.io/api-guidelines/"
"documentation.html) on documentation guidelines"
msgstr ""

#: src/testing/integration_testing.md:3
msgid ""
"[Unit tests](unit_testing.md) are testing one module in isolation at a time: "
"they're small and can test private code. Integration tests are external to "
"your crate and use only its public interface in the same way any other code "
"would. Their purpose is to test that many parts of your library work "
"correctly together."
msgstr ""

#: src/testing/integration_testing.md:8
msgid "Cargo looks for integration tests in `tests` directory next to `src`."
msgstr ""

#: src/testing/integration_testing.md:10 src/testing/dev_dependencies.md:17
msgid "File `src/lib.rs`:"
msgstr ""

#: src/testing/integration_testing.md:13
msgid "// Define this in a crate called `adder`.\n"
msgstr ""

#: src/testing/integration_testing.md:19
msgid "File with test: `tests/integration_test.rs`:"
msgstr ""

#: src/testing/integration_testing.md:28
msgid "Running tests with `cargo test` command:"
msgstr ""

#: src/testing/integration_testing.md:50
msgid ""
"Each Rust source file in the `tests` directory is compiled as a separate "
"crate. In order to share some code between integration tests we can make a "
"module with public functions, importing and using it within tests."
msgstr ""

#: src/testing/integration_testing.md:54
msgid "File `tests/common/mod.rs`:"
msgstr ""

#: src/testing/integration_testing.md:58
msgid ""
"// some setup code, like creating required files/directories, starting\n"
"    // servers, etc.\n"
msgstr ""

#: src/testing/integration_testing.md:63
msgid "File with test: `tests/integration_test.rs`"
msgstr ""

#: src/testing/integration_testing.md:66
msgid "// importing common module.\n"
msgstr ""

#: src/testing/integration_testing.md:71
msgid "// using common code.\n"
msgstr ""

#: src/testing/integration_testing.md:77
msgid ""
"Creating the module as `tests/common.rs` also works, but is not recommended "
"because the test runner will treat the file as a test crate and try to run "
"tests inside it."
msgstr ""

#: src/testing/dev_dependencies.md:1
msgid "Development dependencies"
msgstr ""

#: src/testing/dev_dependencies.md:3
msgid ""
"Sometimes there is a need to have dependencies for tests (or examples, or "
"benchmarks) only. Such dependencies are added to `Cargo.toml` in the `[dev-"
"dependencies]` section. These dependencies are not propagated to other "
"packages which depend on this package."
msgstr ""

#: src/testing/dev_dependencies.md:8
msgid ""
"One such example is [`pretty_assertions`](https://docs.rs/pretty_assertions/"
"1.0.0/pretty_assertions/index.html), which extends standard `assert_eq!` and "
"`assert_ne!` macros, to provide colorful diff. File `Cargo.toml`:"
msgstr ""

#: src/testing/dev_dependencies.md:11
msgid ""
"```toml\n"
"# standard crate data is left out\n"
"[dev-dependencies]\n"
"pretty_assertions = \"1\"\n"
"```"
msgstr ""

#: src/testing/dev_dependencies.md:27
msgid "// crate for test-only use. Cannot be used in non-test code.\n"
msgstr ""

#: src/testing/dev_dependencies.md:38
msgid ""
"[Cargo](http://doc.crates.io/specifying-dependencies.html) docs on "
"specifying dependencies."
msgstr ""

#: src/unsafe.md:3
msgid ""
"As an introduction to this section, to borrow from [the official docs]"
"(https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html), \"one should try "
"to minimize the amount of unsafe code in a code base.\" With that in mind, "
"let's get started! Unsafe annotations in Rust are used to bypass protections "
"put in place by the compiler; specifically, there are four primary things "
"that unsafe is used for:"
msgstr ""

#: src/unsafe.md:9
msgid "dereferencing raw pointers"
msgstr ""

#: src/unsafe.md:10
msgid ""
"calling functions or methods which are `unsafe` (including calling a "
"function over FFI, see [a previous chapter](std_misc/ffi.md) of the book)"
msgstr ""

#: src/unsafe.md:12
msgid "accessing or modifying static mutable variables"
msgstr ""

#: src/unsafe.md:13
msgid "implementing unsafe traits"
msgstr ""

#: src/unsafe.md:15
msgid "Raw Pointers"
msgstr ""

#: src/unsafe.md:17
msgid ""
"Raw pointers `*` and references `&T` function similarly, but references are "
"always safe because they are guaranteed to point to valid data due to the "
"borrow checker. Dereferencing a raw pointer can only be done through an "
"unsafe block."
msgstr ""

#: src/unsafe.md:32
msgid "Calling Unsafe Functions"
msgstr ""

#: src/unsafe.md:34
msgid ""
"Some functions can be declared as `unsafe`, meaning it is the programmer's "
"responsibility to ensure correctness instead of the compiler's. One example "
"of this is [`std::slice::from_raw_parts`](https://doc.rust-lang.org/std/"
"slice/fn.from_raw_parts.html) which will create a slice given a pointer to "
"the first element and a length."
msgstr ""

#: src/unsafe.md:56
msgid ""
"For `slice::from_raw_parts`, one of the assumptions which _must_ be upheld "
"is that the pointer passed in points to valid memory and that the memory "
"pointed to is of the correct type. If these invariants aren't upheld then "
"the program's behaviour is undefined and there is no knowing what will "
"happen."
msgstr ""

#: src/unsafe/asm.md:3
msgid ""
"Rust provides support for inline assembly via the `asm!` macro. It can be "
"used to embed handwritten assembly in the assembly output generated by the "
"compiler. Generally this should not be necessary, but might be where the "
"required performance or timing cannot be otherwise achieved. Accessing low "
"level hardware primitives, e.g. in kernel code, may also demand this "
"functionality."
msgstr ""

#: src/unsafe/asm.md:8
msgid ""
"**Note**: the examples here are given in x86/x86-64 assembly, but other "
"architectures are also supported."
msgstr ""

#: src/unsafe/asm.md:10
msgid "Inline assembly is currently supported on the following architectures:"
msgstr ""

#: src/unsafe/asm.md:12
msgid "x86 and x86-64"
msgstr ""

#: src/unsafe/asm.md:13
msgid "ARM"
msgstr ""

#: src/unsafe/asm.md:14
msgid "AArch64"
msgstr ""

#: src/unsafe/asm.md:15
msgid "RISC-V"
msgstr ""

#: src/unsafe/asm.md:17
msgid "Basic usage"
msgstr ""

#: src/unsafe/asm.md:19
msgid "Let us start with the simplest possible example:"
msgstr ""

#: src/unsafe/asm.md:22 src/unsafe/asm.md:42 src/unsafe/asm.md:69
#: src/unsafe/asm.md:107 src/unsafe/asm.md:124 src/unsafe/asm.md:149
#: src/unsafe/asm.md:183 src/unsafe/asm.md:204 src/unsafe/asm.md:221
#: src/unsafe/asm.md:260 src/unsafe/asm.md:296 src/unsafe/asm.md:312
#: src/unsafe/asm.md:338 src/unsafe/asm.md:376 src/unsafe/asm.md:403
#: src/unsafe/asm.md:427 src/unsafe/asm.md:465
msgid "\"x86_64\""
msgstr ""

#: src/unsafe/asm.md:26
msgid "\"nop\""
msgstr ""

#: src/unsafe/asm.md:31
msgid ""
"This will insert a NOP (no operation) instruction into the assembly "
"generated by the compiler. Note that all `asm!` invocations have to be "
"inside an `unsafe` block, as they could insert arbitrary instructions and "
"break various invariants. The instructions to be inserted are listed in the "
"first argument of the `asm!` macro as a string literal."
msgstr ""

#: src/unsafe/asm.md:36
msgid "Inputs and outputs"
msgstr ""

#: src/unsafe/asm.md:38
msgid ""
"Now inserting an instruction that does nothing is rather boring. Let us do "
"something that actually acts on data:"
msgstr ""

#: src/unsafe/asm.md:47
msgid "\"mov {}, 5\""
msgstr ""

#: src/unsafe/asm.md:53
msgid ""
"This will write the value `5` into the `u64` variable `x`. You can see that "
"the string literal we use to specify instructions is actually a template "
"string. It is governed by the same rules as Rust [format strings](https://"
"doc.rust-lang.org/std/fmt/#syntax). The arguments that are inserted into the "
"template however look a bit different than you may be familiar with. First "
"we need to specify if the variable is an input or an output of the inline "
"assembly. In this case it is an output. We declared this by writing `out`. "
"We also need to specify in what kind of register the assembly expects the "
"variable. In this case we put it in an arbitrary general purpose register by "
"specifying `reg`. The compiler will choose an appropriate register to insert "
"into the template and will read the variable from there after the inline "
"assembly finishes executing."
msgstr ""

#: src/unsafe/asm.md:66
msgid "Let us see another example that also uses an input:"
msgstr ""

#: src/unsafe/asm.md:76
msgid "\"mov {0}, {1}\""
msgstr ""

#: src/unsafe/asm.md:77 src/unsafe/asm.md:112 src/unsafe/asm.md:130
msgid "\"add {0}, 5\""
msgstr ""

#: src/unsafe/asm.md:86
msgid ""
"This will add `5` to the input in variable `i` and write the result to "
"variable `o`. The particular way this assembly does this is first copying "
"the value from `i` to the output, and then adding `5` to it."
msgstr ""

#: src/unsafe/asm.md:90
msgid "The example shows a few things:"
msgstr ""

#: src/unsafe/asm.md:92
msgid ""
"First, we can see that `asm!` allows multiple template string arguments; "
"each one is treated as a separate line of assembly code, as if they were all "
"joined together with newlines between them. This makes it easy to format "
"assembly code."
msgstr ""

#: src/unsafe/asm.md:97
msgid ""
"Second, we can see that inputs are declared by writing `in` instead of `out`."
msgstr ""

#: src/unsafe/asm.md:99
msgid ""
"Third, we can see that we can specify an argument number, or name as in any "
"format string. For inline assembly templates this is particularly useful as "
"arguments are often used more than once. For more complex inline assembly "
"using this facility is generally recommended, as it improves readability, "
"and allows reordering instructions without changing the argument order."
msgstr ""

#: src/unsafe/asm.md:104
msgid "We can further refine the above example to avoid the `mov` instruction:"
msgstr ""

#: src/unsafe/asm.md:118
msgid ""
"We can see that `inout` is used to specify an argument that is both input "
"and output. This is different from specifying an input and output separately "
"in that it is guaranteed to assign both to the same register."
msgstr ""

#: src/unsafe/asm.md:121
msgid ""
"It is also possible to specify different variables for the input and output "
"parts of an `inout` operand:"
msgstr ""

#: src/unsafe/asm.md:136
msgid "Late output operands"
msgstr ""

#: src/unsafe/asm.md:138
msgid ""
"The Rust compiler is conservative with its allocation of operands. It is "
"assumed that an `out` can be written at any time, and can therefore not "
"share its location with any other argument. However, to guarantee optimal "
"performance it is important to use as few registers as possible, so they "
"won't have to be saved and reloaded around the inline assembly block. To "
"achieve this Rust provides a `lateout` specifier. This can be used on any "
"output that is written only after all inputs have been consumed. There is "
"also an `inlateout` variant of this specifier."
msgstr ""

#: src/unsafe/asm.md:146
msgid ""
"Here is an example where `inlateout` _cannot_ be used in `release` mode or "
"other optimized cases:"
msgstr ""

#: src/unsafe/asm.md:157 src/unsafe/asm.md:189 src/unsafe/asm.md:472
msgid "\"add {0}, {1}\""
msgstr ""

#: src/unsafe/asm.md:158
msgid "\"add {0}, {2}\""
msgstr ""

#: src/unsafe/asm.md:168
msgid ""
"In unoptimized cases (e.g. `Debug` mode), replacing `inout(reg) a` with "
"`inlateout(reg) a` in the above example can continue to give the expected "
"result. However, with `release` mode or other optimized cases, using "
"`inlateout(reg) a` can instead lead to the final value `a = 16`, causing the "
"assertion to fail."
msgstr ""

#: src/unsafe/asm.md:173
msgid ""
"This is because in optimized cases, the compiler is free to allocate the "
"same register for inputs `b` and `c` since it knows that they have the same "
"value. Furthermore, when `inlateout` is used, `a` and `c` could be allocated "
"to the same register, in which case the first `add` instruction would "
"overwrite the initial load from variable `c`. This is in contrast to how "
"using `inout(reg) a` ensures a separate register is allocated for `a`."
msgstr ""

#: src/unsafe/asm.md:179
msgid ""
"However, the following example can use `inlateout` since the output is only "
"modified after all input registers have been read:"
msgstr ""

#: src/unsafe/asm.md:195
msgid ""
"As you can see, this assembly fragment will still work correctly if `a` and "
"`b` are assigned to the same register."
msgstr ""

#: src/unsafe/asm.md:197
msgid "Explicit register operands"
msgstr ""

#: src/unsafe/asm.md:199
msgid ""
"Some instructions require that the operands be in a specific register. "
"Therefore, Rust inline assembly provides some more specific constraint "
"specifiers. While `reg` is generally available on any architecture, explicit "
"registers are highly architecture specific. E.g. for x86 the general purpose "
"registers `eax`, `ebx`, `ecx`, `edx`, `ebp`, `esi`, and `edi` among others "
"can be addressed by their name."
msgstr ""

#: src/unsafe/asm.md:209
msgid "\"out 0x64, eax\""
msgstr ""

#: src/unsafe/asm.md:209 src/unsafe/asm.md:285
msgid "\"eax\""
msgstr ""

#: src/unsafe/asm.md:214
msgid ""
"In this example we call the `out` instruction to output the content of the "
"`cmd` variable to port `0x64`. Since the `out` instruction only accepts "
"`eax` (and its sub registers) as operand we had to use the `eax` constraint "
"specifier."
msgstr ""

#: src/unsafe/asm.md:216
msgid ""
"**Note**: unlike other operand types, explicit register operands cannot be "
"used in the template string: you can't use `{}` and should write the "
"register name directly instead. Also, they must appear at the end of the "
"operand list after all other operand types."
msgstr ""

#: src/unsafe/asm.md:218
msgid "Consider this example which uses the x86 `mul` instruction:"
msgstr ""

#: src/unsafe/asm.md:230
msgid ""
"// The x86 mul instruction takes rax as an implicit input and writes\n"
"            // the 128-bit result of the multiplication to rax:rdx.\n"
"            \"mul {}\""
msgstr ""

#: src/unsafe/asm.md:234 src/unsafe/asm.md:356
msgid "\"rax\""
msgstr ""

#: src/unsafe/asm.md:235
msgid "\"rdx\""
msgstr ""

#: src/unsafe/asm.md:244
msgid ""
"This uses the `mul` instruction to multiply two 64-bit inputs with a 128-bit "
"result. The only explicit operand is a register, that we fill from the "
"variable `a`. The second operand is implicit, and must be the `rax` "
"register, which we fill from the variable `b`. The lower 64 bits of the "
"result are stored in `rax` from which we fill the variable `lo`. The higher "
"64 bits are stored in `rdx` from which we fill the variable `hi`."
msgstr ""

#: src/unsafe/asm.md:250
msgid "Clobbered registers"
msgstr ""

#: src/unsafe/asm.md:252
msgid ""
"In many cases inline assembly will modify state that is not needed as an "
"output. Usually this is either because we have to use a scratch register in "
"the assembly or because instructions modify state that we don't need to "
"further examine. This state is generally referred to as being \"clobbered\". "
"We need to tell the compiler about this since it may need to save and "
"restore this state around the inline assembly block."
msgstr ""

#: src/unsafe/asm.md:262
msgid "// three entries of four bytes each\n"
msgstr ""

#: src/unsafe/asm.md:264
msgid ""
"// String is stored as ascii in ebx, edx, ecx in order\n"
"    // Because ebx is reserved, the asm needs to preserve the value of it.\n"
"    // So we push and pop it around the main asm.\n"
"    // 64 bit mode on 64 bit processors does not allow pushing/popping of\n"
"    // 32 bit registers (like ebx), so we have to use the extended rbx "
"register instead.\n"
msgstr ""

#: src/unsafe/asm.md:272
msgid "\"push rbx\""
msgstr ""

#: src/unsafe/asm.md:273
msgid "\"cpuid\""
msgstr ""

#: src/unsafe/asm.md:274
msgid "\"mov [rdi], ebx\""
msgstr ""

#: src/unsafe/asm.md:275
msgid "\"mov [rdi + 4], edx\""
msgstr ""

#: src/unsafe/asm.md:276
msgid "\"mov [rdi + 8], ecx\""
msgstr ""

#: src/unsafe/asm.md:277
msgid "\"pop rbx\""
msgstr ""

#: src/unsafe/asm.md:278
msgid ""
"// We use a pointer to an array for storing the values to simplify\n"
"            // the Rust code at the cost of a couple more asm instructions\n"
"            // This is more explicit with how the asm works however, as "
"opposed\n"
"            // to explicit register outputs such as `out(\"ecx\") val`\n"
"            // The *pointer itself* is only an input even though it's "
"written behind\n"
msgstr ""

#: src/unsafe/asm.md:283 src/unsafe/asm.md:354
msgid "\"rdi\""
msgstr ""

#: src/unsafe/asm.md:284
msgid "// select cpuid 0, also specify eax as clobbered\n"
msgstr ""

#: src/unsafe/asm.md:286
msgid "// cpuid clobbers these registers too\n"
msgstr ""

#: src/unsafe/asm.md:287
msgid "\"ecx\""
msgstr ""

#: src/unsafe/asm.md:288
msgid "\"edx\""
msgstr ""

#: src/unsafe/asm.md:293
msgid "\"CPU Manufacturer ID: {}\""
msgstr ""

#: src/unsafe/asm.md:300
msgid ""
"In the example above we use the `cpuid` instruction to read the CPU "
"manufacturer ID. This instruction writes to `eax` with the maximum supported "
"`cpuid` argument and `ebx`, `edx`, and `ecx` with the CPU manufacturer ID as "
"ASCII bytes in that order."
msgstr ""

#: src/unsafe/asm.md:303
msgid ""
"Even though `eax` is never read we still need to tell the compiler that the "
"register has been modified so that the compiler can save any values that "
"were in these registers before the asm. This is done by declaring it as an "
"output but with `_` instead of a variable name, which indicates that the "
"output value is to be discarded."
msgstr ""

#: src/unsafe/asm.md:305
msgid ""
"This code also works around the limitation that `ebx` is a reserved register "
"by LLVM. That means that LLVM assumes that it has full control over the "
"register and it must be restored to its original state before exiting the "
"asm block, so it cannot be used as an input or output **except** if the "
"compiler uses it to fulfill a general register class (e.g. `in(reg)`). This "
"makes `reg` operands dangerous when using reserved registers as we could "
"unknowingly corrupt our input or output because they share the same register."
msgstr ""

#: src/unsafe/asm.md:307
msgid ""
"To work around this we use `rdi` to store the pointer to the output array, "
"save `ebx` via `push`, read from `ebx` inside the asm block into the array "
"and then restore `ebx` to its original state via `pop`. The `push` and `pop` "
"use the full 64-bit `rbx` version of the register to ensure that the entire "
"register is saved. On 32 bit targets the code would instead use `ebx` in the "
"`push`/`pop`."
msgstr ""

#: src/unsafe/asm.md:309
msgid ""
"This can also be used with a general register class to obtain a scratch "
"register for use inside the asm code:"
msgstr ""

#: src/unsafe/asm.md:314
msgid "// Multiply x by 6 using shifts and adds\n"
msgstr ""

#: src/unsafe/asm.md:319
msgid "\"mov {tmp}, {x}\""
msgstr ""

#: src/unsafe/asm.md:320
msgid "\"shl {tmp}, 1\""
msgstr ""

#: src/unsafe/asm.md:321
msgid "\"shl {x}, 2\""
msgstr ""

#: src/unsafe/asm.md:322
msgid "\"add {x}, {tmp}\""
msgstr ""

#: src/unsafe/asm.md:331
msgid "Symbol operands and ABI clobbers"
msgstr ""

#: src/unsafe/asm.md:333
msgid ""
"By default, `asm!` assumes that any register not specified as an output will "
"have its contents preserved by the assembly code. The [`clobber_abi`]"
"(https://doc.rust-lang.org/stable/reference/inline-assembly.html#abi-"
"clobbers) argument to `asm!` tells the compiler to automatically insert the "
"necessary clobber operands according to the given calling convention ABI: "
"any register which is not fully preserved in that ABI will be treated as "
"clobbered.  Multiple `clobber_abi` arguments may be provided and all "
"clobbers from all specified ABIs will be inserted."
msgstr ""

#: src/unsafe/asm.md:341 src/unsafe/asm.md:359
msgid "\"C\""
msgstr ""

#: src/unsafe/asm.md:342
msgid "\"arg = {}\""
msgstr ""

#: src/unsafe/asm.md:350
msgid "\"call {}\""
msgstr ""

#: src/unsafe/asm.md:351
msgid "// Function pointer to call\n"
msgstr ""

#: src/unsafe/asm.md:353
msgid "// 1st argument in rdi\n"
msgstr ""

#: src/unsafe/asm.md:355
msgid "// Return value in rax\n"
msgstr ""

#: src/unsafe/asm.md:357
msgid ""
"// Mark all registers which are not preserved by the \"C\" calling\n"
"            // convention as clobbered.\n"
msgstr ""

#: src/unsafe/asm.md:367
msgid "Register template modifiers"
msgstr ""

#: src/unsafe/asm.md:369
msgid ""
"In some cases, fine control is needed over the way a register name is "
"formatted when inserted into the template string. This is needed when an "
"architecture's assembly language has several names for the same register, "
"each typically being a \"view\" over a subset of the register (e.g. the low "
"32 bits of a 64-bit register)."
msgstr ""

#: src/unsafe/asm.md:371
msgid ""
"By default the compiler will always choose the name that refers to the full "
"register size (e.g. `rax` on x86-64, `eax` on x86, etc)."
msgstr ""

#: src/unsafe/asm.md:373
msgid ""
"This default can be overridden by using modifiers on the template string "
"operands, just like you would with format strings:"
msgstr ""

#: src/unsafe/asm.md:382
msgid "\"mov {0:h}, {0:l}\""
msgstr ""

#: src/unsafe/asm.md:389
msgid ""
"In this example, we use the `reg_abcd` register class to restrict the "
"register allocator to the 4 legacy x86 registers (`ax`, `bx`, `cx`, `dx`) of "
"which the first two bytes can be addressed independently."
msgstr ""

#: src/unsafe/asm.md:391
msgid ""
"Let us assume that the register allocator has chosen to allocate `x` in the "
"`ax` register. The `h` modifier will emit the register name for the high "
"byte of that register and the `l` modifier will emit the register name for "
"the low byte. The asm code will therefore be expanded as `mov ah, al` which "
"copies the low byte of the value into the high byte."
msgstr ""

#: src/unsafe/asm.md:394
msgid ""
"If you use a smaller data type (e.g. `u16`) with an operand and forget to "
"use template modifiers, the compiler will emit a warning and suggest the "
"correct modifier to use."
msgstr ""

#: src/unsafe/asm.md:396
msgid "Memory address operands"
msgstr ""

#: src/unsafe/asm.md:398
msgid ""
"Sometimes assembly instructions require operands passed via memory addresses/"
"memory locations. You have to manually use the memory address syntax "
"specified by the target architecture. For example, on x86/x86_64 using Intel "
"assembly syntax, you should wrap inputs/outputs in `[]` to indicate they are "
"memory operands:"
msgstr ""

#: src/unsafe/asm.md:408
msgid "\"fldcw [{}]\""
msgstr ""

#: src/unsafe/asm.md:414
msgid "Labels"
msgstr ""

#: src/unsafe/asm.md:416
msgid ""
"Any reuse of a named label, local or otherwise, can result in an assembler "
"or linker error or may cause other strange behavior. Reuse of a named label "
"can happen in a variety of ways including:"
msgstr ""

#: src/unsafe/asm.md:418
msgid ""
"explicitly: using a label more than once in one `asm!` block, or multiple "
"times across blocks."
msgstr ""

#: src/unsafe/asm.md:419
msgid ""
"implicitly via inlining: the compiler is allowed to instantiate multiple "
"copies of an `asm!` block, for example when the function containing it is "
"inlined in multiple places."
msgstr ""

#: src/unsafe/asm.md:420
msgid ""
"implicitly via LTO: LTO can cause code from _other crates_ to be placed in "
"the same codegen unit, and so could bring in arbitrary labels."
msgstr ""

#: src/unsafe/asm.md:422
msgid ""
"As a consequence, you should only use GNU assembler **numeric** [local "
"labels](https://sourceware.org/binutils/docs/as/Symbol-Names.html#Local-"
"Labels) inside inline assembly code. Defining symbols in assembly code may "
"lead to assembler and/or linker errors due to duplicate symbol definitions."
msgstr ""

#: src/unsafe/asm.md:424
msgid ""
"Moreover, on x86 when using the default Intel syntax, due to [an LLVM bug]"
"(https://bugs.llvm.org/show_bug.cgi?id=36144), you shouldn't use labels "
"exclusively made of `0` and `1` digits, e.g. `0`, `11` or `101010`, as they "
"may end up being interpreted as binary values. Using `options(att_syntax)` "
"will avoid any ambiguity, but that affects the syntax of the _entire_ `asm!` "
"block. (See [Options](#options), below, for more on `options`.)"
msgstr ""

#: src/unsafe/asm.md:433
msgid "\"mov {0}, 10\""
msgstr ""

#: src/unsafe/asm.md:434 src/unsafe/asm.md:439
msgid "\"2:\""
msgstr ""

#: src/unsafe/asm.md:435
msgid "\"sub {0}, 1\""
msgstr ""

#: src/unsafe/asm.md:436
msgid "\"cmp {0}, 3\""
msgstr ""

#: src/unsafe/asm.md:437
msgid "\"jle 2f\""
msgstr ""

#: src/unsafe/asm.md:438
msgid "\"jmp 2b\""
msgstr ""

#: src/unsafe/asm.md:440
msgid "\"add {0}, 2\""
msgstr ""

#: src/unsafe/asm.md:448
msgid ""
"This will decrement the `{0}` register value from 10 to 3, then add 2 and "
"store it in `a`."
msgstr ""

#: src/unsafe/asm.md:450
msgid "This example shows a few things:"
msgstr ""

#: src/unsafe/asm.md:452
msgid ""
"First, that the same number can be used as a label multiple times in the "
"same inline block."
msgstr ""

#: src/unsafe/asm.md:453
msgid ""
"Second, that when a numeric label is used as a reference (as an instruction "
"operand, for example), the suffixes “b” (“backward”) or ”f” (“forward”) "
"should be added to the numeric label. It will then refer to the nearest "
"label defined by this number in this direction."
msgstr ""

#: src/unsafe/asm.md:458
msgid "Options"
msgstr ""

#: src/unsafe/asm.md:460
msgid ""
"By default, an inline assembly block is treated the same way as an external "
"FFI function call with a custom calling convention: it may read/write "
"memory, have observable side effects, etc. However, in many cases it is "
"desirable to give the compiler more information about what the assembly code "
"is actually doing so that it can optimize better."
msgstr ""

#: src/unsafe/asm.md:462
msgid "Let's take our previous example of an `add` instruction:"
msgstr ""

#: src/unsafe/asm.md:481
msgid ""
"Options can be provided as an optional final argument to the `asm!` macro. "
"We specified three options here:"
msgstr ""

#: src/unsafe/asm.md:483
msgid ""
"`pure` means that the asm code has no observable side effects and that its "
"output depends only on its inputs. This allows the compiler optimizer to "
"call the inline asm fewer times or even eliminate it entirely."
msgstr ""

#: src/unsafe/asm.md:484
msgid ""
"`nomem` means that the asm code does not read or write to memory. By default "
"the compiler will assume that inline assembly can read or write any memory "
"address that is accessible to it (e.g. through a pointer passed as an "
"operand, or a global)."
msgstr ""

#: src/unsafe/asm.md:485
msgid ""
"`nostack` means that the asm code does not push any data onto the stack. "
"This allows the compiler to use optimizations such as the stack red zone on "
"x86-64 to avoid stack pointer adjustments."
msgstr ""

#: src/unsafe/asm.md:487
msgid ""
"These allow the compiler to better optimize code using `asm!`, for example "
"by eliminating pure `asm!` blocks whose outputs are not needed."
msgstr ""

#: src/unsafe/asm.md:489
msgid ""
"See the [reference](https://doc.rust-lang.org/stable/reference/inline-"
"assembly.html) for the full list of available options and their effects."
msgstr ""

#: src/compatibility.md:3
msgid ""
"The Rust language is evolving rapidly, and because of this certain "
"compatibility issues can arise, despite efforts to ensure forwards-"
"compatibility wherever possible."
msgstr ""

#: src/compatibility.md:7
msgid "[Raw identifiers](compatibility/raw_identifiers.md)"
msgstr ""

#: src/compatibility/raw_identifiers.md:3
msgid ""
"Rust, like many programming languages, has the concept of \"keywords\". "
"These identifiers mean something to the language, and so you cannot use them "
"in places like variable names, function names, and other places. Raw "
"identifiers let you use keywords where they would not normally be allowed. "
"This is particularly useful when Rust introduces new keywords, and a library "
"using an older edition of Rust has a variable or function with the same name "
"as a keyword introduced in a newer edition."
msgstr ""

#: src/compatibility/raw_identifiers.md:11
msgid ""
"For example, consider a crate `foo` compiled with the 2015 edition of Rust "
"that exports a function named `try`. This keyword is reserved for a new "
"feature in the 2018 edition, so without raw identifiers, we would have no "
"way to name the function."
msgstr ""

#: src/compatibility/raw_identifiers.md:24
msgid "You'll get this error:"
msgstr ""

#: src/compatibility/raw_identifiers.md:34
msgid "You can write this with a raw identifier:"
msgstr ""

#: src/meta.md:3
msgid ""
"Some topics aren't exactly relevant to how you program runs but provide you "
"tooling or infrastructure support which just makes things better for "
"everyone. These topics include:"
msgstr ""

#: src/meta.md:7
msgid ""
"[Documentation](meta/doc.md): Generate library documentation for users via "
"the included `rustdoc`."
msgstr ""

#: src/meta.md:9
msgid ""
"[Playground](meta/playground.md): Integrate the Rust Playground in your "
"documentation."
msgstr ""

#: src/meta/doc.md:3
msgid ""
"Use `cargo doc` to build documentation in `target/doc`, `cargo doc --open` "
"will automatically open it in your web browser."
msgstr ""

#: src/meta/doc.md:6
msgid ""
"Use `cargo test` to run all tests (including documentation tests), and "
"`cargo test --doc` to only run documentation tests."
msgstr ""

#: src/meta/doc.md:9
msgid ""
"These commands will appropriately invoke `rustdoc` (and `rustc`) as required."
msgstr ""

#: src/meta/doc.md:11
msgid "Doc comments"
msgstr ""

#: src/meta/doc.md:13
msgid ""
"Doc comments are very useful for big projects that require documentation. "
"When running `rustdoc`, these are the comments that get compiled into "
"documentation. They are denoted by a `///`, and support [Markdown](https://"
"en.wikipedia.org/wiki/Markdown)."
msgstr ""

#: src/meta/doc.md:18
msgid "\"doc\""
msgstr ""

#: src/meta/doc.md:19
msgid "/// A human being is represented here\n"
msgstr ""

#: src/meta/doc.md:22
msgid "/// A person must have a name, no matter how much Juliet may hate it\n"
msgstr ""

#: src/meta/doc.md:27
msgid ""
"/// Creates a person with the given name.\n"
"    ///\n"
"    /// # Examples\n"
"    ///\n"
"    /// ```\n"
"    /// // You can have rust code between fences inside the comments\n"
"    /// // If you pass --test to `rustdoc`, it will even test it for you!\n"
"    /// use doc::Person;\n"
"    /// let person = Person::new(\"name\");\n"
"    /// ```\n"
msgstr ""

#: src/meta/doc.md:43
msgid ""
"/// Gives a friendly hello!\n"
"    ///\n"
"    /// Says \"Hello, [name](Person::name)\" to the `Person` it is called "
"on.\n"
msgstr ""

#: src/meta/doc.md:47
msgid "\"Hello, {}!\""
msgstr ""

#: src/meta/doc.md:52
msgid "\"John\""
msgstr ""

#: src/meta/doc.md:58
msgid ""
"To run the tests, first build the code as a library, then tell `rustdoc` "
"where to find the library so it can link it into each doctest program:"
msgstr ""

#: src/meta/doc.md:61
msgid ""
"```shell\n"
"$ rustc doc.rs --crate-type lib\n"
"$ rustdoc --test --extern doc=\"libdoc.rlib\" doc.rs\n"
"```"
msgstr ""

#: src/meta/doc.md:66
msgid "Doc attributes"
msgstr ""

#: src/meta/doc.md:68
msgid ""
"Below are a few examples of the most common `#[doc]` attributes used with "
"`rustdoc`."
msgstr ""

#: src/meta/doc.md:71
msgid "`inline`"
msgstr ""

#: src/meta/doc.md:73
msgid "Used to inline docs, instead of linking out to separate page."
msgstr ""

#: src/meta/doc.md:78
msgid "/// bar docs\n"
msgstr ""

#: src/meta/doc.md:81
msgid "/// the docs for Bar\n"
msgstr ""

#: src/meta/doc.md:86
msgid "`no_inline`"
msgstr ""

#: src/meta/doc.md:88
msgid "Used to prevent linking out to separate page or anywhere."
msgstr ""

#: src/meta/doc.md:91
msgid "// Example from libcore/prelude\n"
msgstr ""

#: src/meta/doc.md:96
msgid "`hidden`"
msgstr ""

#: src/meta/doc.md:98
msgid "Using this tells `rustdoc` not to include this in documentation:"
msgstr ""

#: src/meta/doc.md:101
msgid "// Example from the futures-rs library\n"
msgstr ""

#: src/meta/doc.md:106
msgid ""
"For documentation, `rustdoc` is widely used by the community. It's what is "
"used to generate the [std library docs](https://doc.rust-lang.org/std/)."
msgstr ""

#: src/meta/doc.md:111
msgid ""
"[The Rust Book: Making Useful Documentation Comments](https://doc.rust-"
"lang.org/book/ch14-02-publishing-to-crates-io.html#making-useful-"
"documentation-comments)"
msgstr ""

#: src/meta/doc.md:112
msgid "[The rustdoc Book](https://doc.rust-lang.org/rustdoc/index.html)"
msgstr ""

#: src/meta/doc.md:113
msgid ""
"[The Reference: Doc comments](https://doc.rust-lang.org/stable/reference/"
"comments.html#doc-comments)"
msgstr ""

#: src/meta/doc.md:114
msgid ""
"[RFC 1574: API Documentation Conventions](https://rust-lang.github.io/rfcs/"
"1574-more-api-documentation-conventions.html#appendix-a-full-conventions-"
"text)"
msgstr ""

#: src/meta/doc.md:115
msgid ""
"[RFC 1946: Relative links to other items from doc comments (intra-rustdoc "
"links)](https://rust-lang.github.io/rfcs/1946-intra-rustdoc-links.html)"
msgstr ""

#: src/meta/doc.md:116
msgid ""
"[Is there any documentation style guide for comments? (reddit)](https://"
"www.reddit.com/r/rust/comments/ahb50s/"
"is_there_any_documentation_style_guide_for/)"
msgstr ""

#: src/meta/playground.md:3
msgid ""
"The [Rust Playground](https://play.rust-lang.org/) is a way to experiment "
"with Rust code through a web interface."
msgstr ""

#: src/meta/playground.md:6
msgid "Using it with `mdbook`"
msgstr ""

#: src/meta/playground.md:8
msgid ""
"In [`mdbook`](https://github.com/rust-lang/mdBook), you can make code "
"examples playable and editable."
msgstr ""

#: src/meta/playground.md:16
msgid ""
"This allows the reader to both run your code sample, but also modify and "
"tweak it. The key here is the adding of the word `editable` to your "
"codefence block separated by a comma."
msgstr ""

#: src/meta/playground.md:26
msgid ""
"Additionally, you can add `ignore` if you want `mdbook` to skip your code "
"when it builds and tests."
msgstr ""

#: src/meta/playground.md:35
msgid "Using it with docs"
msgstr ""

#: src/meta/playground.md:37
msgid ""
"You may have noticed in some of the [official Rust docs](https://doc.rust-"
"lang.org/core/) a button that says \"Run\", which opens the code sample up "
"in a new tab in Rust Playground. This feature is enabled if you use the "
"`#[doc]` attribute called [`html_playground_url`](https://doc.rust-lang.org/"
"rustdoc/write-documentation/the-doc-attribute.html#html_playground_url)."
msgstr ""

#: src/meta/playground.md:42
msgid ""
"````text\n"
"#![doc(html_playground_url = \"https://play.rust-lang.org/\")]\n"
"//! ```\n"
"//! println!(\"Hello World\");\n"
"//! ```\n"
"````"
msgstr ""

#: src/meta/playground.md:51
msgid "[The Rust Playground](https://play.rust-lang.org/)"
msgstr ""

#: src/meta/playground.md:52
msgid ""
"[The Rust Playground On Github](https://github.com/integer32llc/rust-"
"playground/)"
msgstr ""

#: src/meta/playground.md:53
msgid ""
"[The rustdoc Book](https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html)"
msgstr ""
