Реализовать `fmt::Display` для структуры, в которой каждый элемент должен обрабатываться
последовательно не так то просто.
Проблема в том, что `write!` каждый раз возвращает `fmt::Result`.
Правильная обработка `fmt::Result` требует работы с *каждым* результатом.
Для подобных случаев Rust предоставляет макрос `try!` или эквивалентный ему оператор `?`,
который больше подходит для данного примера.

Использование `try!` для `write!` выглядит следующим образом:

```rust
// Попробуй исполнить `write!`, чтобы узнать, вернется ли ошибка. Если ошибка, верни ее.
// Если нет, то продолжи.
try!(write!(f, "{}", value));
```

Более компактная версия примера с использованием оператора `?`:

```rust
write!(f, "{}", value)?;
```

С помощью оператора `?` реализация `fmt::Display` для `Vec` довольно простая:

{testcase_list.play}

### Задание

Попробуйте изменить программу так, чтобы индекс элемента так же выводился в консоль.
Новый вывод должен выглядеть примерно вот так:

```rust
[0: 1, 1: 2, 2: 3]
```


### Смотрите также

[`for`][for], [`ref`][ref], [`Result`][result], [`struct`][struct],
[`try!`][try], и [`vec!`][vec]

[for]: ../../../flow_control/for.html
[result]: ../../../std/result.html
[ref]: ../../../scope/borrow/ref.html
[struct]: ../../../custom_types/structs.html
[try]: ../../../std/result/try.html
[vec]: ../../../std/vec.html
