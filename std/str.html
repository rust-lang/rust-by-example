<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Strings - Rust By Example</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A description">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080)
                sidebar = store.get('mdbook-sidebar') || 'visible';
            $("html").addClass("sidebar-" + sidebar);
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="index.html">Introduction</a></li><li><a href="hello.html"><strong>1.</strong> Hello World</a></li><li><ul class="section"><li><a href="hello/comment.html"><strong>1.1.</strong> Comments</a></li><li><a href="hello/print.html"><strong>1.2.</strong> Formatted print</a></li><li><ul class="section"><li><a href="hello/print/print_debug.html"><strong>1.2.1.</strong> Debug</a></li><li><a href="hello/print/print_display.html"><strong>1.2.2.</strong> Display</a></li><li><ul class="section"><li><a href="hello/print/print_display/testcase_list.html"><strong>1.2.2.1.</strong> Testcase: List</a></li></ul></li><li><a href="hello/print/fmt.html"><strong>1.2.3.</strong> Formatting</a></li></ul></li></ul></li><li><a href="primitives.html"><strong>2.</strong> Primitives</a></li><li><ul class="section"><li><a href="primitives/literals.html"><strong>2.1.</strong> Literals and operators</a></li><li><a href="primitives/tuples.html"><strong>2.2.</strong> Tuples</a></li><li><a href="primitives/array.html"><strong>2.3.</strong> Arrays and Slices</a></li></ul></li><li><a href="custom_types.html"><strong>3.</strong> Custom Types</a></li><li><ul class="section"><li><a href="custom_types/structs.html"><strong>3.1.</strong> Structures</a></li><li><a href="custom_types/enum.html"><strong>3.2.</strong> Enums</a></li><li><ul class="section"><li><a href="custom_types/enum/enum_use.html"><strong>3.2.1.</strong> use</a></li><li><a href="custom_types/enum/c_like.html"><strong>3.2.2.</strong> C-like</a></li><li><a href="custom_types/enum/testcase_linked_list.html"><strong>3.2.3.</strong> Testcase: linked-list</a></li></ul></li><li><a href="custom_types/constants.html"><strong>3.3.</strong> constants</a></li></ul></li><li><a href="variable_bindings.html"><strong>4.</strong> Variable Bindings</a></li><li><ul class="section"><li><a href="variable_bindings/mut.html"><strong>4.1.</strong> Mutability</a></li><li><a href="variable_bindings/scope.html"><strong>4.2.</strong> Scope and Shadowing</a></li><li><a href="variable_bindings/declare.html"><strong>4.3.</strong> Declare first</a></li></ul></li><li><a href="types.html"><strong>5.</strong> Types</a></li><li><ul class="section"><li><a href="types/cast.html"><strong>5.1.</strong> Casting</a></li><li><a href="types/literals.html"><strong>5.2.</strong> Literals</a></li><li><a href="types/inference.html"><strong>5.3.</strong> Inference</a></li><li><a href="types/alias.html"><strong>5.4.</strong> Aliasing</a></li></ul></li><li><a href="conversion.html"><strong>6.</strong> Conversion</a></li><li><ul class="section"><li><a href="conversion/from_into.html"><strong>6.1.</strong> From and Into</a></li><li><a href="conversion/string.html"><strong>6.2.</strong> To and From String</a></li></ul></li><li><a href="expression.html"><strong>7.</strong> Expressions</a></li><li><a href="flow_control.html"><strong>8.</strong> Flow Control</a></li><li><ul class="section"><li><a href="flow_control/if_else.html"><strong>8.1.</strong> if/else</a></li><li><a href="flow_control/loop.html"><strong>8.2.</strong> loop</a></li><li><ul class="section"><li><a href="flow_control/loop/nested.html"><strong>8.2.1.</strong> Nesting and labels</a></li><li><a href="flow_control/loop/return.html"><strong>8.2.2.</strong> Returning from loops</a></li></ul></li><li><a href="flow_control/while.html"><strong>8.3.</strong> while</a></li><li><a href="flow_control/for.html"><strong>8.4.</strong> for and range</a></li><li><a href="flow_control/match.html"><strong>8.5.</strong> match</a></li><li><ul class="section"><li><a href="flow_control/match/destructuring.html"><strong>8.5.1.</strong> Destructuring</a></li><li><ul class="section"><li><a href="flow_control/match/destructuring/destructure_tuple.html"><strong>8.5.1.1.</strong> tuples</a></li><li><a href="flow_control/match/destructuring/destructure_enum.html"><strong>8.5.1.2.</strong> enums</a></li><li><a href="flow_control/match/destructuring/destructure_pointers.html"><strong>8.5.1.3.</strong> pointers/ref</a></li><li><a href="flow_control/match/destructuring/destructure_structures.html"><strong>8.5.1.4.</strong> structs</a></li></ul></li><li><a href="flow_control/match/guard.html"><strong>8.5.2.</strong> Guards</a></li><li><a href="flow_control/match/binding.html"><strong>8.5.3.</strong> Binding</a></li></ul></li><li><a href="flow_control/if_let.html"><strong>8.6.</strong> if let</a></li><li><a href="flow_control/while_let.html"><strong>8.7.</strong> while let</a></li></ul></li><li><a href="fn.html"><strong>9.</strong> Functions</a></li><li><ul class="section"><li><a href="fn/methods.html"><strong>9.1.</strong> Methods</a></li><li><a href="fn/closures.html"><strong>9.2.</strong> Closures</a></li><li><ul class="section"><li><a href="fn/closures/capture.html"><strong>9.2.1.</strong> Capturing</a></li><li><a href="fn/closures/input_parameters.html"><strong>9.2.2.</strong> As input parameters</a></li><li><a href="fn/closures/anonymity.html"><strong>9.2.3.</strong> Type anonymity</a></li><li><a href="fn/closures/input_functions.html"><strong>9.2.4.</strong> Input functions</a></li><li><a href="fn/closures/output_parameters.html"><strong>9.2.5.</strong> As output parameters</a></li><li><a href="fn/closures/closure_examples.html"><strong>9.2.6.</strong> Examples in std</a></li><li><ul class="section"><li><a href="fn/closures/closure_examples/iter_any.html"><strong>9.2.6.1.</strong> Iterator::any</a></li><li><a href="fn/closures/closure_examples/iter_find.html"><strong>9.2.6.2.</strong> Iterator::find</a></li></ul></li></ul></li><li><a href="fn/hof.html"><strong>9.3.</strong> Higher Order Functions</a></li></ul></li><li><a href="mod.html"><strong>10.</strong> Modules</a></li><li><ul class="section"><li><a href="mod/visibility.html"><strong>10.1.</strong> Visibility</a></li><li><a href="mod/struct_visibility.html"><strong>10.2.</strong> Struct visibility</a></li><li><a href="mod/use.html"><strong>10.3.</strong> The use declaration</a></li><li><a href="mod/super.html"><strong>10.4.</strong> super and self</a></li><li><a href="mod/split.html"><strong>10.5.</strong> File hierarchy</a></li></ul></li><li><a href="crates.html"><strong>11.</strong> Crates</a></li><li><ul class="section"><li><a href="crates/lib.html"><strong>11.1.</strong> Library</a></li><li><a href="crates/link.html"><strong>11.2.</strong> extern crate</a></li></ul></li><li><a href="attribute.html"><strong>12.</strong> Attributes</a></li><li><ul class="section"><li><a href="attribute/unused.html"><strong>12.1.</strong> dead_code</a></li><li><a href="attribute/crate.html"><strong>12.2.</strong> Crates</a></li><li><a href="attribute/cfg.html"><strong>12.3.</strong> cfg</a></li><li><ul class="section"><li><a href="attribute/cfg/custom.html"><strong>12.3.1.</strong> Custom</a></li></ul></li></ul></li><li><a href="generics.html"><strong>13.</strong> Generics</a></li><li><ul class="section"><li><a href="generics/gen_fn.html"><strong>13.1.</strong> Functions</a></li><li><a href="generics/impl.html"><strong>13.2.</strong> Implementation</a></li><li><a href="generics/gen_trait.html"><strong>13.3.</strong> Traits</a></li><li><a href="generics/bounds.html"><strong>13.4.</strong> Bounds</a></li><li><ul class="section"><li><a href="generics/bounds/testcase_empty.html"><strong>13.4.1.</strong> Testcase: empty bounds</a></li></ul></li><li><a href="generics/multi_bounds.html"><strong>13.5.</strong> Multiple bounds</a></li><li><a href="generics/where.html"><strong>13.6.</strong> Where clauses</a></li><li><a href="generics/new_types.html"><strong>13.7.</strong> New Type Idiom</a></li><li><a href="generics/assoc_items.html"><strong>13.8.</strong> Associated items</a></li><li><ul class="section"><li><a href="generics/assoc_items/the_problem.html"><strong>13.8.1.</strong> The Problem</a></li><li><a href="generics/assoc_items/types.html"><strong>13.8.2.</strong> Associated types</a></li></ul></li><li><a href="generics/phantom.html"><strong>13.9.</strong> Phantom type parameters</a></li><li><ul class="section"><li><a href="generics/phantom/testcase_units.html"><strong>13.9.1.</strong> Testcase: unit clarification</a></li></ul></li></ul></li><li><a href="scope.html"><strong>14.</strong> Scoping rules</a></li><li><ul class="section"><li><a href="scope/raii.html"><strong>14.1.</strong> RAII</a></li><li><a href="scope/move.html"><strong>14.2.</strong> Ownership and moves</a></li><li><ul class="section"><li><a href="scope/move/mut.html"><strong>14.2.1.</strong> Mutability</a></li></ul></li><li><a href="scope/borrow.html"><strong>14.3.</strong> Borrowing</a></li><li><ul class="section"><li><a href="scope/borrow/mut.html"><strong>14.3.1.</strong> Mutability</a></li><li><a href="scope/borrow/freeze.html"><strong>14.3.2.</strong> Freezing</a></li><li><a href="scope/borrow/alias.html"><strong>14.3.3.</strong> Aliasing</a></li><li><a href="scope/borrow/ref.html"><strong>14.3.4.</strong> The ref pattern</a></li></ul></li><li><a href="scope/lifetime.html"><strong>14.4.</strong> Lifetimes</a></li><li><ul class="section"><li><a href="scope/lifetime/explicit.html"><strong>14.4.1.</strong> Explicit annotation</a></li><li><a href="scope/lifetime/fn.html"><strong>14.4.2.</strong> Functions</a></li><li><a href="scope/lifetime/methods.html"><strong>14.4.3.</strong> Methods</a></li><li><a href="scope/lifetime/struct.html"><strong>14.4.4.</strong> Structs</a></li><li><a href="scope/lifetime/lifetime_bounds.html"><strong>14.4.5.</strong> Bounds</a></li><li><a href="scope/lifetime/lifetime_coercion.html"><strong>14.4.6.</strong> Coercion</a></li><li><a href="scope/lifetime/static_lifetime.html"><strong>14.4.7.</strong> static</a></li><li><a href="scope/lifetime/elision.html"><strong>14.4.8.</strong> elision</a></li></ul></li></ul></li><li><a href="trait.html"><strong>15.</strong> Traits</a></li><li><ul class="section"><li><a href="trait/derive.html"><strong>15.1.</strong> Derive</a></li><li><a href="trait/ops.html"><strong>15.2.</strong> Operator Overloading</a></li><li><a href="trait/drop.html"><strong>15.3.</strong> Drop</a></li><li><a href="trait/iter.html"><strong>15.4.</strong> Iterators</a></li><li><a href="trait/clone.html"><strong>15.5.</strong> Clone</a></li></ul></li><li><a href="macros.html"><strong>16.</strong> macro_rules!</a></li><li><ul class="section"><li><a href="macro/syntax.html"><strong>16.1.</strong> Syntax</a></li><li><ul class="section"><li><a href="macros/designators.html"><strong>16.1.1.</strong> Designators</a></li><li><a href="macros/overload.html"><strong>16.1.2.</strong> Overload</a></li><li><a href="macros/repeat.html"><strong>16.1.3.</strong> Repeat</a></li></ul></li><li><a href="macros/dry.html"><strong>16.2.</strong> DRY (Don't Repeat Yourself)</a></li><li><a href="macros/dsl.html"><strong>16.3.</strong> DSL (Domain Specific Languages)</a></li><li><a href="macros/variadics.html"><strong>16.4.</strong> Variadics</a></li></ul></li><li><a href="error.html"><strong>17.</strong> Error handling</a></li><li><ul class="section"><li><a href="error/panic.html"><strong>17.1.</strong> panic</a></li><li><a href="error/option_unwrap.html"><strong>17.2.</strong> Option &amp; unwrap</a></li><li><ul class="section"><li><a href="error/option_unwrap/map.html"><strong>17.2.1.</strong> Combinators: map</a></li><li><a href="error/option_unwrap/and_then.html"><strong>17.2.2.</strong> Combinators: and_then</a></li></ul></li><li><a href="error/result.html"><strong>17.3.</strong> Result</a></li><li><ul class="section"><li><a href="error/result/result_map.html"><strong>17.3.1.</strong> map for Result</a></li><li><a href="error/result/result_alias.html"><strong>17.3.2.</strong> aliases for Result</a></li><li><a href="error/result/early_returns.html"><strong>17.3.3.</strong> Early returns</a></li><li><a href="error/result/enter_question_mark.html"><strong>17.3.4.</strong> Introducing ?</a></li></ul></li><li><a href="error/multiple_error_types.html"><strong>17.4.</strong> Multiple error types</a></li><li><ul class="section"><li><a href="error/multiple_error_types/option_result.html"><strong>17.4.1.</strong> Pulling Results out of Options</a></li><li><a href="error/multiple_error_types/define_error_type.html"><strong>17.4.2.</strong> Defining an error type</a></li><li><a href="error/multiple_error_types/boxing_errors.html"><strong>17.4.3.</strong> Boxing errors</a></li><li><a href="error/multiple_error_types/reenter_question_mark.html"><strong>17.4.4.</strong> Other uses of ?</a></li><li><a href="error/multiple_error_types/wrap_error.html"><strong>17.4.5.</strong> Wrapping errors</a></li></ul></li><li><a href="error/iter_result.html"><strong>17.5.</strong> Iterating over Results</a></li></ul></li><li><a href="std.html"><strong>18.</strong> Std library types</a></li><li><ul class="section"><li><a href="std/box.html"><strong>18.1.</strong> Box, stack and heap</a></li><li><a href="std/vec.html"><strong>18.2.</strong> Vectors</a></li><li><a href="std/str.html" class="active"><strong>18.3.</strong> Strings</a></li><li><a href="std/option.html"><strong>18.4.</strong> Option</a></li><li><a href="std/result.html"><strong>18.5.</strong> Result</a></li><li><ul class="section"><li><a href="std/result/question_mark.html"><strong>18.5.1.</strong> ?</a></li></ul></li><li><a href="std/panic.html"><strong>18.6.</strong> panic!</a></li><li><a href="std/hash.html"><strong>18.7.</strong> HashMap</a></li><li><ul class="section"><li><a href="std/hash/alt_key_types.html"><strong>18.7.1.</strong> Alternate/custom key types</a></li><li><a href="std/hash/hashset.html"><strong>18.7.2.</strong> HashSet</a></li></ul></li></ul></li><li><a href="std_misc.html"><strong>19.</strong> Std misc</a></li><li><ul class="section"><li><a href="std_misc/threads.html"><strong>19.1.</strong> Threads</a></li><li><ul class="section"><li><a href="std_misc/threads/testcase_mapreduce.html"><strong>19.1.1.</strong> Testcase: map-reduce</a></li></ul></li><li><a href="std_misc/channels.html"><strong>19.2.</strong> Channels</a></li><li><a href="std_misc/path.html"><strong>19.3.</strong> Path</a></li><li><a href="std_misc/file.html"><strong>19.4.</strong> File I/O</a></li><li><ul class="section"><li><a href="std_misc/file/open.html"><strong>19.4.1.</strong> open</a></li><li><a href="std_misc/file/create.html"><strong>19.4.2.</strong> create</a></li></ul></li><li><a href="std_misc/process.html"><strong>19.5.</strong> Child processes</a></li><li><ul class="section"><li><a href="std_misc/process/pipe.html"><strong>19.5.1.</strong> Pipes</a></li><li><a href="std_misc/process/wait.html"><strong>19.5.2.</strong> Wait</a></li></ul></li><li><a href="std_misc/fs.html"><strong>19.6.</strong> Filesystem Operations</a></li><li><a href="std_misc/arg.html"><strong>19.7.</strong> Program arguments</a></li><li><ul class="section"><li><a href="std_misc/arg/matching.html"><strong>19.7.1.</strong> Argument parsing</a></li></ul></li><li><a href="std_misc/ffi.html"><strong>19.8.</strong> Foreign Function Interface</a></li></ul></li><li><a href="meta.html"><strong>20.</strong> Meta</a></li><li><ul class="section"><li><a href="meta/doc.html"><strong>20.1.</strong> Documentation</a></li><li><a href="meta/test.html"><strong>20.2.</strong> Testing</a></li></ul></li><li><a href="unsafe.html"><strong>21.</strong> Unsafe Operations</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">Rust By Example</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="std/str.html#strings" id="strings"><h1>Strings</h1></a>
<p>There are two types of strings in Rust: <code>String</code> and <code>&amp;str</code>.</p>
<p>A <code>String</code> is stored as a vector of bytes (<code>Vec&lt;u8&gt;</code>), but guaranteed to
always be a valid UTF-8 sequence. <code>String</code> is heap allocated, growable and not
null terminated.</p>
<p><code>&amp;str</code> is a slice (<code>&amp;[u8]</code>) that always points to a valid UTF-8 sequence, and
can be used to view into a <code>String</code>, just like <code>&amp;[T]</code> is a view into <code>Vec&lt;T&gt;</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // (all the type annotations are superfluous)
    // A reference to a string allocated in read only memory
    let pangram: &amp;'static str = &quot;the quick brown fox jumps over the lazy dog&quot;;
    println!(&quot;Pangram: {}&quot;, pangram);

    // Iterate over words in reverse, no new string is allocated
    println!(&quot;Words in reverse&quot;);
    for word in pangram.split_whitespace().rev() {
        println!(&quot;&gt; {}&quot;, word);
    }

    // Copy chars into a vector, sort and remove duplicates
    let mut chars: Vec&lt;char&gt; = pangram.chars().collect();
    chars.sort();
    chars.dedup();

    // Create an empty and growable `String`
    let mut string = String::new();
    for c in chars {
        // Insert a char at the end of string
        string.push(c);
        // Insert a string at the end of string
        string.push_str(&quot;, &quot;);
    }

    // The trimmed string is a slice to the original string, hence no new
    // allocation is performed
    let chars_to_trim: &amp;[char] = &amp;[' ', ','];
    let trimmed_str: &amp;str = string.trim_matches(chars_to_trim);
    println!(&quot;Used characters: {}&quot;, trimmed_str);

    // Heap allocate a string
    let alice = String::from(&quot;I like dogs&quot;);
    // Allocate new memory and store the modified string there
    let bob: String = alice.replace(&quot;dog&quot;, &quot;cat&quot;);

    println!(&quot;Alice says: {}&quot;, alice);
    println!(&quot;Bob says: {}&quot;, bob);
}
</code></pre></pre>
<p>More <code>str</code>/<code>String</code> methods can be found under the
<a href="https://doc.rust-lang.org/std/str/">std::str</a> and
<a href="https://doc.rust-lang.org/std/string/">std::string</a>
modules</p>
<a class="header" href="std/str.html#literals-and-escapes" id="literals-and-escapes"><h2>Literals and escapes</h2></a>
<p>There are multiple ways to write string literals with special characters in them.
All result in a similar <code>&amp;str</code> so it's best to use the form that is the most
convenient to write. Similarly there are multiple ways to write byte string literals,
which all result in <code>&amp;[u8; N]</code>.</p>
<p>Generally special characters are escaped with a backslash character: <code>\</code>.
This way you can add any character to your string, even unprintable ones
and ones that you don't know how to type. If you want a literal backslash,
escape it with another one: <code>\\</code></p>
<p>String or character literal delimiters occuring within a literal must be escaped: <code>&quot;\&quot;&quot;</code>, <code>'\''</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // You can use escapes to write bytes by their hexadecimal values...
    let byte_escape = &quot;I'm writing \x52\x75\x73\x74!&quot;;
    println!(&quot;What are you doing\x3F (\\x3F means ?) {}&quot;, byte_escape);

    // ...or Unicode code points.
    let unicode_codepoint = &quot;\u{211D}&quot;;
    let character_name = &quot;\&quot;DOUBLE-STRUCK CAPITAL R\&quot;&quot;;

    println!(&quot;Unicode character {} (U+211D) is called {}&quot;,
                unicode_codepoint, character_name );


    let long_string = &quot;String literals
                        can span multiple lines.
                        The linebreak and indentation here -&gt;\
                        &lt;- can be escaped too!&quot;;
    println!(&quot;{}&quot;, long_string);
}
</code></pre></pre>
<p>Sometimes there are just too many characters that need to be escaped or it's just
much more convenient to write a string out as-is. This is where raw string literals come into play.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let raw_str = r&quot;Escapes don't work here: \x3F \u{211D}&quot;;
    println!(&quot;{}&quot;, raw_str);

    // If you need quotes in a raw string, add a pair of #s
    let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#;
    println!(&quot;{}&quot;, quotes);

    // If you need &quot;# in your string, just use more #s in the delimiter.
    // There is no limit for the number of #s you can use.
    let longer_delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###;
    println!(&quot;{}&quot;, longer_delimiter);
}
</code></pre></pre>
<p>Want a string that's not UTF-8? (Remember, <code>str</code> and <code>String</code> must be valid UTF-8)
Or maybe you want an array of bytes that's mostly text? Byte strings to the rescue!</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::str;

fn main() {
    // Note that this is not actually a &amp;str
    let bytestring: &amp;[u8; 20] = b&quot;this is a bytestring&quot;;

    // Byte arrays don't have Display so printing them is a bit limited
    println!(&quot;A bytestring: {:?}&quot;, bytestring);

    // Bytestrings can have byte escapes...
    let escaped = b&quot;\x52\x75\x73\x74 as bytes&quot;;
    // ...but no unicode escapes
    // let escaped = b&quot;\u{211D} is not allowed&quot;;
    println!(&quot;Some escaped bytes: {:?}&quot;, escaped);


    // Raw bytestrings work just like raw strings
    let raw_bytestring = br&quot;\u{211D} is not escaped here&quot;;
    println!(&quot;{:?}&quot;, raw_bytestring);

    // Converting a byte array to str can fail
    if let Ok(my_str) = str::from_utf8(raw_bytestring) {
        println!(&quot;And the same as text: '{}'&quot;, my_str);
    }

    let quotes = br#&quot;You can also use &quot;fancier&quot; formatting, \
                    like with normal raw strings&quot;#;

    // Bytestrings don't have to be UTF-8
    let shift_jis = b&quot;\x82\xe6\x82\xa8\x82\xb1\x82&quot;; // &quot;ようこそ&quot; in SHIFT-JIS

    // But then they can't always be converted to str
    match str::from_utf8(shift_jis) {
        Ok(my_str) =&gt; println!(&quot;Conversion successful: '{}'&quot;, my_str),
        Err(e) =&gt; println!(&quot;Conversion failed: {:?}&quot;, e),
    };
}
</code></pre></pre>
<p>For conversions between character encodings check out the <a href="https://crates.io/crates/encoding">encoding</a> crate.</p>
<p>A more detailed listing of the ways to write string literals and escape characters
is given in the <a href="https://doc.rust-lang.org/reference/tokens.html">'Tokens' chapter</a> of the Rust Reference.</p>


                    <div class="nav-wrapper">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="std/vec.html" class="mobile-nav-chapters previous" title="Previous chapter">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="std/option.html" class="mobile-nav-chapters next" title="Next chapter">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </div>
                </div>
            </div>

            
                <a href="std/vec.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="std/option.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
