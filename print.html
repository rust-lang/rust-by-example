<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Rust By Example</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A description">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

        <!-- Custom JS script -->
        

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="index.html">Introduction</a></li><li><a href="hello.html"><strong>1.</strong> Hello World</a></li><li><ul class="section"><li><a href="hello/comment.html"><strong>1.1.</strong> Comments</a></li><li><a href="hello/print.html"><strong>1.2.</strong> Formatted print</a></li><li><ul class="section"><li><a href="hello/print/print_debug.html"><strong>1.2.1.</strong> Debug</a></li><li><a href="hello/print/print_display.html"><strong>1.2.2.</strong> Display</a></li><li><ul class="section"><li><a href="hello/print/print_display/testcase_list.html"><strong>1.2.2.1.</strong> Testcase: List</a></li></ul></li><li><a href="hello/print/fmt.html"><strong>1.2.3.</strong> Formatting</a></li></ul></li></ul></li><li><a href="primitives.html"><strong>2.</strong> Primitives</a></li><li><ul class="section"><li><a href="primitives/literals.html"><strong>2.1.</strong> Literals and operators</a></li><li><a href="primitives/tuples.html"><strong>2.2.</strong> Tuples</a></li><li><a href="primitives/array.html"><strong>2.3.</strong> Arrays and Slices</a></li></ul></li><li><a href="custom_types.html"><strong>3.</strong> Custom Types</a></li><li><ul class="section"><li><a href="custom_types/structs.html"><strong>3.1.</strong> Structures</a></li><li><a href="custom_types/enum.html"><strong>3.2.</strong> Enums</a></li><li><ul class="section"><li><a href="custom_types/enum/enum_use.html"><strong>3.2.1.</strong> use</a></li><li><a href="custom_types/enum/c_like.html"><strong>3.2.2.</strong> C-like</a></li><li><a href="custom_types/enum/testcase_linked_list.html"><strong>3.2.3.</strong> Testcase: linked-list</a></li></ul></li><li><a href="custom_types/constants.html"><strong>3.3.</strong> constants</a></li></ul></li><li><a href="variable_bindings.html"><strong>4.</strong> Variable Bindings</a></li><li><ul class="section"><li><a href="variable_bindings/mut.html"><strong>4.1.</strong> Mutability</a></li><li><a href="variable_bindings/scope.html"><strong>4.2.</strong> Scope and Shadowing</a></li><li><a href="variable_bindings/declare.html"><strong>4.3.</strong> Declare first</a></li></ul></li><li><a href="cast.html"><strong>5.</strong> Casting</a></li><li><ul class="section"><li><a href="cast/literals.html"><strong>5.1.</strong> Literals</a></li><li><a href="cast/inference.html"><strong>5.2.</strong> Inference</a></li><li><a href="cast/alias.html"><strong>5.3.</strong> Aliasing</a></li></ul></li><li><a href="expression.html"><strong>6.</strong> Expressions</a></li><li><a href="flow_control.html"><strong>7.</strong> Flow Control</a></li><li><ul class="section"><li><a href="flow_control/if_else.html"><strong>7.1.</strong> if/else</a></li><li><a href="flow_control/loop.html"><strong>7.2.</strong> loop</a></li><li><ul class="section"><li><a href="flow_control/loop/nested.html"><strong>7.2.1.</strong> Nesting and labels</a></li><li><a href="flow_control/loop/return.html"><strong>7.2.2.</strong> Returning from loops</a></li></ul></li><li><a href="flow_control/while.html"><strong>7.3.</strong> while</a></li><li><a href="flow_control/for.html"><strong>7.4.</strong> for and range</a></li><li><a href="flow_control/match.html"><strong>7.5.</strong> match</a></li><li><ul class="section"><li><a href="flow_control/match/destructuring.html"><strong>7.5.1.</strong> Destructuring</a></li><li><ul class="section"><li><a href="flow_control/match/destructuring/destructure_tuple.html"><strong>7.5.1.1.</strong> tuples</a></li><li><a href="flow_control/match/destructuring/destructure_enum.html"><strong>7.5.1.2.</strong> enums</a></li><li><a href="flow_control/match/destructuring/destructure_pointers.html"><strong>7.5.1.3.</strong> pointers/ref</a></li><li><a href="flow_control/match/destructuring/destructure_structures.html"><strong>7.5.1.4.</strong> structs</a></li></ul></li><li><a href="flow_control/match/guard.html"><strong>7.5.2.</strong> Guards</a></li><li><a href="flow_control/match/binding.html"><strong>7.5.3.</strong> Binding</a></li></ul></li><li><a href="flow_control/if_let.html"><strong>7.6.</strong> if let</a></li><li><a href="flow_control/while_let.html"><strong>7.7.</strong> while let</a></li></ul></li><li><a href="fn.html"><strong>8.</strong> Functions</a></li><li><ul class="section"><li><a href="fn/methods.html"><strong>8.1.</strong> Methods</a></li><li><a href="fn/closures.html"><strong>8.2.</strong> Closures</a></li><li><ul class="section"><li><a href="fn/closures/capture.html"><strong>8.2.1.</strong> Capturing</a></li><li><a href="fn/closures/input_parameters.html"><strong>8.2.2.</strong> As input parameters</a></li><li><a href="fn/closures/anonymity.html"><strong>8.2.3.</strong> Type anonymity</a></li><li><a href="fn/closures/input_functions.html"><strong>8.2.4.</strong> Input functions</a></li><li><a href="fn/closures/output_parameters.html"><strong>8.2.5.</strong> As output parameters</a></li><li><a href="fn/closures/closure_examples.html"><strong>8.2.6.</strong> Examples in <code>std</code></a></li><li><ul class="section"><li><a href="fn/closures/closure_examples/iter_any.html"><strong>8.2.6.1.</strong> Iterator::any</a></li><li><a href="fn/closures/closure_examples/iter_find.html"><strong>8.2.6.2.</strong> Iterator::find</a></li></ul></li></ul></li><li><a href="fn/hof.html"><strong>8.3.</strong> Higher Order Functions</a></li></ul></li><li><a href="mod.html"><strong>9.</strong> Modules</a></li><li><ul class="section"><li><a href="mod/visibility.html"><strong>9.1.</strong> Visibility</a></li><li><a href="mod/struct_visibility.html"><strong>9.2.</strong> Struct visibility</a></li><li><a href="mod/use.html"><strong>9.3.</strong> The <code>use</code> declaration</a></li><li><a href="mod/super.html"><strong>9.4.</strong> <code>super</code> and <code>self</code></a></li><li><a href="mod/split.html"><strong>9.5.</strong> File hierarchy</a></li></ul></li><li><a href="crates.html"><strong>10.</strong> Crates</a></li><li><ul class="section"><li><a href="crates/lib.html"><strong>10.1.</strong> Library</a></li><li><a href="crates/link.html"><strong>10.2.</strong> <code>extern crate</code></a></li></ul></li><li><a href="attribute.html"><strong>11.</strong> Attributes</a></li><li><ul class="section"><li><a href="attribute/unused.html"><strong>11.1.</strong> <code>dead_code</code></a></li><li><a href="attribute/crate.html"><strong>11.2.</strong> Crates</a></li><li><a href="attribute/cfg.html"><strong>11.3.</strong> <code>cfg</code></a></li><li><ul class="section"><li><a href="attribute/cfg/custom.html"><strong>11.3.1.</strong> Custom</a></li></ul></li></ul></li><li><a href="generics.html"><strong>12.</strong> Generics</a></li><li><ul class="section"><li><a href="generics/gen_fn.html"><strong>12.1.</strong> Functions</a></li><li><a href="generics/impl.html"><strong>12.2.</strong> Implementation</a></li><li><a href="generics/gen_trait.html"><strong>12.3.</strong> Traits</a></li><li><a href="generics/bounds.html"><strong>12.4.</strong> Bounds</a></li><li><ul class="section"><li><a href="generics/bounds/testcase_empty.html"><strong>12.4.1.</strong> Testcase: empty bounds</a></li></ul></li><li><a href="generics/multi_bounds.html"><strong>12.5.</strong> Multiple bounds</a></li><li><a href="generics/where.html"><strong>12.6.</strong> Where clauses</a></li><li><a href="generics/assoc_items.html"><strong>12.7.</strong> Associated items</a></li><li><ul class="section"><li><a href="generics/assoc_items/the_problem.html"><strong>12.7.1.</strong> The Problem</a></li><li><a href="generics/assoc_items/types.html"><strong>12.7.2.</strong> Associated types</a></li></ul></li><li><a href="generics/phantom.html"><strong>12.8.</strong> Phantom type parameters</a></li><li><ul class="section"><li><a href="generics/phantom/testcase_units.html"><strong>12.8.1.</strong> Testcase: unit clarification</a></li></ul></li></ul></li><li><a href="scope.html"><strong>13.</strong> Scoping rules</a></li><li><ul class="section"><li><a href="scope/raii.html"><strong>13.1.</strong> RAII</a></li><li><a href="scope/move.html"><strong>13.2.</strong> Ownership and moves</a></li><li><ul class="section"><li><a href="scope/move/mut.html"><strong>13.2.1.</strong> Mutability</a></li></ul></li><li><a href="scope/borrow.html"><strong>13.3.</strong> Borrowing</a></li><li><ul class="section"><li><a href="scope/borrow/mut.html"><strong>13.3.1.</strong> Mutability</a></li><li><a href="scope/borrow/freeze.html"><strong>13.3.2.</strong> Freezing</a></li><li><a href="scope/borrow/alias.html"><strong>13.3.3.</strong> Aliasing</a></li><li><a href="scope/borrow/ref.html"><strong>13.3.4.</strong> The ref pattern</a></li></ul></li><li><a href="scope/lifetime.html"><strong>13.4.</strong> Lifetimes</a></li><li><ul class="section"><li><a href="scope/lifetime/explicit.html"><strong>13.4.1.</strong> Explicit annotation</a></li><li><a href="scope/lifetime/fn.html"><strong>13.4.2.</strong> Functions</a></li><li><a href="scope/lifetime/methods.html"><strong>13.4.3.</strong> Methods</a></li><li><a href="scope/lifetime/struct.html"><strong>13.4.4.</strong> Structs</a></li><li><a href="scope/lifetime/lifetime_bounds.html"><strong>13.4.5.</strong> Bounds</a></li><li><a href="scope/lifetime/lifetime_coercion.html"><strong>13.4.6.</strong> Coercion</a></li><li><a href="scope/lifetime/static_lifetime.html"><strong>13.4.7.</strong> static</a></li><li><a href="scope/lifetime/elision.html"><strong>13.4.8.</strong> elision</a></li></ul></li></ul></li><li><a href="trait.html"><strong>14.</strong> Traits</a></li><li><ul class="section"><li><a href="trait/derive.html"><strong>14.1.</strong> Derive</a></li><li><a href="trait/ops.html"><strong>14.2.</strong> Operator Overloading</a></li><li><a href="trait/drop.html"><strong>14.3.</strong> Drop</a></li><li><a href="trait/iter.html"><strong>14.4.</strong> Iterators</a></li><li><a href="trait/clone.html"><strong>14.5.</strong> Clone</a></li></ul></li><li><a href="macros.html"><strong>15.</strong> macro_rules!</a></li><li><ul class="section"><li><a href="macros/designators.html"><strong>15.1.</strong> Designators</a></li><li><a href="macros/overload.html"><strong>15.2.</strong> Overload</a></li><li><a href="macros/repeat.html"><strong>15.3.</strong> Repeat</a></li><li><a href="macros/dry.html"><strong>15.4.</strong> DRY (Don't Repeat Yourself)</a></li></ul></li><li><a href="error.html"><strong>16.</strong> Error handling</a></li><li><ul class="section"><li><a href="error/panic.html"><strong>16.1.</strong> <code>panic</code></a></li><li><a href="error/option_unwrap.html"><strong>16.2.</strong> <code>Option</code> &amp; <code>unwrap</code></a></li><li><ul class="section"><li><a href="error/option_unwrap/map.html"><strong>16.2.1.</strong> Combinators: <code>map</code></a></li><li><a href="error/option_unwrap/and_then.html"><strong>16.2.2.</strong> Combinators: <code>and_then</code></a></li></ul></li><li><a href="error/result.html"><strong>16.3.</strong> <code>Result</code></a></li><li><ul class="section"><li><a href="error/result/result_map.html"><strong>16.3.1.</strong> <code>map</code> for <code>Result</code></a></li><li><a href="error/result/result_alias.html"><strong>16.3.2.</strong> aliases for <code>Result</code></a></li></ul></li><li><a href="error/multiple_error_types.html"><strong>16.4.</strong> Multiple error types</a></li><li><ul class="section"><li><a href="error/multiple_error_types/early_returns.html"><strong>16.4.1.</strong> Early returns</a></li><li><a href="error/multiple_error_types/enter_question_mark.html"><strong>16.4.2.</strong> Introducing <code>?</code></a></li></ul></li><li><a href="error/define_error_type.html"><strong>16.5.</strong> Defining an error type</a></li><li><a href="error/reenter_question_mark.html"><strong>16.6.</strong> Other uses of <code>?</code></a></li><li><a href="error/boxing_errors.html"><strong>16.7.</strong> <code>Box</code>ing errors</a></li><li><a href="error/iter_result.html"><strong>16.8.</strong> Iterating over <code>Result</code>s</a></li></ul></li><li><a href="std.html"><strong>17.</strong> Std library types</a></li><li><ul class="section"><li><a href="std/box.html"><strong>17.1.</strong> Box, stack and heap</a></li><li><a href="std/vec.html"><strong>17.2.</strong> Vectors</a></li><li><a href="std/str.html"><strong>17.3.</strong> Strings</a></li><li><a href="std/option.html"><strong>17.4.</strong> <code>Option</code></a></li><li><a href="std/result.html"><strong>17.5.</strong> <code>Result</code></a></li><li><ul class="section"><li><a href="std/result/question_mark.html"><strong>17.5.1.</strong> <code>?</code></a></li></ul></li><li><a href="std/panic.html"><strong>17.6.</strong> <code>panic!</code></a></li><li><a href="std/hash.html"><strong>17.7.</strong> HashMap</a></li><li><ul class="section"><li><a href="std/hash/alt_key_types.html"><strong>17.7.1.</strong> Alternate/custom key types</a></li><li><a href="std/hash/hashset.html"><strong>17.7.2.</strong> HashSet</a></li></ul></li></ul></li><li><a href="std_misc.html"><strong>18.</strong> Std misc</a></li><li><ul class="section"><li><a href="std_misc/threads.html"><strong>18.1.</strong> Threads</a></li><li><ul class="section"><li><a href="std_misc/threads/testcase_mapreduce.html"><strong>18.1.1.</strong> Testcase: map-reduce</a></li></ul></li><li><a href="std_misc/channels.html"><strong>18.2.</strong> Channels</a></li><li><a href="std_misc/path.html"><strong>18.3.</strong> Path</a></li><li><a href="std_misc/file.html"><strong>18.4.</strong> File I/O</a></li><li><ul class="section"><li><a href="std_misc/file/open.html"><strong>18.4.1.</strong> <code>open</code></a></li><li><a href="std_misc/file/create.html"><strong>18.4.2.</strong> <code>create</code></a></li></ul></li><li><a href="std_misc/process.html"><strong>18.5.</strong> Child processes</a></li><li><ul class="section"><li><a href="std_misc/process/pipe.html"><strong>18.5.1.</strong> Pipes</a></li><li><a href="std_misc/process/wait.html"><strong>18.5.2.</strong> Wait</a></li></ul></li><li><a href="std_misc/fs.html"><strong>18.6.</strong> Filesystem Operations</a></li><li><a href="std_misc/arg.html"><strong>18.7.</strong> Program arguments</a></li><li><ul class="section"><li><a href="std_misc/arg/matching.html"><strong>18.7.1.</strong> Argument parsing</a></li></ul></li><li><a href="std_misc/ffi.html"><strong>18.8.</strong> Foreign Function Interface</a></li></ul></li><li><a href="meta.html"><strong>19.</strong> Meta</a></li><li><ul class="section"><li><a href="meta/doc.html"><strong>19.1.</strong> Documentation</a></li><li><a href="meta/test.html"><strong>19.2.</strong> Testing</a></li></ul></li><li><a href="unsafe.html"><strong>20.</strong> Unsafe Operations</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <!-- START - Rust-By-Example customization -->
                         <i id="edit-button" class="fa fa-edit">Edit</i>
                         <!-- END - Rust-By-Example customization -->
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">Rust By Example</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#rust-by-example" id="rust-by-example"><h1>Rust by Example</h1></a>
<p><a href="https://www.rust-lang.org/">Rust</a> is a modern systems programming language focusing on safety, speed,
and concurrency. It accomplishes these goals by being memory safe without using
garbage collection.</p>
<p>Rust by Example (RBE) is a collection of runnable examples that illustrate various Rust
concepts and standard libraries. To get even more out of these examples, don't forget
to <a href="https://www.rust-lang.org/install.html">install Rust locally</a> and check out the <a href="https://doc.rust-lang.org/std/">official docs</a>.
Additionally for the curious, you can also <a href="https://github.com/rust-lang/rust-by-example">check out the source code for this site</a>.</p>
<p>Now let's begin!</p>
<a class="header" href="print.html#hello-world" id="hello-world"><h1>Hello World</h1></a>
<p>This is the source code of the traditional Hello World program.</p>
<pre><pre class="playpen"><code class="language-rust editable">// This is a comment, and will be ignored by the compiler
// You can test this code by clicking the &quot;Run&quot; button over there -&gt;
// or if prefer to use your keyboard, you can use the &quot;Ctrl + Enter&quot; shortcut

// This code is editable, feel free to hack it!
// You can always return to the original code by clicking the &quot;Reset&quot; button -&gt;

// This is the main function
fn main() {
    // The statements here will be executed when the compiled binary is called

    // Print text to the console
    println!(&quot;Hello World!&quot;);
}
</code></pre></pre>
<p><code>println!</code> is a <a href="./macros.html"><em>macro</em></a> that prints text to the
console.</p>
<p>A binary can be generated using the Rust compiler: <code>rustc</code>.</p>
<pre><code class="language-bash">$ rustc hello.rs
</code></pre>
<p><code>rustc</code> will produce a <code>hello</code> binary that can be executed.</p>
<pre><code class="language-bash">$ ./hello
Hello World!
</code></pre>
<a class="header" href="print.html#activity" id="activity"><h3>Activity</h3></a>
<p>Click 'Run' above to see the expected output. Next, add a new
line with a second <code>println!</code> macro so that the output
shows:</p>
<pre><code class="language-text">Hello World!
I'm a Rustacean!
</code></pre>
<a class="header" href="print.html#comments" id="comments"><h1>Comments</h1></a>
<p>Any program requires comments and indeed Rust supports
a few different varieties:</p>
<ul>
<li><em>Regular comments</em> which are ignored by the compiler:</li>
</ul>
<ul>
<li><code>// Line comments which go to the end of the line.</code></li>
<li><code>/* Block comments which go to the closing delimiter. */</code></li>
</ul>
<ul>
<li><em>Doc comments</em> which are parsed into HTML library
<a href="/meta/doc.html">documentation</a>:</li>
</ul>
<ul>
<li><code>/// Generate library docs for the following item.</code></li>
<li><code>//! Generate library docs for the enclosing item.</code></li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // This is an example of a line comment
    // Notice how there are two slashes at the beginning of the line
    // And that nothing written inside these will be read by the compiler

    // println!(&quot;Hello, world!&quot;);

    // Run it. See? Now try deleting the two slashes, and run it again.

    /* 
     * This is another type of comment, the block comment. In general,
     * the line comment is the recommended comment style however the
     * block comment is extremely useful for temporarily disabling
     * a large chunk of code. /* Block comments can be /* nested, */ */
     * so it takes only a few keystrokes to comment out all the lines
     * in this main() function. /*/*/* Try it yourself! */*/*/
     */

     /*
     Note, the previous column of `*` was entirely for style. There's
     no actual need for it.
     */

     // Observe how block comments allow easy expression manipulation
     // which line comments do not. Deleting the comment delimiters
     // will change the result:
     let x = 5 + /* 90 + */ 5;
     println!(&quot;Is `x` 10 or 100? x = {}&quot;, x);
}

</code></pre></pre>
<a class="header" href="print.html#see-also" id="see-also"><h3>See also:</h3></a>
<p><a href="/meta/doc.html">Library documentation</a></p>
<a class="header" href="print.html#formatted-print" id="formatted-print"><h1>Formatted print</h1></a>
<p>Printing is handled by a series of <a href="/macros.html"><code>macros</code></a> defined in <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>
some of which include:</p>
<ul>
<li><code>format!</code>: write formatted text to <a href="/std/str.html"><code>String</code></a></li>
<li><code>print!</code>: same as <code>format!</code> but the text is printed to the console.</li>
<li><code>println!</code>: same as <code>print!</code> but a newline is appended.</li>
</ul>
<p>All parse text in the same fashion. A plus is that the formatting correctness will
be checked at compile time.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // In general, the `{}` will be automatically replaced with any
    // arguments. These will be stringified.
    println!(&quot;{} days&quot;, 31);

    // Without a suffix, 31 becomes an i32. You can change what type 31 is,
    // with a suffix.

    // There are various optional patterns this works with. Positional
    // arguments can be used.
    println!(&quot;{0}, this is {1}. {1}, this is {0}&quot;, &quot;Alice&quot;, &quot;Bob&quot;);

    // As can named arguments.
    println!(&quot;{subject} {verb} {object}&quot;,
             object=&quot;the lazy dog&quot;,
             subject=&quot;the quick brown fox&quot;,
             verb=&quot;jumps over&quot;);

    // Special formatting can be specified after a `:`.
    println!(&quot;{} of {:b} people know binary, the other half doesn't&quot;, 1, 2);

    // You can right-align text with a specified width. This will output
    // &quot;     1&quot;. 5 white spaces and a &quot;1&quot;.
    println!(&quot;{number:&gt;width$}&quot;, number=1, width=6);

    // You can pad numbers with extra zeroes. This will output &quot;000001&quot;.
    println!(&quot;{number:&gt;0width$}&quot;, number=1, width=6);

    // It will even check to make sure the correct number of arguments are
    // used.
    println!(&quot;My name is {0}, {1} {0}&quot;, &quot;Bond&quot;);
    // FIXME ^ Add the missing argument: &quot;James&quot;
    
    // Create a structure which contains an `i32`. Name it `Structure`.
    #[allow(dead_code)]
    struct Structure(i32);

    // However, custom types such as this structure require more complicated
    // handling. This will not work.
    println!(&quot;This struct `{}` won't print...&quot;, Structure(3));
    // FIXME ^ Comment out this line.
}
</code></pre></pre>
<p><a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a> contains many <a href="/trait.html"><code>traits</code></a> which govern the display
of text. The base form of two important ones are listed below:</p>
<ul>
<li><code>fmt::Debug</code>: Uses the <code>{:?}</code> marker. Format text for debugging purposes.</li>
<li><code>fmt::Display</code>: Uses the <code>{}</code> marker. Format text in a more elegant, user
friendly fashion.</li>
</ul>
<p>Here, <code>fmt::Display</code> was used because the std library provides implementations
for these types. To print text for custom types, more steps are required.</p>
<a class="header" href="print.html#activities" id="activities"><h3>Activities</h3></a>
<ul>
<li>Fix the two issues in the above code (see FIXME) so that it runs without
error.</li>
<li>Add a <code>println!</code> macro that prints: <code>Pi is roughly 3.142</code> by controlling
the number of decimal places shown. For the purposes of this exercise,
use <code>let pi = 3.141592</code> as an estimate for Pi. (Hint: you may need to
check the <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a> documentation for setting the number of
decimals to display)</li>
</ul>
<a class="header" href="print.html#see-also-1" id="see-also-1"><h3>See also</h3></a>
<p><a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>, <a href="/macros.html"><code>macros</code></a>, <a href="/custom_types/structs.html"><code>struct</code></a>,
and <a href="/trait.html"><code>traits</code></a></p>
<a class="header" href="print.html#debug" id="debug"><h1>Debug</h1></a>
<p>All types which want to use <code>std::fmt</code> formatting <code>traits</code> require an
implementation to be printable. Automatic implementations are only provided
for types such as in the <code>std</code> library. All others <em>must</em> be manually
implemented somehow.</p>
<p>The <code>fmt::Debug</code> <code>trait</code> makes this very straightforward. <em>All</em> types can
<code>derive</code> (automatically create) the <code>fmt::Debug</code> implementation. This is
not true for <code>fmt::Display</code> which must be manually implemented.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// This structure cannot be printed either with `fmt::Display` or
// with `fmt::Debug`
struct UnPrintable(i32);

// The `derive` attribute automatically creates the implementation
// required to make this `struct` printable with `fmt::Debug`.
#[derive(Debug)]
struct DebugPrintable(i32);
#}</code></pre></pre>
<p>All <code>std</code> library types automatically are printable with <code>{:?}</code> too:</p>
<pre><pre class="playpen"><code class="language-rust editible">// Derive the `fmt::Debug` implementation for `Structure`. `Structure`
// is a structure which contains a single `i32`.
#[derive(Debug)]
struct Structure(i32);

// Put a `Structure` inside of the structure `Deep`. Make it printable
// also.
#[derive(Debug)]
struct Deep(Structure);

fn main() {
    // Printing with `{:?}` is similar to with `{}`.
    println!(&quot;{:?} months in a year.&quot;, 12);
    println!(&quot;{1:?} {0:?} is the {actor:?} name.&quot;,
             &quot;Slater&quot;,
             &quot;Christian&quot;,
             actor=&quot;actor's&quot;);

    // `Structure` is printable!
    println!(&quot;Now {:?} will print!&quot;, Structure(3));
    
    // The problem with `derive` is there is no control over how
    // the results look. What if I want this to just show a `7`?
    println!(&quot;Now {:?} will print!&quot;, Deep(Structure(7)));
}
</code></pre></pre>
<p>So <code>fmt::Debug</code> definitely makes this printable but sacrifices some
elegance. Manually implementing <code>fmt::Display</code> will fix that.</p>
<a class="header" href="print.html#see-also-2" id="see-also-2"><h3>See also</h3></a>
<p><a href="https://doc.rust-lang.org/reference/attributes.html">attributes</a>, <a href="/trait/derive.html"><code>derive</code></a>, <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>,
and <a href="/custom_types/structs.html"><code>struct</code></a></p>
<a class="header" href="print.html#display" id="display"><h1>Display</h1></a>
<p><code>fmt::Debug</code> hardly looks compact and clean, so it is often advantageous to
customize the output appearance. This is done by manually implementing
<a href="https://doc.rust-lang.org/std/fmt/"><code>fmt::Display</code></a>, which uses the <code>{}</code> print marker. Implementing it
looks like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Import (via `use`) the `fmt` module to make it available.
use std::fmt;

// Define a structure which `fmt::Display` will be implemented for. This is simply
// a tuple struct containing an `i32` bound to the name `Structure`.
struct Structure(i32);

// In order to use the `{}` marker, the trait `fmt::Display` must be implemented
// manually for the type.
impl fmt::Display for Structure {
    // This trait requires `fmt` with this exact signature.
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // Write strictly the first element into the supplied output
        // stream: `f`. Returns `fmt::Result` which indicates whether the
        // operation succeeded or failed. Note that `write!` uses syntax which
        // is very similar to `println!`.
        write!(f, &quot;{}&quot;, self.0)
    }
}
#}</code></pre></pre>
<p><code>fmt::Display</code> may be cleaner than <code>fmt::Debug</code> but this presents
a problem for the <code>std</code> library. How should ambiguous types be displayed?
For example, if the <code>std</code> library implemented a single style for all
<code>Vec&lt;T&gt;</code>, what style should it be? Either of these two?</p>
<ul>
<li><code>Vec&lt;path&gt;</code>: <code>/:/etc:/home/username:/bin</code> (split on <code>:</code>)</li>
<li><code>Vec&lt;number&gt;</code>: <code>1,2,3</code> (split on <code>,</code>)</li>
</ul>
<p>No, because there is no ideal style for all types and the <code>std</code> library
doesn't presume to dictate one. <code>fmt::Display</code> is not implemented for <code>Vec&lt;T&gt;</code>
or for any other generic containers. <code>fmt::Debug</code> must then be used for these
generic cases.</p>
<p>This is not a problem though because for any new <em>container</em> type which is
<em>not</em> generic,<code>fmt::Display</code> can be implemented.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt; // Import `fmt`

// A structure holding two numbers. `Debug` will be derived so the results can
// be contrasted with `Display`.
#[derive(Debug)]
struct MinMax(i64, i64);

// Implement `Display` for `MinMax`.
impl fmt::Display for MinMax {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // Use `self.number` to refer to each positional data point.
        write!(f, &quot;({}, {})&quot;, self.0, self.1)
    }
}

// Define a structure where the fields are nameable for comparison.
#[derive(Debug)]
struct Point2D {
    x: f64,
    y: f64,
}

// Similarly, implement for Point2D
impl fmt::Display for Point2D {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // Customize so only `x` and `y` are denoted.
        write!(f, &quot;x: {}, y: {}&quot;, self.x, self.y)
    }
}

fn main() {
    let minmax = MinMax(0, 14);

    println!(&quot;Compare structures:&quot;);
    println!(&quot;Display: {}&quot;, minmax);
    println!(&quot;Debug: {:?}&quot;, minmax);

    let big_range =   MinMax(-300, 300);
    let small_range = MinMax(-3, 3);

    println!(&quot;The big range is {big} and the small is {small}&quot;,
             small = small_range,
             big = big_range);

    let point = Point2D { x: 3.3, y: 7.2 };

    println!(&quot;Compare points:&quot;);
    println!(&quot;Display: {}&quot;, point);
    println!(&quot;Debug: {:?}&quot;, point);

    // Error. Both `Debug` and `Display` were implemented but `{:b}`
    // requires `fmt::Binary` to be implemented. This will not work.
    // println!(&quot;What does Point2D look like in binary: {:b}?&quot;, point);
}
</code></pre></pre>
<p>So, <code>fmt::Display</code> has been implemented but <code>fmt::Binary</code> has not, and
therefore cannot be used. <code>std::fmt</code> has many such <a href="/trait.html"><code>traits</code></a> and
each requires its own implementation. This is detailed further in
<a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>.</p>
<a class="header" href="print.html#activity-1" id="activity-1"><h3>Activity</h3></a>
<p>After checking the output of the above example, use the <code>Point2D</code> struct as
guide to add a Complex struct to the example. When printed in the same
way, the output should be:</p>
<pre><code>Display: 3.3 + 7.2i
Debug: Complex { real: 3.3, imag: 7.2 }
</code></pre>
<a class="header" href="print.html#see-also-3" id="see-also-3"><h3>See also</h3></a>
<p><a href="/trait/derive.html"><code>derive</code></a>, <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>, <a href="/macros.html">macros</a>, <a href="/custom_types/structs.html"><code>struct</code></a>,
<a href="/trait.html"><code>trait</code></a>, and <a href="/mod/use.html">use</a></p>
<a class="header" href="print.html#testcase-list" id="testcase-list"><h1>Testcase: List</h1></a>
<p>Implementing <code>fmt::Display</code> for a structure where the elements must each be
handled sequentially is tricky. The problem is that each <code>write!</code> generates a
<code>fmt::Result</code>. Proper handling of this requires dealing with <em>all</em> the
results. Rust provides the <code>?</code> operator for exactly this purpose.</p>
<p>Using <code>?</code> on <code>write!</code> looks like this:</p>
<pre><code class="language-rust ignore">// Try `write!` to see if it errors. If it errors, return
// the error. Otherwise continue.
write!(f, &quot;{}&quot;, value)?;
</code></pre>
<p>Alternatively, you can also use the <code>try!</code> macro, which works the same way.
This is a bit more verbose and no longer recommended, but you may still see it in
older Rust code. Using <code>try!</code> looks like this:</p>
<pre><code class="language-rust ignore">try!(write!(f, &quot;{}&quot;, value));
</code></pre>
<p>With <code>?</code> available, implementing <code>fmt::Display</code> for a <code>Vec</code> is
straightforward:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt; // Import the `fmt` module.

// Define a structure named `List` containing a `Vec`.
struct List(Vec&lt;i32&gt;);

impl fmt::Display for List {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // Extract the value using tuple indexing
        // and create a reference to `vec`.
        let vec = &amp;self.0;

        write!(f, &quot;[&quot;)?;

        // Iterate over `vec` in `v` while enumerating the iteration
        // count in `count`.
        for (count, v) in vec.iter().enumerate() {
            // For every element except the first, add a comma.
            // Use the ? operator, or try!, to return on errors.
            if count != 0 { write!(f, &quot;, &quot;)?; }
            write!(f, &quot;{}&quot;, v)?;
        }

        // Close the opened bracket and return a fmt::Result value
        write!(f, &quot;]&quot;)
    }
}

fn main() {
    let v = List(vec![1, 2, 3]);
    println!(&quot;{}&quot;, v);
}
</code></pre></pre>
<a class="header" href="print.html#activity-2" id="activity-2"><h3>Activity</h3></a>
<p>Try changing the program so that the index of each element in the vector is also printed. The new output should look like this:</p>
<pre><code class="language-rust ignore">[0: 1, 1: 2, 2: 3]
</code></pre>
<a class="header" href="print.html#see-also-4" id="see-also-4"><h3>See also</h3></a>
<p><a href="/flow_control/for.html"><code>for</code></a>, <a href="/scope/borrow/ref.html"><code>ref</code></a>, <a href="/std/result.html"><code>Result</code></a>, <a href="/custom_types/structs.html"><code>struct</code></a>,
<a href="/std/result/question_mark.html"><code>?</code></a>, and <a href="/std/vec.html"><code>vec!</code></a></p>
<a class="header" href="print.html#formatting" id="formatting"><h1>Formatting</h1></a>
<p>We've seen that formatting is specified via a <em>format string</em>:</p>
<ul>
<li><code>format!(&quot;{}&quot;, foo)</code> -&gt; <code>&quot;3735928559&quot;</code></li>
<li><code>format!(&quot;0x{:X}&quot;, foo)</code> -&gt;
<a href="https://en.wikipedia.org/wiki/Deadbeef#Magic_debug_values"><code>&quot;0xDEADBEEF&quot;</code></a></li>
<li><code>format!(&quot;0o{:o}&quot;, foo)</code> -&gt; <code>&quot;0o33653337357&quot;</code></li>
</ul>
<p>The same variable (<code>foo</code>) can be formatted differently depending on which
<em>argument type</em> is used: <code>X</code> vs <code>o</code> vs <em>unspecified</em>.</p>
<p>This formatting functionality is implemented via traits, and there is one trait
for each argument type. The most common formatting trait is <code>Display</code>, which
handles cases where the argument type is left unspecified: <code>{}</code> for instance.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt::{self, Formatter, Display};

struct City {
    name: &amp;'static str,
    // Latitude
    lat: f32,
    // Longitude
    lon: f32,
}

impl Display for City {
    // `f` is a buffer, this method must write the formatted string into it
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        let lat_c = if self.lat &gt;= 0.0 { 'N' } else { 'S' };
        let lon_c = if self.lon &gt;= 0.0 { 'E' } else { 'W' };

        // `write!` is like `format!`, but it will write the formatted string
        // into a buffer (the first argument)
        write!(f, &quot;{}: {:.3}°{} {:.3}°{}&quot;,
               self.name, self.lat.abs(), lat_c, self.lon.abs(), lon_c)
    }
}

#[derive(Debug)]
struct Color {
    red: u8,
    green: u8,
    blue: u8,
}

fn main() {
    for city in [
        City { name: &quot;Dublin&quot;, lat: 53.347778, lon: -6.259722 },
        City { name: &quot;Oslo&quot;, lat: 59.95, lon: 10.75 },
        City { name: &quot;Vancouver&quot;, lat: 49.25, lon: -123.1 },
    ].iter() {
        println!(&quot;{}&quot;, *city);
    }
    for color in [
        Color { red: 128, green: 255, blue: 90 },
        Color { red: 0, green: 3, blue: 254 },
        Color { red: 0, green: 0, blue: 0 },
    ].iter() {
        // Switch this to use {} once you've added an implementation
        // for fmt::Display
        println!(&quot;{:?}&quot;, *color)
    }
}
</code></pre></pre>
<p>You can view a <a href="https://doc.rust-lang.org/std/fmt/#formatting-traits">full list of formatting traits</a> and their argument
types in the <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a> documentation.</p>
<a class="header" href="print.html#activity-3" id="activity-3"><h3>Activity</h3></a>
<p>Add an implementation of the <code>fmt::Display</code> trait for the <code>Color</code> struct above
so that the output displays as:</p>
<pre><code class="language-text">RGB (128, 255, 90) 0x80FF5A
RGB (0, 3, 254) 0x0003FE
RGB (0, 0, 0) 0x000000
</code></pre>
<p>Two hints if you get stuck:</p>
<ul>
<li>You <a href="https://doc.rust-lang.org/std/fmt/#argument-types">may need to list each color more than once</a>,</li>
<li>You can <a href="https://doc.rust-lang.org/std/fmt/#width">pad with zeros to a width of 2</a> with <code>:02</code>.</li>
</ul>
<a class="header" href="print.html#see-also-5" id="see-also-5"><h3>See also</h3></a>
<p><a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a></p>
<a class="header" href="print.html#primitives" id="primitives"><h1>Primitives</h1></a>
<p>Rust provides access to a wide variety of <code>primitives</code>. A sample includes:</p>
<ul>
<li>signed integers: <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code> and <code>isize</code> (pointer size)</li>
<li>unsigned integers: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code> and <code>usize</code> (pointer size)</li>
<li>floating point: <code>f32</code>, <code>f64</code></li>
<li><code>char</code> Unicode scalar values like <code>'a'</code>, <code>'α'</code> and <code>'∞'</code> (4 bytes each)</li>
<li><code>bool</code> either <code>true</code> or <code>false</code></li>
<li>and the unit type <code>()</code>, whose only value is also <code>()</code></li>
<li>arrays like <code>[1, 2, 3]</code></li>
<li>tuples like <code>(1, true)</code></li>
</ul>
<p>Variables can always be <em>type annotated</em>. Numbers may additionally be
annotated via a <em>suffix</em> or <em>by default</em>. Integers default to <code>i32</code> and
floats to <code>f64</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // Variables can be type annotated.
    let logical: bool = true;

    let a_float: f64 = 1.0;  // Regular annotation
    let an_integer   = 5i32; // Suffix annotation

    // Or a default will be used.
    let default_float   = 3.0; // `f64`
    let default_integer = 7;   // `i32`

    let mut mutable = 12; // Mutable `i32`.

    // Error! The type of a variable can't be changed
    mutable = true;
}
</code></pre></pre>
<a class="header" href="print.html#see-also-6" id="see-also-6"><h3>See also:</h3></a>
<p><a href="https://doc.rust-lang.org/std/">the <code>std</code> library</a></p>
<a class="header" href="print.html#literals-and-operators" id="literals-and-operators"><h1>Literals and operators</h1></a>
<p>Integers <code>1</code>, floats <code>1.2</code>, characters <code>'a'</code>, strings <code>&quot;abc&quot;</code>, booleans <code>true</code>
and the unit type <code>()</code> can be expressed using literals.</p>
<p>Integers can, alternatively, be expressed using hexadecimal, octal or binary
notation using either of these prefixes: <code>0x</code>, <code>0o</code> or <code>0b</code>.</p>
<p>Underscores can be inserted in numeric literals to improve readability, e.g.
<code>1_000</code> is the same as <code>1000</code>, and <code>0.000_001</code> is the same as <code>0.000001</code>.</p>
<p>We need to tell the compiler the type of the literals we use. For now,
we'll use the <code>u32</code> suffix to indicate that the literal is an unsigned 32-bit
integer, and the <code>i32</code> suffix to indicate that it's a signed 32-bit integer.</p>
<p>The operators available and their precedence <a href="https://doc.rust-lang.org/reference/expressions.html#operator-precedence">in Rust</a> are similar to other
<a href="https://en.wikipedia.org/wiki/Operator_precedence#Programming_languages">C-like languages</a>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // Integer addition
    println!(&quot;1 + 2 = {}&quot;, 1u32 + 2);

    // Integer subtraction
    println!(&quot;1 - 2 = {}&quot;, 1i32 - 2);
    // TODO ^ Try changing `1i32` to `1u32` to see why the type is important

    // Short-circuiting boolean logic
    println!(&quot;true AND false is {}&quot;, true &amp;&amp; false);
    println!(&quot;true OR false is {}&quot;, true || false);
    println!(&quot;NOT true is {}&quot;, !true);

    // Bitwise operations
    println!(&quot;0011 AND 0101 is {:04b}&quot;, 0b0011u32 &amp; 0b0101);
    println!(&quot;0011 OR 0101 is {:04b}&quot;, 0b0011u32 | 0b0101);
    println!(&quot;0011 XOR 0101 is {:04b}&quot;, 0b0011u32 ^ 0b0101);
    println!(&quot;1 &lt;&lt; 5 is {}&quot;, 1u32 &lt;&lt; 5);
    println!(&quot;0x80 &gt;&gt; 2 is 0x{:x}&quot;, 0x80u32 &gt;&gt; 2);

    // Use underscores to improve readability!
    println!(&quot;One million is written as {}&quot;, 1_000_000u32);
}
</code></pre></pre>
<a class="header" href="print.html#tuples" id="tuples"><h1>Tuples</h1></a>
<p>A tuple is a collection of values of different types. Tuples are constructed
using parentheses <code>()</code>, and each tuple itself is a value with type signature
<code>(T1, T2, ...)</code>, where <code>T1</code>, <code>T2</code> are the types of its members. Functions can
use tuples to return multiple values, as tuples can hold any number of values.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Tuples can be used as function arguments and as return values
fn reverse(pair: (i32, bool)) -&gt; (bool, i32) {
    // `let` can be used to bind the members of a tuple to variables
    let (integer, boolean) = pair;

    (boolean, integer)
}

// The following struct is for the activity.
#[derive(Debug)]
struct Matrix(f32, f32, f32, f32);

fn main() {
    // A tuple with a bunch of different types
    let long_tuple = (1u8, 2u16, 3u32, 4u64,
                      -1i8, -2i16, -3i32, -4i64,
                      0.1f32, 0.2f64,
                      'a', true);

    // Values can be extracted from the tuple using tuple indexing
    println!(&quot;long tuple first value: {}&quot;, long_tuple.0);
    println!(&quot;long tuple second value: {}&quot;, long_tuple.1);

    // Tuples can be tuple members
    let tuple_of_tuples = ((1u8, 2u16, 2u32), (4u64, -1i8), -2i16);

    // Tuples are printable
    println!(&quot;tuple of tuples: {:?}&quot;, tuple_of_tuples);

    let pair = (1, true);
    println!(&quot;pair is {:?}&quot;, pair);

    println!(&quot;the reversed pair is {:?}&quot;, reverse(pair));

    // To create one element tuples, the comma is required to tell them apart
    // from a literal surrounded by parentheses
    println!(&quot;one element tuple: {:?}&quot;, (5u32,));
    println!(&quot;just an integer: {:?}&quot;, (5u32));

    //tuples can be destructured to create bindings
    let tuple = (1, &quot;hello&quot;, 4.5, true);

    let (a, b, c, d) = tuple;
    println!(&quot;{:?}, {:?}, {:?}, {:?}&quot;, a, b, c, d);

    let matrix = Matrix(1.1, 1.2, 2.1, 2.2);
    println!(&quot;{:?}&quot;, matrix)

}
</code></pre></pre>
<a class="header" href="print.html#activity-4" id="activity-4"><h3>Activity</h3></a>
<ol>
<li>
<p><em>Recap</em>: Add the <code>fmt::Display</code> trait to the Matrix <code>struct</code> in the above example,
so that if you switch from printing the debug format <code>{:?}</code> to the display
format <code>{}</code>, you see the following output:</p>
<pre><code class="language-text">( 1.1 1.2 )
( 2.1 2.2 )
</code></pre>
<p>You may want to refer back to the example for <a href="/hello/print/print_display.html">print display</a>.</p>
</li>
<li>
<p>Add a <code>transpose</code> function using the <code>reverse</code> function as a template, which
accepts a matrix as an argument, and returns a matrix in which two elements
have been swapped. For example:</p>
<pre><code class="language-rust ignore">println!(&quot;Matrix:\n{}&quot;, matrix);
println!(&quot;Transpose:\n{}&quot;, transpose(matrix));
</code></pre>
<p>results in the output:</p>
<pre><code class="language-text">Matrix:
( 1.1 1.2 )
( 2.1 2.2 )
Transpose:
( 1.1 2.1 )
( 1.2 2.2 )
</code></pre>
</li>
</ol>
<a class="header" href="print.html#arrays-and-slices" id="arrays-and-slices"><h1>Arrays and Slices</h1></a>
<p>An array is a collection of objects of the same type <code>T</code>, stored in contiguous
memory. Arrays are created using brackets <code>[]</code>, and their size, which is known
at compile time, is part of their type signature <code>[T; size]</code>.</p>
<p>Slices are similar to arrays, but their size is not known at compile time.
Instead, a slice is a two-word object, the first word is a pointer to the data,
and the second word is the length of the slice. The word size is the same as
usize, determined by the processor architecture eg 64 bits on an x86-64.
Slices can be used to borrow a section of an array, and have the type signature
<code>&amp;[T]</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">use std::mem;

// This function borrows a slice
fn analyze_slice(slice: &amp;[i32]) {
    println!(&quot;first element of the slice: {}&quot;, slice[0]);
    println!(&quot;the slice has {} elements&quot;, slice.len());
}

fn main() {
    // Fixed-size array (type signature is superfluous)
    let xs: [i32; 5] = [1, 2, 3, 4, 5];

    // All elements can be initialized to the same value
    let ys: [i32; 500] = [0; 500];

    // Indexing starts at 0
    println!(&quot;first element of the array: {}&quot;, xs[0]);
    println!(&quot;second element of the array: {}&quot;, xs[1]);

    // `len` returns the size of the array
    println!(&quot;array size: {}&quot;, xs.len());

    // Arrays are stack allocated
    println!(&quot;array occupies {} bytes&quot;, mem::size_of_val(&amp;xs));

    // Arrays can be automatically borrowed as slices
    println!(&quot;borrow the whole array as a slice&quot;);
    analyze_slice(&amp;xs);

    // Slices can point to a section of an array
    println!(&quot;borrow a section of the array as a slice&quot;);
    analyze_slice(&amp;ys[1 .. 4]);

    // Out of bound indexing yields a panic
    println!(&quot;{}&quot;, xs[5]);
}
</code></pre></pre>
<a class="header" href="print.html#custom-types" id="custom-types"><h1>Custom Types</h1></a>
<p>Rust custom data types are formed mainly through the two keywords:</p>
<ul>
<li><code>struct</code>: define a structure</li>
<li><code>enum</code>: define an enumeration</li>
</ul>
<p>Constants can also be created via the <code>const</code> and <code>static</code> keywords.</p>
<a class="header" href="print.html#structures" id="structures"><h1>Structures</h1></a>
<p>There are three types of structures (&quot;structs&quot;) that can be created using the
<code>struct</code> keyword:</p>
<ul>
<li>Tuple structs, which are, basically, named tuples.</li>
<li>The classic <a href="https://en.wikipedia.org/wiki/Struct_(C_programming_language)">C structs</a></li>
<li>Unit structs, which are field-less, are useful for generics.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">#[derive(Debug)]
struct Person&lt;'a&gt; {
    name: &amp;'a str,
    age: u8
}

// A unit struct
struct Nil;

// A tuple struct
struct Pair(i32, f32);

// A struct with two fields
struct Point {
    x: f32,
    y: f32,
}

// Structs can be reused as fields of another struct
#[allow(dead_code)]
struct Rectangle {
    p1: Point,
    p2: Point,
}

fn main() {
    // Create struct with field init shorthand
    let name = &quot;Peter&quot;;
    let age = 27;
    let peter = Person { name, age };
    
    // Print debug struct
    println!(&quot;{:?}&quot;, peter);
    
    
    // Instantiate a `Point`
    let point: Point = Point { x: 0.3, y: 0.4 };

    // Access the fields of the point
    println!(&quot;point coordinates: ({}, {})&quot;, point.x, point.y);

    // Destructure the point using a `let` binding
    let Point { x: my_x, y: my_y } = point;

    let _rectangle = Rectangle {
        // struct instantiation is an expression too
        p1: Point { x: my_y, y: my_x },
        p2: point,
    };

    // Instantiate a unit struct
    let _nil = Nil;

    // Instantiate a tuple struct
    let pair = Pair(1, 0.1);

    // Access the fields of a tuple struct
    println!(&quot;pair contains {:?} and {:?}&quot;, pair.0, pair.1);

    // Destructure a tuple struct
    let Pair(integer, decimal) = pair;

    println!(&quot;pair contains {:?} and {:?}&quot;, integer, decimal);
}
</code></pre></pre>
<a class="header" href="print.html#activity-5" id="activity-5"><h3>Activity</h3></a>
<ol>
<li>Add a function <code>rect_area</code> which calculates the area of a rectangle (try
using nested destructuring).</li>
<li>Add a function <code>square</code> which takes a <code>Point</code> and a <code>f32</code> as arguments, and returns a <code>Rectangle</code> with its lower left corner on the point, and a width and height corresponding to the <code>f32</code>.</li>
</ol>
<a class="header" href="print.html#see-also-7" id="see-also-7"><h3>See also:</h3></a>
<p><a href="/attribute.html"><code>attributes</code></a> and <a href="/flow_control/match/destructuring.html">destructuring</a></p>
<a class="header" href="print.html#enums" id="enums"><h1>Enums</h1></a>
<p>The <code>enum</code> keyword allows the creation of a type which may be one of a few
different variants. Any variant which is valid as a <code>struct</code> is also valid as
an <code>enum</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">// An attribute to hide warnings for unused code.
#![allow(dead_code)]

// Create an `enum` to classify someone. Note how both names
// and type information together specify the variant:
// `Engineer != Scientist` and `Height(i32) != Weight(i32)`. Each
// is different and independent.
enum Person {
    // An `enum` may either be `unit-like`,
    Engineer,
    Scientist,
    // like tuple structs,
    Height(i32),
    Weight(i32),
    // or like structures.
    Info { name: String, height: i32 }
}

// A function which takes a `Person` enum as an argument and
// returns nothing.
fn inspect(p: Person) {
    // Usage of an `enum` must cover all cases (irrefutable)
    // so a `match` is used to branch over it.
    match p {
        Person::Engineer  =&gt; println!(&quot;Is an engineer!&quot;),
        Person::Scientist =&gt; println!(&quot;Is a scientist!&quot;),
        // Destructure `i` from inside the `enum`.
        Person::Height(i) =&gt; println!(&quot;Has a height of {}.&quot;, i),
        Person::Weight(i) =&gt; println!(&quot;Has a weight of {}.&quot;, i),
        // Destructure `Info` into `name` and `height`.
        Person::Info { name, height } =&gt; {
            println!(&quot;{} is {} tall!&quot;, name, height);
        },
    }
}

fn main() {
    let person   = Person::Height(18);
    let amira    = Person::Weight(10);
    // `to_owned()` creates an owned `String` from a string slice.
    let dave     = Person::Info { name: &quot;Dave&quot;.to_owned(), height: 72 };
    let rebecca  = Person::Scientist;
    let rohan    = Person::Engineer;

    inspect(person);
    inspect(amira);
    inspect(dave);
    inspect(rebecca);
    inspect(rohan);
}

</code></pre></pre>
<a class="header" href="print.html#see-also-8" id="see-also-8"><h3>See also:</h3></a>
<p><a href="/attribute.html"><code>attributes</code></a>, <a href="/flow_control/match.html"><code>match</code></a>, <a href="/fn.html"><code>fn</code></a>, and <a href="/std/str.html"><code>String</code></a></p>
<a class="header" href="print.html#use" id="use"><h1>use</h1></a>
<p>The <code>use</code> declaration can be used so manual scoping isn't needed:</p>
<pre><pre class="playpen"><code class="language-rust editable">// An attribute to hide warnings for unused code.
#![allow(dead_code)]

enum Status {
    Rich,
    Poor,
}

enum Work {
    Civilian,
    Soldier,
}

fn main() {
    // Explicitly `use` each name so they are available without
    // manual scoping.
    use Status::{Poor, Rich};
    // Automatically `use` each name inside `Work`.
    use Work::*;

    // Equivalent to `Status::Poor`.
    let status = Poor;
    // Equivalent to `Work::Civilian`.
    let work = Civilian;

    match status {
        // Note the lack of scoping because of the explicit `use` above.
        Rich =&gt; println!(&quot;The rich have lots of money!&quot;),
        Poor =&gt; println!(&quot;The poor have no money...&quot;),
    }

    match work {
        // Note again the lack of scoping.
        Civilian =&gt; println!(&quot;Civilians work!&quot;),
        Soldier  =&gt; println!(&quot;Soldiers fight!&quot;),
    }
}
</code></pre></pre>
<a class="header" href="print.html#see-also-9" id="see-also-9"><h3>See also:</h3></a>
<p><a href="/flow_control/match.html"><code>match</code></a> and <a href="/mod/use.html"><code>use</code></a></p>
<a class="header" href="print.html#c-like" id="c-like"><h1>C-like</h1></a>
<p><code>enum</code> can also be used as C-like enums.</p>
<pre><pre class="playpen"><code class="language-rust editable">// An attribute to hide warnings for unused code.
#![allow(dead_code)]

// enum with implicit discriminator (starts at 0)
enum Number {
    Zero,
    One,
    Two,
}

// enum with explicit discriminator
enum Color {
    Red = 0xff0000,
    Green = 0x00ff00,
    Blue = 0x0000ff,
}

fn main() {
    // `enums` can be cast as integers.
    println!(&quot;zero is {}&quot;, Number::Zero as i32);
    println!(&quot;one is {}&quot;, Number::One as i32);

    println!(&quot;roses are #{:06x}&quot;, Color::Red as i32);
    println!(&quot;violets are #{:06x}&quot;, Color::Blue as i32);
}
</code></pre></pre>
<a class="header" href="print.html#see-also-10" id="see-also-10"><h3>See also:</h3></a>
<p><a href="/cast.html">casting</a></p>
<a class="header" href="print.html#testcase-linked-list" id="testcase-linked-list"><h1>Testcase: linked-list</h1></a>
<p>A common use for <code>enums</code> is to create a linked-list:</p>
<pre><pre class="playpen"><code class="language-rust editable">use List::*;

enum List {
    // Cons: Tuple struct that wraps an element and a pointer to the next node
    Cons(u32, Box&lt;List&gt;),
    // Nil: A node that signifies the end of the linked list
    Nil,
}

// Methods can be attached to an enum
impl List {
    // Create an empty list
    fn new() -&gt; List {
        // `Nil` has type `List`
        Nil
    }

    // Consume a list, and return the same list with a new element at its front
    fn prepend(self, elem: u32) -&gt; List {
        // `Cons` also has type List
        Cons(elem, Box::new(self))
    }

    // Return the length of the list
    fn len(&amp;self) -&gt; u32 {
        // `self` has to be matched, because the behavior of this method
        // depends on the variant of `self`
        // `self` has type `&amp;List`, and `*self` has type `List`, matching on a
        // concrete type `T` is preferred over a match on a reference `&amp;T`
        match *self {
            // Can't take ownership of the tail, because `self` is borrowed;
            // instead take a reference to the tail
            Cons(_, ref tail) =&gt; 1 + tail.len(),
            // Base Case: An empty list has zero length
            Nil =&gt; 0
        }
    }

    // Return representation of the list as a (heap allocated) string
    fn stringify(&amp;self) -&gt; String {
        match *self {
            Cons(head, ref tail) =&gt; {
                // `format!` is similar to `print!`, but returns a heap
                // allocated string instead of printing to the console
                format!(&quot;{}, {}&quot;, head, tail.stringify())
            },
            Nil =&gt; {
                format!(&quot;Nil&quot;)
            },
        }
    }
}

fn main() {
    // Create an empty linked list
    let mut list = List::new();

    // Append some elements
    list = list.prepend(1);
    list = list.prepend(2);
    list = list.prepend(3);

    // Show the final state of the list
    println!(&quot;linked list has length: {}&quot;, list.len());
    println!(&quot;{}&quot;, list.stringify());
}
</code></pre></pre>
<a class="header" href="print.html#see-also-11" id="see-also-11"><h3>See also:</h3></a>
<p><a href="/std/box.html"><code>Box</code></a> and <a href="/fn/methods.html">methods</a></p>
<a class="header" href="print.html#constants" id="constants"><h1>constants</h1></a>
<p>Rust has two different types of constants which can be declared in any scope
including global. Both require explicit type annotation:</p>
<ul>
<li><code>const</code>: An unchangeable value (the common case).</li>
<li><code>static</code>: A possibly <code>mut</code>able variable with <a href="/scope/lifetime/static_lifetime.html"><code>'static</code></a> lifetime.</li>
</ul>
<p>One special case is the <code>&quot;string&quot;</code> literal. It can be assigned directly to a
<code>static</code> variable without modification because its type signature:
<code>&amp;'static str</code> has the required lifetime of <code>'static</code>. All other reference
types must be specifically annotated so that they fulfill the <code>'static</code>
lifetime. This may seem minor though because the required explicit annotation
hides the distinction.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// Globals are declared outside all other scopes.
static LANGUAGE: &amp;'static str = &quot;Rust&quot;;
const  THRESHOLD: i32 = 10;

fn is_big(n: i32) -&gt; bool {
    // Access constant in some function
    n &gt; THRESHOLD
}

fn main() {
    let n = 16;

    // Access constant in the main thread
    println!(&quot;This is {}&quot;, LANGUAGE);
    println!(&quot;The threshold is {}&quot;, THRESHOLD);
    println!(&quot;{} is {}&quot;, n, if is_big(n) { &quot;big&quot; } else { &quot;small&quot; });

    // Error! Cannot modify a `const`.
    THRESHOLD = 5;
    // FIXME ^ Comment out this line
}
</code></pre></pre>
<a class="header" href="print.html#see-also-12" id="see-also-12"><h3>See also:</h3></a>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0246-const-vs-static.md">The <code>const</code>/<code>static</code> RFC</a>,
<a href="/scope/lifetime/static_lifetime.html"><code>'static</code> lifetime</a></p>
<a class="header" href="print.html#variable-bindings" id="variable-bindings"><h1>Variable Bindings</h1></a>
<p>Rust provides type safety via static typing. Variable bindings can be type
annotated when declared. However, in most cases, the compiler will be able
to infer the type of the variable from the context, heavily reducing the
annotation burden.</p>
<p>Values (like literals) can be bound to variables, using the <code>let</code> binding.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let an_integer = 1u32;
    let a_boolean = true;
    let unit = ();

    // copy `an_integer` into `copied_integer`
    let copied_integer = an_integer;

    println!(&quot;An integer: {:?}&quot;, copied_integer);
    println!(&quot;A boolean: {:?}&quot;, a_boolean);
    println!(&quot;Meet the unit value: {:?}&quot;, unit);

    // The compiler warns about unused variable bindings; these warnings can
    // be silenced by prefixing the variable name with an underscore
    let _unused_variable = 3u32;

    let noisy_unused_variable = 2u32;
    // FIXME ^ Prefix with an underscore to suppress the warning
}
</code></pre></pre>
<a class="header" href="print.html#mutability" id="mutability"><h1>Mutability</h1></a>
<p>Variable bindings are immutable by default, but this can be overridden using
the <code>mut</code> modifier.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    let _immutable_binding = 1;
    let mut mutable_binding = 1;

    println!(&quot;Before mutation: {}&quot;, mutable_binding);

    // Ok
    mutable_binding += 1;

    println!(&quot;After mutation: {}&quot;, mutable_binding);

    // Error!
    _immutable_binding += 1;
    // FIXME ^ Comment out this line
}
</code></pre></pre>
<p>The compiler will throw a detailed diagnostic about mutability errors.</p>
<a class="header" href="print.html#scope-and-shadowing" id="scope-and-shadowing"><h1>Scope and Shadowing</h1></a>
<p>Variable bindings have a scope, and are constrained to live in a <em>block</em>. A
block is a collection of statements enclosed by braces <code>{}</code>. Also, <a href="https://en.wikipedia.org/wiki/Variable_shadowing">variable
shadowing</a> is allowed.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // This binding lives in the main function
    let long_lived_binding = 1;

    // This is a block, and has a smaller scope than the main function
    {
        // This binding only exists in this block
        let short_lived_binding = 2;

        println!(&quot;inner short: {}&quot;, short_lived_binding);

        // This binding *shadows* the outer one
        let long_lived_binding = 5_f32;

        println!(&quot;inner long: {}&quot;, long_lived_binding);
    }
    // End of the block

    // Error! `short_lived_binding` doesn't exist in this scope
    println!(&quot;outer short: {}&quot;, short_lived_binding);
    // FIXME ^ Comment out this line

    println!(&quot;outer long: {}&quot;, long_lived_binding);
    
    // This binding also *shadows* the previous binding
    let long_lived_binding = 'a';
    
    println!(&quot;outer long: {}&quot;, long_lived_binding);
}
</code></pre></pre>
<a class="header" href="print.html#declare-first" id="declare-first"><h1>Declare first</h1></a>
<p>It's possible to declare variable bindings first, and initialize them later.
However, this form is seldom used, as it may lead to the use of uninitialized
variables.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // Declare a variable binding
    let a_binding;

    {
        let x = 2;

        // Initialize the binding
        a_binding = x * x;
    }

    println!(&quot;a binding: {}&quot;, a_binding);

    let another_binding;

    // Error! Use of uninitialized binding
    println!(&quot;another binding: {}&quot;, another_binding);
    // FIXME ^ Comment out this line

    another_binding = 1;

    println!(&quot;another binding: {}&quot;, another_binding);
}
</code></pre></pre>
<p>The compiler forbids use of uninitialized variables, as this would lead to
undefined behavior.</p>
<a class="header" href="print.html#casting" id="casting"><h1>Casting</h1></a>
<p>Rust provides no implicit type conversion (coercion) between primitive types.
But, explicit type conversion (casting) can be performed using the <code>as</code> keyword.</p>
<p>Rules for converting between integral types follow C conventions generally,
except in cases where C has undefined behavior. The behavior of all casts
between integral types is well defined in Rust.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// Suppress all warnings from casts which overflow.
#![allow(overflowing_literals)]

fn main() {
    let decimal = 65.4321_f32;

    // Error! No implicit conversion
    let integer: u8 = decimal;
    // FIXME ^ Comment out this line

    // Explicit conversion
    let integer = decimal as u8;
    let character = integer as char;

    println!(&quot;Casting: {} -&gt; {} -&gt; {}&quot;, decimal, integer, character);

    // when casting any value to an unsigned type, T, 
    // std::T::MAX + 1 is added or subtracted until the value
    // fits into the new type

    // 1000 already fits in a u16
    println!(&quot;1000 as a u16 is: {}&quot;, 1000 as u16);

    // 1000 - 256 - 256 - 256 = 232
    // Under the hood, the first 8 least significant bits (LSB) are kept,
    // while the rest towards the most significant bit (MSB) get truncated.
    println!(&quot;1000 as a u8 is : {}&quot;, 1000 as u8);
    // -1 + 256 = 255
    println!(&quot;  -1 as a u8 is : {}&quot;, (-1i8) as u8);

    // For positive numbers, this is the same as the modulus
    println!(&quot;1000 mod 256 is : {}&quot;, 1000 % 256);

    // When casting to a signed type, the (bitwise) result is the same as 
    // first casting to the corresponding unsigned type. If the most significant 
    // bit of that value is 1, then the value is negative.

    // Unless it already fits, of course.
    println!(&quot; 128 as a i16 is: {}&quot;, 128 as i16);
    // 128 as u8 -&gt; 128, whose two's complement in eight bits is:
    println!(&quot; 128 as a i8 is : {}&quot;, 128 as i8);

    // repeating the example above
    // 1000 as u8 -&gt; 232
    println!(&quot;1000 as a i8 is : {}&quot;, 1000 as i8);
    // and the two's complement of 232 is -24
    println!(&quot; 232 as a i8 is : {}&quot;, 232 as i8);
}
</code></pre></pre>
<a class="header" href="print.html#literals" id="literals"><h1>Literals</h1></a>
<p>Numeric literals can be type annotated by adding the type as a suffix. As an example,
to specify that the literal <code>42</code> should have the type <code>i32</code>, write <code>42i32</code>.</p>
<p>The type of unsuffixed numeric literals will depend on how they are used. If no
constraint exists, the compiler will use <code>i32</code> for integers, and <code>f64</code> for
floating-point numbers.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // Suffixed literals, their types are known at initialization
    let x = 1u8;
    let y = 2u32;
    let z = 3f32;

    // Unsuffixed literal, their types depend on how they are used
    let i = 1;
    let f = 1.0;

    // `size_of_val` returns the size of a variable in bytes
    println!(&quot;size of `x` in bytes: {}&quot;, std::mem::size_of_val(&amp;x));
    println!(&quot;size of `y` in bytes: {}&quot;, std::mem::size_of_val(&amp;y));
    println!(&quot;size of `z` in bytes: {}&quot;, std::mem::size_of_val(&amp;z));
    println!(&quot;size of `i` in bytes: {}&quot;, std::mem::size_of_val(&amp;i));
    println!(&quot;size of `f` in bytes: {}&quot;, std::mem::size_of_val(&amp;f));
}
</code></pre></pre>
<p>There are some concepts used in the previous code that haven't been explained
yet, here's a brief explanation for the impatient readers:</p>
<ul>
<li><code>fun(&amp;foo)</code> is used to pass an argument to a function <em>by reference</em>, rather
than by value (<code>fun(foo)</code>). For more details see <a href="/scope/borrow.html">borrowing</a>.</li>
<li><code>std::mem::size_of_val</code> is a function, but called with its <em>full path</em>. Code
can be split in logical units called <em>modules</em>. In this case, the
<code>size_of_val</code> function is defined in the <code>mem</code> module, and the <code>mem</code> module
is defined in the <code>std</code> <em>crate</em>. For more details, see
<a href="/mod.html">modules</a> and <a href="/crates.html">crates</a>.</li>
</ul>
<a class="header" href="print.html#inference" id="inference"><h1>Inference</h1></a>
<p>The type inference engine is pretty smart. It does more than looking at the
type of the
<a href="https://en.wikipedia.org/wiki/Value_%28computer_science%29#lrvalue">r-value</a>
during an initialization. It also looks at how the variable is used afterwards
to infer its type. Here's an advanced example of type inference:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // Because of the annotation, the compiler knows that `elem` has type u8.
    let elem = 5u8;

    // Create an empty vector (a growable array).
    let mut vec = Vec::new();
    // At this point the compiler doesn't know the exact type of `vec`, it
    // just knows that it's a vector of something (`Vec&lt;_&gt;`).

    // Insert `elem` in the vector.
    vec.push(elem);
    // Aha! Now the compiler knows that `vec` is a vector of `u8`s (`Vec&lt;u8&gt;`)
    // TODO ^ Try commenting out the `vec.push(elem)` line

    println!(&quot;{:?}&quot;, vec);
}
</code></pre></pre>
<p>No type annotation of variables was needed, the compiler is happy and so is the
programmer!</p>
<a class="header" href="print.html#aliasing" id="aliasing"><h1>Aliasing</h1></a>
<p>The <code>type</code> statement can be used to give a new name to an existing type. Types
must have <code>CamelCase</code> names, or the compiler will raise a warning. The
exception to this rule are the primitive types: <code>usize</code>, <code>f32</code>, etc.</p>
<pre><pre class="playpen"><code class="language-rust editable">// `NanoSecond` is a new name for `u64`.
type NanoSecond = u64;
type Inch = u64;

// Use an attribute to silence warning.
#[allow(non_camel_case_types)]
type u64_t = u64;
// TODO ^ Try removing the attribute

fn main() {
    // `NanoSecond` = `Inch` = `u64_t` = `u64`.
    let nanoseconds: NanoSecond = 5 as u64_t;
    let inches: Inch = 2 as u64_t;

    // Note that type aliases *don't* provide any extra type safety, because
    // aliases are *not* new types
    println!(&quot;{} nanoseconds + {} inches = {} unit?&quot;,
             nanoseconds,
             inches,
             nanoseconds + inches);
}
</code></pre></pre>
<p>The main use of aliases is to reduce boilerplate; for example the <code>IoResult&lt;T&gt;</code> type
is an alias for the <code>Result&lt;T, IoError&gt;</code> type.</p>
<a class="header" href="print.html#see-also-13" id="see-also-13"><h3>See also:</h3></a>
<p><a href="/attribute.html">Attributes</a></p>
<a class="header" href="print.html#expressions" id="expressions"><h1>Expressions</h1></a>
<p>A Rust program is (mostly) made up of a series of statements:</p>
<pre><code>fn main() {
    // statement
    // statement
    // statement
}
</code></pre>
<p>There are a few kinds of statements in Rust. The most common two are declaring
a variable binding, and using a <code>;</code> with an expression:</p>
<pre><code>fn main() {
    // variable binding
    let x = 5;

    // expression;
    x;
    x + 1;
    15;
}
</code></pre>
<p>Blocks are expressions too, so they can be used as <a href="https://en.wikipedia.org/wiki/Value_%28computer_science%29#lrvalue">r-values</a> in
assignments. The last expression in the block will be assigned to the
<a href="https://en.wikipedia.org/wiki/Value_%28computer_science%29#lrvalue">l-value</a>. However, if the last expression of the block ends with a
semicolon, the return value will be <code>()</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let x = 5u32;

    let y = {
        let x_squared = x * x;
        let x_cube = x_squared * x;

        // This expression will be assigned to `y`
        x_cube + x_squared + x
    };

    let z = {
        // The semicolon suppresses this expression and `()` is assigned to `z`
        2 * x;
    };

    println!(&quot;x is {:?}&quot;, x);
    println!(&quot;y is {:?}&quot;, y);
    println!(&quot;z is {:?}&quot;, z);
}
</code></pre></pre>
<a class="header" href="print.html#flow-control" id="flow-control"><h1>Flow Control</h1></a>
<p>An essential part of any programming languages are ways to modify control flow:
<code>if</code>/<code>else</code>, <code>for</code>, and others. Let's talk about them in Rust.</p>
<a class="header" href="print.html#ifelse" id="ifelse"><h1>if/else</h1></a>
<p>Branching with <code>if</code>-<code>else</code> is similar to other languages. Unlike many of them,
the boolean condition doesn't need to be surrounded by parentheses, and each
condition is followed by a block. <code>if</code>-<code>else</code> conditionals are expressions,
and, all branches must return the same type.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let n = 5;

    if n &lt; 0 {
        print!(&quot;{} is negative&quot;, n);
    } else if n &gt; 0 {
        print!(&quot;{} is positive&quot;, n);
    } else {
        print!(&quot;{} is zero&quot;, n);
    }

    let big_n =
        if n &lt; 10 &amp;&amp; n &gt; -10 {
            println!(&quot;, and is a small number, increase ten-fold&quot;);

            // This expression returns an `i32`.
            10 * n
        } else {
            println!(&quot;, and is a big number, reduce by two&quot;);

            // This expression must return an `i32` as well.
            n / 2
            // TODO ^ Try suppressing this expression with a semicolon.
        };
    //   ^ Don't forget to put a semicolon here! All `let` bindings need it.

    println!(&quot;{} -&gt; {}&quot;, n, big_n);
}
</code></pre></pre>
<a class="header" href="print.html#loop" id="loop"><h1>loop</h1></a>
<p>Rust provides a <code>loop</code> keyword to indicate an infinite loop.</p>
<p>The <code>break</code> statement can be used to exit a loop at anytime, whereas the
<code>continue</code> statement can be used to skip the rest of the iteration and start a
new one.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let mut count = 0u32;

    println!(&quot;Let's count until infinity!&quot;);

    // Infinite loop
    loop {
        count += 1;

        if count == 3 {
            println!(&quot;three&quot;);

            // Skip the rest of this iteration
            continue;
        }

        println!(&quot;{}&quot;, count);

        if count == 5 {
            println!(&quot;OK, that's enough&quot;);

            // Exit this loop
            break;
        }
    }
}
</code></pre></pre>
<a class="header" href="print.html#nesting-and-labels" id="nesting-and-labels"><h1>Nesting and labels</h1></a>
<p>It's possible to <code>break</code> or <code>continue</code> outer loops when dealing with nested
loops. In these cases, the loops must be annotated with some <code>'label</code>, and the
label must be passed to the <code>break</code>/<code>continue</code> statement.</p>
<pre><pre class="playpen"><code class="language-rust editable">#![allow(unreachable_code)]

fn main() {
    'outer: loop {
        println!(&quot;Entered the outer loop&quot;);

        'inner: loop {
            println!(&quot;Entered the inner loop&quot;);

            // This would break only the inner loop
            //break;

            // This breaks the outer loop
            break 'outer;
        }

        println!(&quot;This point will never be reached&quot;);
    }

    println!(&quot;Exited the outer loop&quot;);
}
</code></pre></pre>
<a class="header" href="print.html#returning-from-loops" id="returning-from-loops"><h1>Returning from loops</h1></a>
<p>One of the uses of a <code>loop</code> is to retry an operation until it succeded. If the
operation returns a value though, you might need to pass it to the rest of the
code: put it after the <code>break</code>, and it will be returned by the <code>loop</code>
expression.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    assert_eq!(result, 20);
}
</code></pre></pre>
<a class="header" href="print.html#while" id="while"><h1>while</h1></a>
<p>The <code>while</code> keyword can be used to loop until a condition is met.</p>
<p>Let's write the infamous <a href="https://en.wikipedia.org/wiki/Fizz_buzz">FizzBuzz</a> using a <code>while</code> loop.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // A counter variable
    let mut n = 1;

    // Loop while `n` is less than 101
    while n &lt; 101 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }

        // Increment counter
        n += 1;
    }
}
</code></pre></pre>
<a class="header" href="print.html#for-and-range" id="for-and-range"><h1>for and range</h1></a>
<p>The <code>for in</code> construct can be used to iterate through an <code>Iterator</code>.
One of the easiest ways to create an iterator is to use the range
notation <code>a..b</code>. This yields values from <code>a</code> (inclusive) to <code>b</code>
(exclusive) in steps of one.</p>
<p>Let's write FizzBuzz using <code>for</code> instead of <code>while</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // `n` will take the values: 1, 2, ..., 100 in each iteration
    for n in 1..101 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }
    }
}
</code></pre></pre>
<a class="header" href="print.html#see-also-14" id="see-also-14"><h3>See also</h3></a>
<p><a href="/trait/iter.html">Iterator</a></p>
<a class="header" href="print.html#match" id="match"><h1>match</h1></a>
<p>Rust provides pattern matching via the <code>match</code> keyword, which can be used like
a C <code>switch</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let number = 13;
    // TODO ^ Try different values for `number`

    println!(&quot;Tell me about {}&quot;, number);
    match number {
        // Match a single value
        1 =&gt; println!(&quot;One!&quot;),
        // Match several values
        2 | 3 | 5 | 7 | 11 =&gt; println!(&quot;This is a prime&quot;),
        // Match an inclusive range
        13...19 =&gt; println!(&quot;A teen&quot;),
        // Handle the rest of cases
        _ =&gt; println!(&quot;Ain't special&quot;),
    }

    let boolean = true;
    // Match is an expression too
    let binary = match boolean {
        // The arms of a match must cover all the possible values
        false =&gt; 0,
        true =&gt; 1,
        // TODO ^ Try commenting out one of these arms
    };

    println!(&quot;{} -&gt; {}&quot;, boolean, binary);
}
</code></pre></pre>
<a class="header" href="print.html#destructuring" id="destructuring"><h1>Destructuring</h1></a>
<p>A <code>match</code> block can destructure items in a variety of ways.</p>
<a class="header" href="print.html#tuples-1" id="tuples-1"><h1>tuples</h1></a>
<p>Tuples can be destructured in a <code>match</code> as follows:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let pair = (0, -2);
    // TODO ^ Try different values for `pair`

    println!(&quot;Tell me about {:?}&quot;, pair);
    // Match can be used to destructure a tuple
    match pair {
        // Destructure the second
        (0, y) =&gt; println!(&quot;First is `0` and `y` is `{:?}`&quot;, y),
        (x, 0) =&gt; println!(&quot;`x` is `{:?}` and last is `0`&quot;, x),
        _      =&gt; println!(&quot;It doesn't matter what they are&quot;),
        // `_` means don't bind the value to a variable
    }
}
</code></pre></pre>
<a class="header" href="print.html#see-also-15" id="see-also-15"><h3>See also:</h3></a>
<p><a href="/primitives/tuples.html">Tuples</a></p>
<a class="header" href="print.html#enums-1" id="enums-1"><h1>enums</h1></a>
<p>An <code>enum</code> is destructured similarly:</p>
<pre><pre class="playpen"><code class="language-rust editable">// `allow` required to silence warnings because only
// one variant is used.
#[allow(dead_code)]
enum Color {
    // These 3 are specified solely by their name.
    Red,
    Blue,
    Green,
    // These likewise tie `u32` tuples to different names: color models.
    RGB(u32, u32, u32),
    HSV(u32, u32, u32),
    HSL(u32, u32, u32),
    CMY(u32, u32, u32),
    CMYK(u32, u32, u32, u32),
}

fn main() {
    let color = Color::RGB(122, 17, 40);
    // TODO ^ Try different variants for `color`

    println!(&quot;What color is it?&quot;);
    // An `enum` can be destructured using a `match`.
    match color {
        Color::Red   =&gt; println!(&quot;The color is Red!&quot;),
        Color::Blue  =&gt; println!(&quot;The color is Blue!&quot;),
        Color::Green =&gt; println!(&quot;The color is Green!&quot;),
        Color::RGB(r, g, b) =&gt;
            println!(&quot;Red: {}, green: {}, and blue: {}!&quot;, r, g, b),
        Color::HSV(h, s, v) =&gt;
            println!(&quot;Hue: {}, saturation: {}, value: {}!&quot;, h, s, v),
        Color::HSL(h, s, l) =&gt;
            println!(&quot;Hue: {}, saturation: {}, lightness: {}!&quot;, h, s, l),
        Color::CMY(c, m, y) =&gt;
            println!(&quot;Cyan: {}, magenta: {}, yellow: {}!&quot;, c, m, y),
        Color::CMYK(c, m, y, k) =&gt;
            println!(&quot;Cyan: {}, magenta: {}, yellow: {}, key (black): {}!&quot;,
                c, m, y, k),
        // Don't need another arm because all variants have been examined
    }
}
</code></pre></pre>
<a class="header" href="print.html#see-also-16" id="see-also-16"><h3>See also:</h3></a>
<p><a href="/attribute/unused.html"><code>#[allow(...)]</code></a>, <a href="https://en.wikipedia.org/wiki/Color_model">color models</a> and <a href="/custom_types/enum.html"><code>enum</code></a></p>
<a class="header" href="print.html#pointersref" id="pointersref"><h1>pointers/ref</h1></a>
<p>For pointers, a distinction needs to be made between destructuring
and dereferencing as they are different concepts which are used
differently from a language like <code>C</code>.</p>
<ul>
<li>Dereferencing uses <code>*</code></li>
<li>Destructuring uses <code>&amp;</code>, <code>ref</code>, and <code>ref mut</code></li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // Assign a reference of type `i32`. The `&amp;` signifies there
    // is a reference being assigned.
    let reference = &amp;4;

    match reference {
        // If `reference`s is pattern matched against `&amp;val`, it results
        // in a comparison like:
        // `&amp;i32`
        // `&amp;val`
        // ^ We see that if the matching `&amp;`s are dropped, then the `i32`
        // should be assigned to `val`.
        &amp;val =&gt; println!(&quot;Got a value via destructuring: {:?}&quot;, val),
    }

    // To avoid the `&amp;`, you dereference before matching.
    match *reference {
        val =&gt; println!(&quot;Got a value via dereferencing: {:?}&quot;, val),
    }

    // What if you don't start with a reference? `reference` was a `&amp;`
    // because the right side was already a reference. This is not
    // a reference because the right side is not one.
    let _not_a_reference = 3;

    // Rust provides `ref` for exactly this purpose. It modifies the
    // assignment so that a reference is created for the element; this
    // reference is assigned.
    let ref _is_a_reference = 3;

    // Accordingly, by defining 2 values without references, references
    // can be retrieved via `ref` and `ref mut`.
    let value = 5;
    let mut mut_value = 6;

    // Use `ref` keyword to create a reference.
    match value {
        ref r =&gt; println!(&quot;Got a reference to a value: {:?}&quot;, r),
    }

    // Use `ref mut` similarly.
    match mut_value {
        ref mut m =&gt; {
            // Got a reference. Gotta dereference it before we can
            // add anything to it.
            *m += 10;
            println!(&quot;We added 10. `mut_value`: {:?}&quot;, m);
        },
    }
}
</code></pre></pre>
<a class="header" href="print.html#structs" id="structs"><h1>structs</h1></a>
<p>Similarly, a <code>struct</code> can be destructured as shown:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    struct Foo { x: (u32, u32), y: u32 }

    // destructure members of the struct
    let foo = Foo { x: (1, 2), y: 3 };
    let Foo { x: (a, b), y } = foo;

    println!(&quot;a = {}, b = {},  y = {} &quot;, a, b, y);

    // you can destructure structs and rename the variables,
    // the order is not important

    let Foo { y: i, x: j } = foo;
    println!(&quot;i = {:?}, j = {:?}&quot;, i, j);

    // and you can also ignore some variables:
    let Foo { y, .. } = foo;
    println!(&quot;y = {}&quot;, y);

    // this will give an error: pattern does not mention field `x`
    // let Foo { y } = foo;
}
</code></pre></pre>
<a class="header" href="print.html#see-also-17" id="see-also-17"><h3>See also:</h3></a>
<p><a href="/custom_types/structs.html">Structs</a>, <a href="/scope/borrow/ref.html">The ref pattern</a></p>
<a class="header" href="print.html#guards" id="guards"><h1>Guards</h1></a>
<p>A <code>match</code> <em>guard</em> can be added to filter the arm.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let pair = (2, -2);
    // TODO ^ Try different values for `pair`

    println!(&quot;Tell me about {:?}&quot;, pair);
    match pair {
        (x, y) if x == y =&gt; println!(&quot;These are twins&quot;),
        // The ^ `if condition` part is a guard
        (x, y) if x + y == 0 =&gt; println!(&quot;Antimatter, kaboom!&quot;),
        (x, _) if x % 2 == 1 =&gt; println!(&quot;The first one is odd&quot;),
        _ =&gt; println!(&quot;No correlation...&quot;),
    }
}
</code></pre></pre>
<a class="header" href="print.html#see-also-18" id="see-also-18"><h3>See also:</h3></a>
<p><a href="/primitives/tuples.html">Tuples</a></p>
<a class="header" href="print.html#binding" id="binding"><h1>Binding</h1></a>
<p>Indirectly accessing a variable makes it impossible to branch and use that
variable without re-binding. <code>match</code> provides the <code>@</code> sigil for binding values to
names:</p>
<pre><pre class="playpen"><code class="language-rust editable">// A function `age` which returns a `u32`.
fn age() -&gt; u32 {
    15
}

fn main() {
    println!(&quot;Tell me type of person you are&quot;);

    match age() {
        0             =&gt; println!(&quot;I'm not born yet I guess&quot;),
        // Could `match` 1 ... 12 directly but then what age
        // would the child be? Instead, bind to `n` for the
        // sequence of 1 .. 12. Now the age can be reported.
        n @ 1  ... 12 =&gt; println!(&quot;I'm a child of age {:?}&quot;, n),
        n @ 13 ... 19 =&gt; println!(&quot;I'm a teen of age {:?}&quot;, n),
        // Nothing bound. Return the result.
        n             =&gt; println!(&quot;I'm an old person of age {:?}&quot;, n),
    }
}
</code></pre></pre>
<a class="header" href="print.html#see-also-19" id="see-also-19"><h3>See also:</h3></a>
<p><a href="/fn.html">functions</a></p>
<a class="header" href="print.html#if-let" id="if-let"><h1>if let</h1></a>
<p>For some use cases, <code>match</code> is awkward. For example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Make `optional` of type `Option&lt;i32&gt;`
let optional = Some(7);

match optional {
    Some(i) =&gt; {
        println!(&quot;This is a really long string and `{:?}`&quot;, i);
        // ^ Needed 2 indentations just so we could destructure
        // `i` from the option.
    },
    _ =&gt; {},
    // ^ Required because `match` is exhaustive. Doesn't it seem
    // like wasted space?
};

#}</code></pre></pre>
<p><code>if let</code> is cleaner for this use case and in addition allows various
failure options to be specified:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // All have type `Option&lt;i32&gt;`
    let number = Some(7);
    let letter: Option&lt;i32&gt; = None;
    let emoticon: Option&lt;i32&gt; = None;

    // The `if let` construct reads: &quot;if `let` destructures `number` into
    // `Some(i)`, evaluate the block (`{}`).
    if let Some(i) = number {
        println!(&quot;Matched {:?}!&quot;, i);
    }

    // If you need to specify a failure, use an else:
    if let Some(i) = letter {
        println!(&quot;Matched {:?}!&quot;, i);
    } else {
        // Destructure failed. Change to the failure case.
        println!(&quot;Didn't match a number. Let's go with a letter!&quot;);
    };

    // Provide an altered failing condition.
    let i_like_letters = false;

    if let Some(i) = emoticon {
        println!(&quot;Matched {:?}!&quot;, i);
    // Destructure failed. Evaluate an `else if` condition to see if the
    // alternate failure branch should be taken:
    } else if i_like_letters {
        println!(&quot;Didn't match a number. Let's go with a letter!&quot;);
    } else {
        // The condition evaluated false. This branch is the default:
        println!(&quot;I don't like letters. Let's go with an emoticon :)!&quot;);
    };
}
</code></pre></pre>
<a class="header" href="print.html#see-also-20" id="see-also-20"><h3>See also:</h3></a>
<p><a href="/custom_types/enum.html"><code>enum</code></a>, <a href="/std/option.html"><code>Option</code></a>, and the <a href="https://github.com/rust-lang/rfcs/pull/160">RFC</a></p>
<a class="header" href="print.html#while-let" id="while-let"><h1>while let</h1></a>
<p>Similar to <code>if let</code>, <code>while let</code> can make awkward <code>match</code> sequences
more tolerable. Consider the following sequence that increments <code>i</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Make `optional` of type `Option&lt;i32&gt;`
let mut optional = Some(0);

// Repeatedly try this test.
loop {
    match optional {
        // If `optional` destructures, evaluate the block.
        Some(i) =&gt; {
            if i &gt; 9 {
                println!(&quot;Greater than 9, quit!&quot;);
                optional = None;
            } else {
                println!(&quot;`i` is `{:?}`. Try again.&quot;, i);
                optional = Some(i + 1);
            }
            // ^ Requires 3 indentations!
        },
        // Quit the loop when the destructure fails:
        _ =&gt; { break; }
        // ^ Why should this be required? There must be a better way!
    }
}
#}</code></pre></pre>
<p>Using <code>while let</code> makes this sequence much nicer:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // Make `optional` of type `Option&lt;i32&gt;`
    let mut optional = Some(0);

    // This reads: &quot;while `let` destructures `optional` into
    // `Some(i)`, evaluate the block (`{}`). Else `break`.
    while let Some(i) = optional {
        if i &gt; 9 {
            println!(&quot;Greater than 9, quit!&quot;);
            optional = None;
        } else {
            println!(&quot;`i` is `{:?}`. Try again.&quot;, i);
            optional = Some(i + 1);
        }
        // ^ Less rightward drift and doesn't require
        // explicitly handling the failing case.
    }
    // ^ `if let` had additional optional `else`/`else if`
    // clauses. `while let` does not have these.
}
</code></pre></pre>
<a class="header" href="print.html#see-also-21" id="see-also-21"><h3>See also:</h3></a>
<p><a href="/custom_types/enum.html"><code>enum</code></a>, <a href="/std/option.html"><code>Option</code></a>, and the <a href="https://github.com/rust-lang/rfcs/pull/214">RFC</a></p>
<a class="header" href="print.html#functions" id="functions"><h1>Functions</h1></a>
<p>Functions are declared using the <code>fn</code> keyword. Its arguments are type
annotated, just like variables, and, if the function returns a value, the
return type must be specified after an arrow <code>-&gt;</code>.</p>
<p>The final expression in the function will be used as return value.
Alternatively, the <code>return</code> statement can be used to return a value earlier
from within the function, even from inside loops or <code>if</code>s.</p>
<p>Let's rewrite FizzBuzz using functions!</p>
<pre><pre class="playpen"><code class="language-rust editable">// Unlike C/C++, there's no restriction on the order of function definitions
fn main() {
    // We can use this function here, and define it somewhere later
    fizzbuzz_to(100);
}

// Function that returns a boolean value
fn is_divisible_by(lhs: u32, rhs: u32) -&gt; bool {
    // Corner case, early return
    if rhs == 0 {
        return false;
    }

    // This is an expression, the `return` keyword is not necessary here
    lhs % rhs == 0
}

// Functions that &quot;don't&quot; return a value, actually return the unit type `()`
fn fizzbuzz(n: u32) -&gt; () {
    if is_divisible_by(n, 15) {
        println!(&quot;fizzbuzz&quot;);
    } else if is_divisible_by(n, 3) {
        println!(&quot;fizz&quot;);
    } else if is_divisible_by(n, 5) {
        println!(&quot;buzz&quot;);
    } else {
        println!(&quot;{}&quot;, n);
    }
}

// When a function returns `()`, the return type can be omitted from the
// signature
fn fizzbuzz_to(n: u32) {
    for n in 1..n + 1 {
        fizzbuzz(n);
    }
}
</code></pre></pre>
<a class="header" href="print.html#methods" id="methods"><h1>Methods</h1></a>
<p>Methods are functions attached to objects. These methods have access to the
data of the object and its other methods via the <code>self</code> keyword. Methods are
defined under an <code>impl</code> block.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Point {
    x: f64,
    y: f64,
}

// Implementation block, all `Point` methods go in here
impl Point {
    // This is a static method
    // Static methods don't need to be called by an instance
    // These methods are generally used as constructors
    fn origin() -&gt; Point {
        Point { x: 0.0, y: 0.0 }
    }

    // Another static method, taking two arguments:
    fn new(x: f64, y: f64) -&gt; Point {
        Point { x: x, y: y }
    }
}

struct Rectangle {
    p1: Point,
    p2: Point,
}

impl Rectangle {
    // This is an instance method
    // `&amp;self` is sugar for `self: &amp;Self`, where `Self` is the type of the
    // caller object. In this case `Self` = `Rectangle`
    fn area(&amp;self) -&gt; f64 {
        // `self` gives access to the struct fields via the dot operator
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        // `abs` is a `f64` method that returns the absolute value of the
        // caller
        ((x1 - x2) * (y1 - y2)).abs()
    }

    fn perimeter(&amp;self) -&gt; f64 {
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        2.0 * ((x1 - x2).abs() + (y1 - y2).abs())
    }

    // This method requires the caller object to be mutable
    // `&amp;mut self` desugars to `self: &amp;mut Self`
    fn translate(&amp;mut self, x: f64, y: f64) {
        self.p1.x += x;
        self.p2.x += x;

        self.p1.y += y;
        self.p2.y += y;
    }
}

// `Pair` owns resources: two heap allocated integers
struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);

impl Pair {
    // This method &quot;consumes&quot; the resources of the caller object
    // `self` desugars to `self: Self`
    fn destroy(self) {
        // Destructure `self`
        let Pair(first, second) = self;

        println!(&quot;Destroying Pair({}, {})&quot;, first, second);

        // `first` and `second` go out of scope and get freed
    }
}

fn main() {
    let rectangle = Rectangle {
        // Static methods are called using double colons
        p1: Point::origin(),
        p2: Point::new(3.0, 4.0),
    };

    // Instance methods are called using the dot operator
    // Note that the first argument `&amp;self` is implicitly passed, i.e.
    // `rectangle.perimeter()` === `Rectangle::perimeter(&amp;rectangle)`
    println!(&quot;Rectangle perimeter: {}&quot;, rectangle.perimeter());
    println!(&quot;Rectangle area: {}&quot;, rectangle.area());

    let mut square = Rectangle {
        p1: Point::origin(),
        p2: Point::new(1.0, 1.0),
    };

    // Error! `rectangle` is immutable, but this method requires a mutable
    // object
    //rectangle.translate(1.0, 0.0);
    // TODO ^ Try uncommenting this line

    // Okay! Mutable objects can call mutable methods
    square.translate(1.0, 1.0);

    let pair = Pair(Box::new(1), Box::new(2));

    pair.destroy();

    // Error! Previous `destroy` call &quot;consumed&quot; `pair`
    //pair.destroy();
    // TODO ^ Try uncommenting this line
}
</code></pre></pre>
<a class="header" href="print.html#closures" id="closures"><h1>Closures</h1></a>
<p>Closures in Rust, also called lambdas, are functions that can capture
the enclosing environment. For example, a closure that captures the x
variable:</p>
<pre><code class="language-Rust">|val| val + x
</code></pre>
<p>The syntax and capabilities of closures make them very convenient for
on the fly usage. Calling a closure is exactly like calling a function.
However, both input and return types <em>can</em> be inferred and input
variable names <em>must</em> be specified.</p>
<p>Other characteristics of closures include:</p>
<ul>
<li>using <code>||</code> instead of <code>()</code> around input variables.</li>
<li>optional body delimination (<code>{}</code>) for a single expression (mandatory otherwise).</li>
<li>the ability to capture the outer environment variables.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // Increment via closures and functions.
    fn  function            (i: i32) -&gt; i32 { i + 1 }

    // Closures are anonymous, here we are binding them to references
    // Annotation is identical to function annotation but is optional
    // as are the `{}` wrapping the body. These nameless functions
    // are assigned to appropriately named variables.
    let closure_annotated = |i: i32| -&gt; i32 { i + 1 };
    let closure_inferred  = |i     |          i + 1  ;

    let i = 1;
    // Call the function and closures.
    println!(&quot;function: {}&quot;, function(i));
    println!(&quot;closure_annotated: {}&quot;, closure_annotated(i));
    println!(&quot;closure_inferred: {}&quot;, closure_inferred(i));

    // A closure taking no arguments which returns an `i32`.
    // The return type is inferred.
    let one = || 1;
    println!(&quot;closure returning one: {}&quot;, one());

}
</code></pre></pre>
<a class="header" href="print.html#capturing" id="capturing"><h1>Capturing</h1></a>
<p>Closures are inherently flexible and will do what the functionality requires
to make the closure work without annotation. This allows capturing to
flexibly adapt to the use case, sometimes moving and sometimes borrowing.
Closures can capture variables:</p>
<ul>
<li>by reference: <code>&amp;T</code></li>
<li>by mutable reference: <code>&amp;mut T</code></li>
<li>by value: <code>T</code></li>
</ul>
<p>They preferentially capture variables by reference and only go lower when
required.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    use std::mem;
    
    let color = &quot;green&quot;;

    // A closure to print `color` which immediately borrows (`&amp;`)
    // `color` and stores the borrow and closure in the `print`
    // variable. It will remain borrowed until `print` goes out of
    // scope. `println!` only requires `by reference` so it doesn't
    // impose anything more restrictive.
    let print = || println!(&quot;`color`: {}&quot;, color);

    // Call the closure using the borrow.
    print();
    print();

    let mut count = 0;

    // A closure to increment `count` could take either `&amp;mut count`
    // or `count` but `&amp;mut count` is less restrictive so it takes
    // that. Immediately borrows `count`.
    //
    // A `mut` is required on `inc` because a `&amp;mut` is stored inside.
    // Thus, calling the closure mutates the closure which requires
    // a `mut`.
    let mut inc = || {
        count += 1;
        println!(&quot;`count`: {}&quot;, count);
    };

    // Call the closure.
    inc();
    inc();

    //let reborrow = &amp;mut count;
    // ^ TODO: try uncommenting this line.
    
    // A non-copy type.
    let movable = Box::new(3);

    // `mem::drop` requires `T` so this must take by value. A copy type
    // would copy into the closure leaving the original untouched.
    // A non-copy must move and so `movable` immediately moves into
    // the closure.
    let consume = || {
        println!(&quot;`movable`: {:?}&quot;, movable);
        mem::drop(movable);
    };

    // `consume` consumes the variable so this can only be called once.
    consume();
    //consume();
    // ^ TODO: Try uncommenting this line.
}
</code></pre></pre>
<a class="header" href="print.html#see-also-22" id="see-also-22"><h3>See also:</h3></a>
<p><a href="/std/box.html"><code>Box</code></a> and <a href="https://doc.rust-lang.org/std/mem/fn.drop.html"><code>std::mem::drop</code></a></p>
<a class="header" href="print.html#as-input-parameters" id="as-input-parameters"><h1>As input parameters</h1></a>
<p>While Rust chooses how to capture variables on the fly mostly without type
annotation, this ambiguity is not allowed when writing functions. When
taking a closure as an input parameter, the closure's complete type must be
annotated using one of a few <code>traits</code>. In order of decreasing restriction,
they are:</p>
<ul>
<li><code>Fn</code>: the closure captures by reference (<code>&amp;T</code>)</li>
<li><code>FnMut</code>: the closure captures by mutable reference (<code>&amp;mut T</code>)</li>
<li><code>FnOnce</code>: the closure captures by value (<code>T</code>)</li>
</ul>
<p>On a variable-by-variable basis, the compiler will capture variables in the
least restrictive manner possible.</p>
<p>For instance, consider a parameter annotated as <code>FnOnce</code>. This specifies
that the closure <em>may</em> capture by <code>&amp;T</code>, <code>&amp;mut T</code>, or <code>T</code>, but the compiler
will ultimately choose based on how the captured variables are used in the
closure.</p>
<p>This is because if a move is possible, then any type of borrow should also
be possible. Note that the reverse is not true. If the parameter is
annotated as <code>Fn</code>, then capturing variables by <code>&amp;mut T</code> or <code>T</code> are not
allowed.</p>
<p>In the following example, try swapping the usage of <code>Fn</code>, <code>FnMut</code>, and
<code>FnOnce</code> to see what happens:</p>
<pre><pre class="playpen"><code class="language-rust editable">// A function which takes a closure as an argument and calls it.
fn apply&lt;F&gt;(f: F) where
    // The closure takes no input and returns nothing.
    F: FnOnce() {
    // ^ TODO: Try changing this to `Fn` or `FnMut`.

    f();
}

// A function which takes a closure and returns an `i32`.
fn apply_to_3&lt;F&gt;(f: F) -&gt; i32 where
    // The closure takes an `i32` and returns an `i32`.
    F: Fn(i32) -&gt; i32 {

    f(3)
}

fn main() {
    use std::mem;

    let greeting = &quot;hello&quot;;
    // A non-copy type.
    // `to_owned` creates owned data from borrowed one
    let mut farewell = &quot;goodbye&quot;.to_owned();

    // Capture 2 variables: `greeting` by reference and
    // `farewell` by value.
    let diary = || {
        // `greeting` is by reference: requires `Fn`.
        println!(&quot;I said {}.&quot;, greeting);

        // Mutation forces `farewell` to be captured by
        // mutable reference. Now requires `FnMut`.
        farewell.push_str(&quot;!!!&quot;);
        println!(&quot;Then I screamed {}.&quot;, farewell);
        println!(&quot;Now I can sleep. zzzzz&quot;);

        // Manually calling drop forces `farewell` to
        // be captured by value. Now requires `FnOnce`.
        mem::drop(farewell);
    };

    // Call the function which applies the closure.
    apply(diary);

    // `double` satisfies `apply_to_3`'s trait bound
    let double = |x| 2 * x;

    println!(&quot;3 doubled: {}&quot;, apply_to_3(double));
}
</code></pre></pre>
<a class="header" href="print.html#see-also-23" id="see-also-23"><h3>See also:</h3></a>
<p><a href="https://doc.rust-lang.org/std/mem/fn.drop.html"><code>std::mem::drop</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, and <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></p>
<a class="header" href="print.html#type-anonymity" id="type-anonymity"><h1>Type anonymity</h1></a>
<p>Closures succinctly capture variables from enclosing scopes. Does this have
any consequences? It surely does. Observe how using a closure as a function
parameter requires <a href="/generics.html">generics</a>, which is necessary because of how they are
defined:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// `F` must be generic.
fn apply&lt;F&gt;(f: F) where
    F: FnOnce() {
    f();
}
#}</code></pre></pre>
<p>When a closure is defined, the compiler implicitly creates a new
anonymous structure to store the captured variables inside, meanwhile
implementing the functionality via one of the <code>traits</code>: <code>Fn</code>, <code>FnMut</code>, or
<code>FnOnce</code> for this unknown type. This type is assigned to the variable which
is stored until calling.</p>
<p>Since this new type is of unknown type, any usage in a function will require
generics. However, an unbounded type parameter <code>&lt;T&gt;</code> would still be ambiguous
and not be allowed. Thus, bounding by one of the <code>traits</code>: <code>Fn</code>, <code>FnMut</code>, or
<code>FnOnce</code> (which it implements) is sufficient to specify its type.</p>
<pre><pre class="playpen"><code class="language-rust editable">// `F` must implement `Fn` for a closure which takes no
// inputs and returns nothing - exactly what is required
// for `print`.
fn apply&lt;F&gt;(f: F) where
    F: Fn() {
    f();
}

fn main() {
    let x = 7;

    // Capture `x` into an anonymous type and implement
    // `Fn` for it. Store it in `print`.
    let print = || println!(&quot;{}&quot;, x);

    apply(print);
}
</code></pre></pre>
<a class="header" href="print.html#see-also-24" id="see-also-24"><h3>See also:</h3></a>
<p><a href="https://huonw.github.io/blog/2015/05/finding-closure-in-rust/">A thorough analysis</a>, <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>,
and <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></p>
<a class="header" href="print.html#input-functions" id="input-functions"><h1>Input functions</h1></a>
<p>Since closures may be used as arguments, you might wonder if the same can be said
about functions. And indeed they can! If you declare a function that takes a
closure as parameter, then any function that satisfies the trait bound of that
closure can be passed as a parameter.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Define a function which takes a generic `F` argument
// bounded by `Fn`, and calls it
fn call_me&lt;F: Fn()&gt;(f: F) {
    f();
}

// Define a wrapper function satisfying the `Fn` bound
fn function() {
    println!(&quot;I'm a function!&quot;);
}

fn main() {
    // Define a closure satisfying the `Fn` bound
    let closure = || println!(&quot;I'm a closure!&quot;);

    call_me(closure);
    call_me(function);
}
</code></pre></pre>
<p>As an additional note, the <code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code> <code>traits</code> dictate how
a closure captures variables from the enclosing scope.</p>
<a class="header" href="print.html#see-also-25" id="see-also-25"><h3>See also:</h3></a>
<p><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, and <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></p>
<a class="header" href="print.html#as-output-parameters" id="as-output-parameters"><h1>As output parameters</h1></a>
<p>Closures as input parameters are possible, so returning closures as
output parameters should also be possible. However, returning closure types
are problematic because Rust currently only supports returning concrete
(non-generic) types. Anonymous closure types are, by definition, unknown
and so returning a closure is only possible by making it concrete. This
can be done via boxing.</p>
<p>The valid traits for returns are slightly different than before:</p>
<ul>
<li><code>Fn</code>: normal</li>
<li><code>FnMut</code>: normal</li>
<li><code>FnOnce</code>: There are some unusual things at play here, so the <a href="https://doc.rust-lang.org/std/boxed/trait.FnBox.html"><code>FnBox</code></a>
type is currently needed, and is unstable. This is expected to change in
the future.</li>
</ul>
<p>Beyond this, the <code>move</code> keyword must be used, which signals that all captures
occur by value. This is required because any captures by reference would be
dropped as soon as the function exited, leaving invalid references in the
closure.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn create_fn() -&gt; Box&lt;Fn()&gt; {
    let text = &quot;Fn&quot;.to_owned();

    Box::new(move || println!(&quot;This is a: {}&quot;, text))
}

fn create_fnmut() -&gt; Box&lt;FnMut()&gt; {
    let text = &quot;FnMut&quot;.to_owned();

    Box::new(move || println!(&quot;This is a: {}&quot;, text))
}

fn main() {
    let fn_plain = create_fn();
    let mut fn_mut = create_fnmut();

    fn_plain();
    fn_mut();
}
</code></pre></pre>
<a class="header" href="print.html#see-also-26" id="see-also-26"><h3>See also:</h3></a>
<p><a href="/std/box.html">Boxing</a>, <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, and <a href="/generics.html">Generics</a>.</p>
<a class="header" href="print.html#examples-in-std" id="examples-in-std"><h1>Examples in <code>std</code></h1></a>
<p>This section contains a few examples of using closures from the <code>std</code> library.</p>
<a class="header" href="print.html#iteratorany" id="iteratorany"><h1>Iterator::any</h1></a>
<p><code>Iterator::any</code> is a function which when passed an iterator, will return
<code>true</code> if any element satisfies the predicate. Otherwise <code>false</code>. Its
signature:</p>
<pre><code class="language-rust ignore">pub trait Iterator {
    // The type being iterated over.
    type Item;

    // `any` takes `&amp;mut self` meaning the caller may be borrowed
    // and modified, but not consumed.
    fn any&lt;F&gt;(&amp;mut self, f: F) -&gt; bool where
        // `FnMut` meaning any captured variable may at most be
        // modified, not consumed. `Self::Item` states it takes
        // arguments to the closure by value.
        F: FnMut(Self::Item) -&gt; bool {}
}
</code></pre>
<pre><code class="language-rust ignore">fn main() {
    let vec1 = vec![1, 2, 3];
    let vec2 = vec![4, 5, 6];

    // `iter()` for vecs yields `&amp;i32`. Destructure to `i32`.
    println!(&quot;2 in vec1: {}&quot;, vec1.iter()     .any(|&amp;x| x == 2));
    // `into_iter()` for vecs yields `i32`. No destructuring required.
    println!(&quot;2 in vec2: {}&quot;, vec2.into_iter().any(| x| x == 2));

    let array1 = [1, 2, 3];
    let array2 = [4, 5, 6];

    // `iter()` for arrays yields `&amp;i32`.
    println!(&quot;2 in array1: {}&quot;, array1.iter()     .any(|&amp;x| x == 2));
    // `into_iter()` for arrays unusually yields `&amp;i32`.
    println!(&quot;2 in array2: {}&quot;, array2.into_iter().any(|&amp;x| x == 2));
}
</code></pre>
<a class="header" href="print.html#see-also-27" id="see-also-27"><h3>See also:</h3></a>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.any"><code>std::iter::Iterator::any</code></a></p>
<a class="header" href="print.html#iteratorfind" id="iteratorfind"><h1>Iterator::find</h1></a>
<p><code>Iterator::find</code> is a function which when passed an iterator, will return
the first element which satisfies the predicate as an <code>Option</code>. Its
signature:</p>
<pre><code class="language-rust ignore">pub trait Iterator {
    // The type being iterated over.
    type Item;

    // `find` takes `&amp;mut self` meaning the caller may be borrowed
    // and modified, but not consumed.
    fn find&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;Self::Item&gt; where
        // `FnMut` meaning any captured variable may at most be
        // modified, not consumed. `&amp;Self::Item` states it takes
        // arguments to the closure by reference.
        P: FnMut(&amp;Self::Item) -&gt; bool {}
}
</code></pre>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let vec1 = vec![1, 2, 3];
    let vec2 = vec![4, 5, 6];

    // `iter()` for vecs yields `&amp;i32`.
    let mut iter = vec1.iter();
    // `into_iter()` for vecs yields `i32`.
    let mut into_iter = vec2.into_iter();

    // A reference to what is yielded is `&amp;&amp;i32`. Destructure to `i32`.
    println!(&quot;Find 2 in vec1: {:?}&quot;, iter     .find(|&amp;&amp;x| x == 2));
    // A reference to what is yielded is `&amp;i32`. Destructure to `i32`.
    println!(&quot;Find 2 in vec2: {:?}&quot;, into_iter.find(| &amp;x| x == 2));

    let array1 = [1, 2, 3];
    let array2 = [4, 5, 6];

    // `iter()` for arrays yields `&amp;i32`
    println!(&quot;Find 2 in array1: {:?}&quot;, array1.iter()     .find(|&amp;&amp;x| x == 2));
    // `into_iter()` for arrays unusually yields `&amp;i32`
    println!(&quot;Find 2 in array2: {:?}&quot;, array2.into_iter().find(|&amp;&amp;x| x == 2));
}
</code></pre></pre>
<a class="header" href="print.html#see-also-28" id="see-also-28"><h3>See also:</h3></a>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.find"><code>std::iter::Iterator::find</code></a></p>
<a class="header" href="print.html#higher-order-functions" id="higher-order-functions"><h1>Higher Order Functions</h1></a>
<p>Rust provides Higher Order Functions (HOF). These are functions that
take one or more functions and/or produce a more useful function. HOFs
and lazy iterators give Rust its functional flavor.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn is_odd(n: u32) -&gt; bool {
    n % 2 == 1
}

fn main() {
    println!(&quot;Find the sum of all the squared odd numbers under 1000&quot;);
    let upper = 1000;

    // Imperative approach
    // Declare accumulator variable
    let mut acc = 0;
    // Iterate: 0, 1, 2, ... to infinity
    for n in 0.. {
        // Square the number
        let n_squared = n * n;

        if n_squared &gt;= upper {
            // Break loop if exceeded the upper limit
            break;
        } else if is_odd(n_squared) {
            // Accumulate value, if it's odd
            acc += n_squared;
        }
    }
    println!(&quot;imperative style: {}&quot;, acc);

    // Functional approach
    let sum_of_squared_odd_numbers: u32 =
        (0..).map(|n| n * n)             // All natural numbers squared
             .take_while(|&amp;n| n &lt; upper) // Below upper limit
             .filter(|&amp;n| is_odd(n))     // That are odd
             .fold(0, |sum, i| sum + i); // Sum them
    println!(&quot;functional style: {}&quot;, sum_of_squared_odd_numbers);
}
</code></pre></pre>
<p><a href="https://doc.rust-lang.org/core/option/enum.Option.html">Option</a>
and
<a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html">Iterator</a>
implement their fair share of HOFs.</p>
<a class="header" href="print.html#modules" id="modules"><h1>Modules</h1></a>
<p>Rust provides a powerful module system that can be used to hierarchically split
code in logical units (modules), and manage visibility (public/private) between
them.</p>
<p>A module is a collection of items: functions, structs, traits, <code>impl</code> blocks,
and even other modules.</p>
<a class="header" href="print.html#visibility" id="visibility"><h1>Visibility</h1></a>
<p>By default, the items in a module have private visibility, but this can be
overridden with the <code>pub</code> modifier. Only the public items of a module can be
accessed from outside the module scope.</p>
<pre><pre class="playpen"><code class="language-rust editable">// A module named `my_mod`
mod my_mod {
    // Items in modules default to private visibility.
    fn private_function() {
        println!(&quot;called `my_mod::private_function()`&quot;);
    }

    // Use the `pub` modifier to override default visibility.
    pub fn function() {
        println!(&quot;called `my_mod::function()`&quot;);
    }

    // Items can access other items in the same module,
    // even when private.
    pub fn indirect_access() {
        print!(&quot;called `my_mod::indirect_access()`, that\n&gt; &quot;);
        private_function();
    }

    // Modules can also be nested
    pub mod nested {
        pub fn function() {
            println!(&quot;called `my_mod::nested::function()`&quot;);
        }

        #[allow(dead_code)]
        fn private_function() {
            println!(&quot;called `my_mod::nested::private_function()`&quot;);
        }

        // Functions declared using `pub(in path)` syntax are only visible
        // within the given path. `path` must be a parent or ancestor module
        pub(in my_mod) fn public_function_in_my_mod() {
            print!(&quot;called `my_mod::nested::public_function_in_my_mod()`, that\n &gt; &quot;);
            public_function_in_nested()
        }

        // Functions declared using `pub(self)` syntax are only visible within
        // the current module
        pub(self) fn public_function_in_nested() {
            println!(&quot;called `my_mod::nested::public_function_in_nested&quot;);
        }

        // Functions declared using `pub(super)` syntax are only visible within
        // the parent module
        pub(super) fn public_function_in_super_mod() {
            println!(&quot;called my_mod::nested::public_function_in_super_mod&quot;);
        }
    }

    pub fn call_public_function_in_my_mod() {
        print!(&quot;called `my_mod::call_public_funcion_in_my_mod()`, that\n&gt; &quot;);
        nested::public_function_in_my_mod();
        print!(&quot;&gt; &quot;);
        nested::public_function_in_super_mod();
    }

    // pub(crate) makes functions visible only within the current crate
    pub(crate) fn public_function_in_crate() {
        println!(&quot;called `my_mod::public_function_in_crate()&quot;);
    }

    // Nested modules follow the same rules for visibility
    mod private_nested {
        #[allow(dead_code)]
        pub fn function() {
            println!(&quot;called `my_mod::private_nested::function()`&quot;);
        }
    }
}

fn function() {
    println!(&quot;called `function()`&quot;);
}

fn main() {
    // Modules allow disambiguation between items that have the same name.
    function();
    my_mod::function();

    // Public items, including those inside nested modules, can be
    // accessed from outside the parent module.
    my_mod::indirect_access();
    my_mod::nested::function();
    my_mod::call_public_function_in_my_mod();

    // pub(crate) items can be called from anywhere in the same crate
    my_mod::public_function_in_crate();

    // pub(in path) items can only be called from within the mode specified
    // Error! function `public_function_in_my_mod` is private
    //my_mod::nested::public_function_in_my_mod();
    // TODO ^ Try uncommenting this line

    // Private items of a module cannot be directly accessed, even if
    // nested in a public module:

    // Error! `private_function` is private
    //my_mod::private_function();
    // TODO ^ Try uncommenting this line

    // Error! `private_function` is private
    //my_mod::nested::private_function();
    // TODO ^ Try uncommenting this line

    // Error! `private_nested` is a private module
    //my_mod::private_nested::function();
    // TODO ^ Try uncommenting this line
}
</code></pre></pre>
<a class="header" href="print.html#struct-visibility" id="struct-visibility"><h1>Struct visibility</h1></a>
<p>Structs have an extra level of visibility with their fields. The visibility
defaults to private, and can be overridden with the <code>pub</code> modifier. This
visibility only matters when a struct is accessed from outside the module
where it is defined, and has the goal of hiding information (encapsulation).</p>
<pre><pre class="playpen"><code class="language-rust editable">mod my {
    // A public struct with a public field of generic type `T`
    pub struct OpenBox&lt;T&gt; {
        pub contents: T,
    }

    // A public struct with a private field of generic type `T`
    #[allow(dead_code)]
    pub struct ClosedBox&lt;T&gt; {
        contents: T,
    }

    impl&lt;T&gt; ClosedBox&lt;T&gt; {
        // A public constructor method
        pub fn new(contents: T) -&gt; ClosedBox&lt;T&gt; {
            ClosedBox {
                contents: contents,
            }
        }
    }
}

fn main() {
    // Public structs with public fields can be constructed as usual
    let open_box = my::OpenBox { contents: &quot;public information&quot; };

    // and their fields can be normally accessed.
    println!(&quot;The open box contains: {}&quot;, open_box.contents);

    // Public structs with private fields cannot be constructed using field names.
    // Error! `ClosedBox` has private fields
    //let closed_box = my::ClosedBox { contents: &quot;classified information&quot; };
    // TODO ^ Try uncommenting this line

    // However, structs with private fields can be created using
    // public constructors
    let _closed_box = my::ClosedBox::new(&quot;classified information&quot;);

    // and the private fields of a public struct cannot be accessed.
    // Error! The `contents` field is private
    //println!(&quot;The closed box contains: {}&quot;, _closed_box.contents);
    // TODO ^ Try uncommenting this line
}
</code></pre></pre>
<a class="header" href="print.html#see-also-29" id="see-also-29"><h3>See also:</h3></a>
<p><a href="/generics.html">generics</a> and <a href="/fn/methods.html">methods</a></p>
<a class="header" href="print.html#the-use-declaration" id="the-use-declaration"><h1>The <code>use</code> declaration</h1></a>
<p>The <code>use</code> declaration can be used to bind a full path to a new name, for easier
access.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Bind the `deeply::nested::function` path to `other_function`.
use deeply::nested::function as other_function;

fn function() {
    println!(&quot;called `function()`&quot;);
}

mod deeply {
    pub mod nested {
        pub fn function() {
            println!(&quot;called `deeply::nested::function()`&quot;)
        }
    }
}

fn main() {
    // Easier access to `deeply::nested::function`
    other_function();

    println!(&quot;Entering block&quot;);
    {
        // This is equivalent to `use deeply::nested::function as function`.
        // This `function()` will shadow the outer one.
        use deeply::nested::function;
        function();

        // `use` bindings have a local scope. In this case, the
        // shadowing of `function()` is only in this block.
        println!(&quot;Leaving block&quot;);
    }

    function();
}
</code></pre></pre>
<a class="header" href="print.html#super-and-self" id="super-and-self"><h1><code>super</code> and <code>self</code></h1></a>
<p>The <code>super</code> and <code>self</code> keywords can be used in the path to remove ambiguity
when accessing items and to prevent unnecessary hardcoding of paths.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn function() {
    println!(&quot;called `function()`&quot;);
}

mod cool {
    pub fn function() {
        println!(&quot;called `cool::function()`&quot;);
    }
}

mod my {
    fn function() {
        println!(&quot;called `my::function()`&quot;);
    }
    
    mod cool {
        pub fn function() {
            println!(&quot;called `my::cool::function()`&quot;);
        }
    }
    
    pub fn indirect_call() {
        // Let's access all the functions named `function` from this scope!
        print!(&quot;called `my::indirect_call()`, that\n&gt; &quot;);
        
        // The `self` keyword refers to the current module scope - in this case `my`.
        // Calling `self::function()` and calling `function()` directly both give
        // the same result, because they refer to the same function.
        self::function();
        function();
        
        // We can also use `self` to access another module inside `my`:
        self::cool::function();
        
        // The `super` keyword refers to the parent scope (outside the `my` module).
        super::function();
        
        // This will bind to the `cool::function` in the *crate* scope.
        // In this case the crate scope is the outermost scope.
        {
            use cool::function as root_function;
            root_function();
        }
    }
}

fn main() {
    my::indirect_call();
}
</code></pre></pre>
<a class="header" href="print.html#file-hierarchy" id="file-hierarchy"><h1>File hierarchy</h1></a>
<p>Modules can be mapped to a file/directory hierarchy. Let's break down the
<a href="/mod/visibility.html">visibility example</a> in files:</p>
<pre><code class="language-text">$ tree .
.
|-- my
|   |-- inaccessible.rs
|   |-- mod.rs
|   `-- nested.rs
`-- split.rs
</code></pre>
<p>In <code>split.rs</code>:</p>
<pre><code class="language-rust ignore">// This declaration will look for a file named `my.rs` or `my/mod.rs` and will
// insert its contents inside a module named `my` under this scope
mod my;

fn function() {
    println!(&quot;called `function()`&quot;);
}

fn main() {
    my::function();

    function();

    my::indirect_access();

    my::nested::function();
}

</code></pre>
<p>In <code>my/mod.rs</code>:</p>
<pre><code class="language-rust ignore">// Similarly `mod inaccessible` and `mod nested` will locate the `nested.rs`
// and `inaccessible.rs` files and insert them here under their respective
// modules
mod inaccessible;
pub mod nested;

pub fn function() {
    println!(&quot;called `my::function()`&quot;);
}

fn private_function() {
    println!(&quot;called `my::private_function()`&quot;);
}

pub fn indirect_access() {
    print!(&quot;called `my::indirect_access()`, that\n&gt; &quot;);

    private_function();
}
</code></pre>
<p>In <code>my/nested.rs</code>:</p>
<pre><code class="language-rust ignore">pub fn function() {
    println!(&quot;called `my::nested::function()`&quot;);
}

#[allow(dead_code)]
fn private_function() {
    println!(&quot;called `my::nested::private_function()`&quot;);
}
</code></pre>
<p>In <code>my/inaccessible.rs</code>:</p>
<pre><code class="language-rust ignore">#[allow(dead_code)]
pub fn public_function() {
    println!(&quot;called `my::inaccessible::public_function()`&quot;);
}
</code></pre>
<p>Let's check that things still work as before:</p>
<pre><code class="language-bash">$ rustc split.rs &amp;&amp; ./split
called `my::function()`
called `function()`
called `my::indirect_access()`, that
&gt; called `my::private_function()`
called `my::nested::function()`
</code></pre>
<a class="header" href="print.html#crates" id="crates"><h1>Crates</h1></a>
<p>A crate is a compilation unit in Rust. Whenever <code>rustc some_file.rs</code> is called,
<code>some_file.rs</code> is treated as the <em>crate file</em>. If <code>some_file.rs</code> has <code>mod</code>
declarations in it, then the contents of the module files will get merged with
the crate file <em>before</em> running the compiler over it. In other words, modules
do <em>not</em> get compiled individually, only crates get compiled.</p>
<p>A crate can be compiled into a binary or into a library. By default, <code>rustc</code>
will produce a binary from a crate. This behavior can be overridden by passing
the <code>--crate-type</code> flag to <code>rustc</code>.</p>
<a class="header" href="print.html#library" id="library"><h1>Library</h1></a>
<p>Let's create a library, and then see how to link it to another crate.</p>
<pre><pre class="playpen"><code class="language-rust editable">pub fn public_function() {
    println!(&quot;called rary's `public_function()`&quot;);
}

fn private_function() {
    println!(&quot;called rary's `private_function()`&quot;);
}

pub fn indirect_access() {
    print!(&quot;called rary's `indirect_access()`, that\n&gt; &quot;);

    private_function();
}
</code></pre></pre>
<pre><code class="language-bash">$ rustc --crate-type=lib rary.rs
$ ls lib*
library.rlib
</code></pre>
<p>Libraries get prefixed with &quot;lib&quot;, and by default they get named after their
crate file, but this default name can be overridden using the <a href="/attribute/crate.html"><code>crate_name</code>
attribute</a>.</p>
<a class="header" href="print.html#extern-crate" id="extern-crate"><h1><code>extern crate</code></h1></a>
<p>To link a crate to this new library, the <code>extern crate</code> declaration must be
used. This will not only link the library, but also import all its items under
a module named the same as the library. The visibility rules that apply to
modules also apply to libraries.</p>
<pre><code class="language-rust ignore">// Link to `library`, import items under the `rary` module
extern crate rary;

fn main() {
    rary::public_function();

    // Error! `private_function` is private
    //rary::private_function();

    rary::indirect_access();
}
</code></pre>
<pre><code class="language-bash"># Where library.rlib is the path to to the compiled library, assumed that it's
# in the same directory here:
$ rustc executable.rs --extern rary=library.rlib &amp;&amp; ./executable
called rary's `public_function()`
called rary's `indirect_access()`, that
&gt; called rary's `private_function()`
</code></pre>
<a class="header" href="print.html#attributes" id="attributes"><h1>Attributes</h1></a>
<p>An attribute is metadata applied to some module, crate or item. This metadata
can be used to/for:</p>
<!-- TODO: Link these to their respective examples -->
<ul>
<li><a href="/attribute/cfg.html">conditional compilation of code</a></li>
<li><a href="/attribute/crate.html">set crate name, version and type (binary or library)</a></li>
<li>disable <a href="https://en.wikipedia.org/wiki/Lint_%28software%29">lints</a> (warnings)</li>
<li>enable compiler features (macros, glob imports, etc.)</li>
<li>link to a foreign library</li>
<li>mark functions as unit tests</li>
<li>mark functions that will be part of a benchmark</li>
</ul>
<p>When attributes apply to a whole crate, their syntax is <code>#![crate_attribute]</code>,
and when they apply to a module or item, the syntax is <code>#[item_attribute]</code>
(notice the missing bang <code>!</code>).</p>
<p>Attributes can take arguments with different syntaxes:</p>
<ul>
<li><code>#[attribute = &quot;value&quot;]</code></li>
<li><code>#[attribute(key = &quot;value&quot;)]</code></li>
<li><code>#[attribute(value)]</code></li>
</ul>
<a class="header" href="print.html#dead_code" id="dead_code"><h1><code>dead_code</code></h1></a>
<p>The compiler provides a <code>dead_code</code>
<a href="https://en.wikipedia.org/wiki/Lint_%28software%29"><em>lint</em></a> that will warn
about unused functions. An <em>attribute</em> can be used to disable the lint.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn used_function() {}

// `#[allow(dead_code)]` is an attribute that disables the `dead_code` lint
#[allow(dead_code)]
fn unused_function() {}

fn noisy_unused_function() {}
// FIXME ^ Add an attribute to suppress the warning

fn main() {
    used_function();
}
</code></pre></pre>
<p>Note that in real programs, you should eliminate dead code. In these examples
we'll allow dead code in some places because of the interactive nature of the
examples.</p>
<a class="header" href="print.html#crates-1" id="crates-1"><h1>Crates</h1></a>
<p>The <code>crate_type</code> attribute can be used to tell the compiler whether a crate is
a binary or a library (and even which type of library), and the <code>crate_name</code>
attribute can be used to set the name of the crate.</p>
<pre><pre class="playpen"><code class="language-rust editable">// This crate is a library
#![crate_type = &quot;lib&quot;]
// The library is named &quot;rary&quot;
#![crate_name = &quot;rary&quot;]

pub fn public_function() {
    println!(&quot;called rary's `public_function()`&quot;);
}

fn private_function() {
    println!(&quot;called rary's `private_function()`&quot;);
}

pub fn indirect_access() {
    print!(&quot;called rary's `indirect_access()`, that\n&gt; &quot;);

    private_function();
}
</code></pre></pre>
<p>When the <code>crate_type</code> attribute is used, we no longer need to pass the
<code>--crate-type</code> flag to <code>rustc</code>.</p>
<pre><code class="language-bash">$ rustc lib.rs
$ ls lib*
library.rlib
</code></pre>
<a class="header" href="print.html#cfg" id="cfg"><h1><code>cfg</code></h1></a>
<p>Conditional compilation is possible through two different operators:</p>
<ul>
<li>the <code>cfg</code> attribute: <code>#[cfg(...)]</code> in attribute position</li>
<li>the <code>cfg!</code> macro: <code>cfg!(...)</code> in boolean expressions</li>
</ul>
<p>Both utilize identical argument syntax.</p>
<pre><pre class="playpen"><code class="language-rust editable">// This function only gets compiled if the target OS is linux
#[cfg(target_os = &quot;linux&quot;)]
fn are_you_on_linux() {
    println!(&quot;You are running linux!&quot;)
}

// And this function only gets compiled if the target OS is *not* linux
#[cfg(not(target_os = &quot;linux&quot;))]
fn are_you_on_linux() {
    println!(&quot;You are *not* running linux!&quot;)
}

fn main() {
    are_you_on_linux();
    
    println!(&quot;Are you sure?&quot;);
    if cfg!(target_os = &quot;linux&quot;) {
        println!(&quot;Yes. It's definitely linux!&quot;);
    } else {
        println!(&quot;Yes. It's definitely *not* linux!&quot;);
    }
}
</code></pre></pre>
<a class="header" href="print.html#see-also-30" id="see-also-30"><h3>See also:</h3></a>
<p><a href="https://doc.rust-lang.org/reference/attributes.html#conditional-compilation">the reference</a>, <a href="https://doc.rust-lang.org/std/macro.cfg!.html"><code>cfg!</code></a>, and <a href="/macros.html">macros</a>.</p>
<a class="header" href="print.html#custom" id="custom"><h1>Custom</h1></a>
<p>Some conditionals like <code>target_os</code> are implicitly provided by <code>rustc</code>, but
custom conditionals must be passed to <code>rustc</code> using the <code>--cfg</code> flag.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">#[cfg(some_condition)]
fn conditional_function() {
    println!(&quot;condition met!&quot;)
}

fn main() {
    conditional_function();
}
</code></pre></pre>
<p>Try to run this to see what happens without the custom <code>cfg</code> flag.</p>
<p>With the custom <code>cfg</code> flag:</p>
<pre><code class="language-bash">$ rustc --cfg some_condition custom.rs &amp;&amp; ./custom
condition met!
</code></pre>
<a class="header" href="print.html#generics" id="generics"><h1>Generics</h1></a>
<p><em>Generics</em> is the topic of generalizing types and functionalities to broader
cases. This is extremely useful for reducing code duplication in many ways,
but can call for rather involving syntax. Namely, being generic requires
taking great care to specify over which types a generic type
is actually considered valid. The simplest and most common use of generics
is for type parameters.</p>
<p>A type parameter is specified as generic by the use of angle brackets and upper
<a href="https://en.wikipedia.org/wiki/CamelCase">camel case</a>: <code>&lt;Aaa, Bbb, ...&gt;</code>. &quot;Generic type parameters&quot; are
typically represented as <code>&lt;T&gt;</code>. In Rust, &quot;generic&quot; also describes anything that
accepts one or more generic type parameters <code>&lt;T&gt;</code>. Any type specified as a
generic type parameter is generic, and everything else is concrete (non-generic).</p>
<p>For example, defining a <em>generic function</em> named <code>foo</code> that takes an argument
<code>T</code> of any type:</p>
<pre><code class="language-rust ignore">fn foo&lt;T&gt;(arg: T) { ... }
</code></pre>
<p>Because <code>T</code> has been specified as a generic type parameter using <code>&lt;T&gt;</code>, it
is considered generic when used here as <code>(arg: T)</code>. This is the case even if <code>T</code>
has previously been defined as a <code>struct</code>.</p>
<p>This example shows some of the syntax in action:</p>
<pre><pre class="playpen"><code class="language-rust editable">// A concrete type `A`.
struct A;

// In defining the type `Single`, the first use of `A` is not preceded by `&lt;A&gt;`.
// Therefore, `Single` is a concrete type, and `A` is defined as above.
struct Single(A);
//            ^ Here is `Single`s first use of the type `A`.

// Here, `&lt;T&gt;` precedes the first use of `T`, so `SingleGen` is a generic type.
// Because the type parameter `T` is generic, it could be anything, including
// the concrete type `A` defined at the top.
struct SingleGen&lt;T&gt;(T);

fn main() {
    // `Single` is concrete and explicitly takes `A`.
    let _s = Single(A);
    
    // Create a variable `_char` of type `SingleGen&lt;char&gt;`
    // and give it the value `SingleGen('a')`.
    // Here, `SingleGen` has a type parameter explicitly specified.
    let _char: SingleGen&lt;char&gt; = SingleGen('a');

    // `SingleGen` can also have a type parameter implicitly specified:
    let _t    = SingleGen(A); // Uses `A` defined at the top.
    let _i32  = SingleGen(6); // Uses `i32`.
    let _char = SingleGen('a'); // Uses `char`.
}
</code></pre></pre>
<a class="header" href="print.html#see-also-31" id="see-also-31"><h3>See also:</h3></a>
<p><a href="/custom_types/structs.html"><code>struct</code>s</a></p>
<a class="header" href="print.html#functions-1" id="functions-1"><h1>Functions</h1></a>
<p>The same set of rules can be applied to functions: a type <code>T</code> becomes
generic when preceded by <code>&lt;T&gt;</code>.</p>
<p>Using generic functions sometimes requires explicitly specifying type
parameters. This may be the case if the function is called where the return type
is generic, or if the compiler doesn't have enough information to infer
the necessary type parameters.</p>
<p>A function call with explicitly specified type parameters looks like:
<code>fun::&lt;A, B, ...&gt;()</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct A;          // Concrete type `A`.
struct S(A);       // Concrete type `S`.
struct SGen&lt;T&gt;(T); // Generic type `SGen`.

// The following functions all take ownership of the variable passed into
// them and immediately go out of scope, freeing the variable.

// Define a function `reg_fn` that takes an argument `_s` of type `S`.
// This has no `&lt;T&gt;` so this is not a generic function.
fn reg_fn(_s: S) {}

// Define a function `gen_spec_t` that takes an argument `_s` of type `SGen&lt;T&gt;`.
// It has been explicitly given the type parameter `A`, but because `A` has not 
// been specified as a generic type parameter for `gen_spec_t`, it is not generic.
fn gen_spec_t(_s: SGen&lt;A&gt;) {}

// Define a function `gen_spec_i32` that takes an argument `_s` of type `SGen&lt;i32&gt;`.
// It has been explicitly given the type parameter `i32`, which is a specific type.
// Because `i32` is not a generic type, this function is also not generic.
fn gen_spec_i32(_s: SGen&lt;i32&gt;) {}

// Define a function `generic` that takes an argument `_s` of type `SGen&lt;T&gt;`.
// Because `SGen&lt;T&gt;` is preceded by `&lt;T&gt;`, this function is generic over `T`.
fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) {}

fn main() {
    // Using the non-generic functions
    reg_fn(S(A));          // Concrete type.
    gen_spec_t(SGen(A));   // Implicitly specified type parameter `A`.
    gen_spec_i32(SGen(6)); // Implicitly specified type parameter `i32`.

    // Explicitly specified type parameter `char` to `generic()`.
    generic::&lt;char&gt;(SGen('a'));

    // Implicitly specified type parameter `char` to `generic()`.
    generic(SGen('c'));
}
</code></pre></pre>
<a class="header" href="print.html#see-also-32" id="see-also-32"><h3>See also:</h3></a>
<p><a href="/fn.html">functions</a> and <a href="/custom_types/structs.html"><code>struct</code>s</a></p>
<a class="header" href="print.html#implementation" id="implementation"><h1>Implementation</h1></a>
<p>Similar to functions, implementations require care to remain generic.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct S; // Concrete type `S`
struct GenericVal&lt;T&gt;(T,); // Generic type `GenericVal`

// impl of GenericVal where we explicitly specify type parameters:
impl GenericVal&lt;f32&gt; {} // Specify `f32`
impl GenericVal&lt;S&gt; {} // Specify `S` as defined above

// `&lt;T&gt;` Must precede the type to remain generic
impl &lt;T&gt; GenericVal&lt;T&gt; {}
#}</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust editable">struct Val {
    val: f64
}

struct GenVal&lt;T&gt;{
    gen_val: T
}

// impl of Val
impl Val {
    fn value(&amp;self) -&gt; &amp;f64 { &amp;self.val }
}

// impl of GenVal for a generic type `T`
impl &lt;T&gt; GenVal&lt;T&gt; {
    fn value(&amp;self) -&gt; &amp;T { &amp;self.gen_val }
}

fn main() {
    let x = Val { val: 3.0 };
    let y = GenVal { gen_val: 3i32 };
    
    println!(&quot;{}, {}&quot;, x.value(), y.value());
}
</code></pre></pre>
<a class="header" href="print.html#see-also-33" id="see-also-33"><h3>See also:</h3></a>
<p><a href="/scope/lifetime/fn.html">functions returning references</a>, <a href="/fn/methods.html"><code>impl</code></a>, and <a href="/custom_types/structs.html"><code>struct</code></a></p>
<a class="header" href="print.html#traits" id="traits"><h1>Traits</h1></a>
<p>Of course <code>trait</code>s can also be generic. Here we define one which reimplements
the <code>Drop</code> <code>trait</code> as a generic method to <code>drop</code> itself and an input.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Non-copyable types.
struct Empty;
struct Null;

// A trait generic over `T`.
trait DoubleDrop&lt;T&gt; {
    // Define a method on the caller type which takes an
    // additional single parameter `T` and does nothing with it.
    fn double_drop(self, _: T);
}

// Implement `DoubleDrop&lt;T&gt;` for any generic parameter `T` and
// caller `U`.
impl&lt;T, U&gt; DoubleDrop&lt;T&gt; for U {
    // This method takes ownership of both passed arguments,
    // deallocating both.
    fn double_drop(self, _: T) {}
}

fn main() {
    let empty = Empty;
    let null  = Null;

    // Deallocate `empty` and `null`.
    empty.double_drop(null);

    //empty;
    //null;
    // ^ TODO: Try uncommenting these lines.
}
</code></pre></pre>
<a class="header" href="print.html#see-also-34" id="see-also-34"><h3>See also:</h3></a>
<p><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>, <a href="/custom_types/structs.html"><code>struct</code></a>, and <a href="/trait.html"><code>trait</code></a></p>
<a class="header" href="print.html#bounds" id="bounds"><h1>Bounds</h1></a>
<p>When working with generics, the type parameters often must use traits as <em>bounds</em> to
stipulate what functionality a type implements. For example, the following
example uses the trait <code>Display</code> to print and so it requires <code>T</code> to be bound
by <code>Display</code>; that is, <code>T</code> <em>must</em> implement <code>Display</code>.</p>
<pre><code class="language-rust ignore">// Define a function `printer` that takes a generic type `T` which
// must implement trait `Display`.
fn printer&lt;T: Display&gt;(t: T) {
    println!(&quot;{}&quot;, t);
}
</code></pre>
<p>Bounding restricts the generic to types that conform to the bounds. That is:</p>
<pre><code class="language-rust ignore">struct S&lt;T: Display&gt;(T);

// Error! `Vec&lt;T&gt;` does not implement `Display`. This
// specialization will fail.
let s = S(vec![1]);
</code></pre>
<p>Another effect of bounding is that generic instances are allowed to access the
<a href="/fn/methods.html">methods</a> of traits specified in the bounds. For example:</p>
<pre><pre class="playpen"><code class="language-rust editable">// A trait which implements the print marker: `{:?}`.
use std::fmt::Debug;

trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

impl HasArea for Rectangle {
    fn area(&amp;self) -&gt; f64 { self.length * self.height }
}

#[derive(Debug)]
struct Rectangle { length: f64, height: f64 }
#[allow(dead_code)]
struct Triangle  { length: f64, height: f64 }

// The generic `T` must implement `Debug`. Regardless
// of the type, this will work properly.
fn print_debug&lt;T: Debug&gt;(t: &amp;T) {
    println!(&quot;{:?}&quot;, t);
}

// `T` must implement `HasArea`. Any function which meets
// the bound can access `HasArea`'s function `area`.
fn area&lt;T: HasArea&gt;(t: &amp;T) -&gt; f64 { t.area() }

fn main() {
    let rectangle = Rectangle { length: 3.0, height: 4.0 };
    let _triangle = Triangle  { length: 3.0, height: 4.0 };

    print_debug(&amp;rectangle);
    println!(&quot;Area: {}&quot;, area(&amp;rectangle));

    //print_debug(&amp;_triangle);
    //println!(&quot;Area: {}&quot;, area(&amp;_triangle));
    // ^ TODO: Try uncommenting these.
    // | Error: Does not implement either `Debug` or `HasArea`. 
}
</code></pre></pre>
<p>As an additional note, <a href="/generics/where.html"><code>where</code></a> clauses can also be used to apply bounds in
some cases to be more expressive.</p>
<a class="header" href="print.html#see-also-35" id="see-also-35"><h3>See also:</h3></a>
<p><a href="/hello/print.html"><code>std::fmt</code></a>, <a href="/custom_types/structs.html"><code>struct</code>s</a>, and <a href="/trait.html"><code>trait</code>s</a></p>
<a class="header" href="print.html#testcase-empty-bounds" id="testcase-empty-bounds"><h1>Testcase: empty bounds</h1></a>
<p>A consequence of how bounds work is that even if a <code>trait</code> doesn't
include any functionality, you can still use it as a bound. <code>Eq</code> and
<code>Ord</code> are examples of such <code>trait</code>s from the <code>std</code> library.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Cardinal;
struct BlueJay;
struct Turkey;

trait Red {}
trait Blue {}

impl Red for Cardinal {}
impl Blue for BlueJay {}

// These functions are only valid for types which implement these
// traits. The fact that the traits are empty is irrelevant.
fn red&lt;T: Red&gt;(_: &amp;T)   -&gt; &amp;'static str { &quot;red&quot; }
fn blue&lt;T: Blue&gt;(_: &amp;T) -&gt; &amp;'static str { &quot;blue&quot; }

fn main() {
    let cardinal = Cardinal;
    let blue_jay = BlueJay;
    let _turkey   = Turkey;

    // `red()` won't work on a blue jay nor vice versa
    // because of the bounds.
    println!(&quot;A cardinal is {}&quot;, red(&amp;cardinal));
    println!(&quot;A blue jay is {}&quot;, blue(&amp;blue_jay));
    //println!(&quot;A turkey is {}&quot;, red(&amp;_turkey));
    // ^ TODO: Try uncommenting this line.
}
</code></pre></pre>
<a class="header" href="print.html#see-also-36" id="see-also-36"><h3>See also:</h3></a>
<p><a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>std::cmp::Eq</code></a>, <a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>std::cmp::Ord</code>s</a>, and <a href="/trait.html"><code>trait</code>s</a></p>
<a class="header" href="print.html#multiple-bounds" id="multiple-bounds"><h1>Multiple bounds</h1></a>
<p>Multiple bounds can be applied with a <code>+</code>. Like normal, different types are
separated with <code>,</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt::{Debug, Display};

fn compare_prints&lt;T: Debug + Display&gt;(t: &amp;T) {
    println!(&quot;Debug: `{:?}`&quot;, t);
    println!(&quot;Display: `{}`&quot;, t);
}

fn compare_types&lt;T: Debug, U: Debug&gt;(t: &amp;T, u: &amp;U) {
    println!(&quot;t: `{:?}&quot;, t);
    println!(&quot;u: `{:?}&quot;, u);
}

fn main() {
    let string = &quot;words&quot;;
    let array = [1, 2, 3];
    let vec = vec![1, 2, 3];

    compare_prints(&amp;string);
    //compare_prints(&amp;array);
    // TODO ^ Try uncommenting this.

    compare_types(&amp;array, &amp;vec);
}
</code></pre></pre>
<a class="header" href="print.html#see-also-37" id="see-also-37"><h3>See also:</h3></a>
<p><a href="/hello/print.html"><code>std::fmt</code></a> and <a href="/trait.html"><code>trait</code>s</a></p>
<a class="header" href="print.html#where-clauses" id="where-clauses"><h1>Where clauses</h1></a>
<p>A bound can also be expressed using a <code>where</code> clause immediately
before the opening <code>{</code>, rather than at the type's first mention.
Additionally, <code>where</code> clauses can apply bounds to arbitrary types,
rather than just to type parameters.</p>
<p>Some cases that a <code>where</code> clause is useful:</p>
<ul>
<li>When specifying generic types and bounds separately is clearer:</li>
</ul>
<pre><code class="language-rust ignore">impl &lt;A: TraitB + TraitC, D: TraitE + TraitF&gt; MyTrait&lt;A, D&gt; for YourType {}

// Expressing bounds with a `where` clause
impl &lt;A, D&gt; MyTrait&lt;A, D&gt; for YourType where
    A: TraitB + TraitC,
    D: TraitE + TraitF {}
</code></pre>
<ul>
<li>When using a <code>where</code> clause is more expressive than using normal syntax.
The <code>impl</code> in this example cannot be directly expressed without a <code>where</code> clause:</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt::Debug;

trait PrintInOption {
    fn print_in_option(self);
}

// Because we would otherwise have to express this as `T: Debug` or 
// use another method of indirect approach, this requires a `where` clause:
impl&lt;T&gt; PrintInOption for T where
    Option&lt;T&gt;: Debug {
    // We want `Option&lt;T&gt;: Debug` as our bound because that is what's
    // being printed. Doing otherwise would be using the wrong bound.
    fn print_in_option(self) {
        println!(&quot;{:?}&quot;, Some(self));
    }
}

fn main() {
    let vec = vec![1, 2, 3];

    vec.print_in_option();
}
</code></pre></pre>
<a class="header" href="print.html#see-also-38" id="see-also-38"><h3>See also:</h3></a>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0135-where.md">RFC</a>, <a href="/custom_types/structs.html"><code>struct</code></a>, and <a href="/trait.html"><code>trait</code></a></p>
<a class="header" href="print.html#associated-items" id="associated-items"><h1>Associated items</h1></a>
<p>&quot;Associated Items&quot; refers to a set of rules pertaining to <a href="https://doc.rust-lang.org/reference/items.html"><code>item</code></a>s
of various types. It is an extension to <code>trait</code> generics, and allows
<code>trait</code>s to internally define new items.</p>
<p>One such item is called an <em>associated type</em>, providing simpler usage
patterns when the <code>trait</code> is generic over its container type.</p>
<a class="header" href="print.html#see-also-39" id="see-also-39"><h3>See also:</h3></a>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md">RFC</a></p>
<a class="header" href="print.html#the-problem" id="the-problem"><h1>The Problem</h1></a>
<p>A <code>trait</code> that is generic over its container type has type specification
requirements - users of the <code>trait</code> <em>must</em> specify all of its generic types.</p>
<p>In the example below, the <code>Contains</code> <code>trait</code> allows the use of the generic
types <code>A</code> and <code>B</code>. The trait is then implemented for the <code>Container</code> type,
specifying <code>i32</code> for <code>A</code> and <code>B</code> so that it can be used with <code>fn difference()</code>.</p>
<p>Because <code>Contains</code> is generic, we are forced to explicitly state <em>all</em> of the
generic types for <code>fn difference()</code>. In practice, we want a way to express that
<code>A</code> and <code>B</code> are determined by the <em>input</em> <code>C</code>. As you will see in the next
section, associated types provide exactly that capability.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Container(i32, i32);

// A trait which checks if 2 items are stored inside of container.
// Also retrieves first or last value.
trait Contains&lt;A, B&gt; {
    fn contains(&amp;self, &amp;A, &amp;B) -&gt; bool; // Explicitly requires `A` and `B`.
    fn first(&amp;self) -&gt; i32; // Doesn't explicitly require `A` or `B`.
    fn last(&amp;self) -&gt; i32;  // Doesn't explicitly require `A` or `B`.
}

impl Contains&lt;i32, i32&gt; for Container {
    // True if the numbers stored are equal.
    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool {
        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)
    }

    // Grab the first number.
    fn first(&amp;self) -&gt; i32 { self.0 }

    // Grab the last number.
    fn last(&amp;self) -&gt; i32 { self.1 }
}

// `C` contains `A` and `B`. In light of that, having to express `A` and
// `B` again is a nuisance.
fn difference&lt;A, B, C&gt;(container: &amp;C) -&gt; i32 where
    C: Contains&lt;A, B&gt; {
    container.last() - container.first()
}

fn main() {
    let number_1 = 3;
    let number_2 = 10;

    let container = Container(number_1, number_2);

    println!(&quot;Does container contain {} and {}: {}&quot;,
        &amp;number_1, &amp;number_2,
        container.contains(&amp;number_1, &amp;number_2));
    println!(&quot;First number: {}&quot;, container.first());
    println!(&quot;Last number: {}&quot;, container.last());

    println!(&quot;The difference is: {}&quot;, difference(&amp;container));
}
</code></pre></pre>
<a class="header" href="print.html#see-also-40" id="see-also-40"><h3>See also:</h3></a>
<p><a href="/custom_types/structs.html"><code>struct</code>s</a>, and <a href="/trait.html"><code>trait</code>s</a></p>
<a class="header" href="print.html#associated-types" id="associated-types"><h1>Associated types</h1></a>
<p>The use of &quot;Associated types&quot; improves the overall readability of code
by moving inner types locally into a trait as <em>output</em> types. Syntax
for the <code>trait</code> definition is as follows:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// `A` and `B` are defined in the trait via the `type` keyword.
// (Note: `type` in this context is different from `type` when used for
// aliases).
trait Contains {
    type A;
    type B;

    // Updated syntax to refer to these new types generically.
    fn contains(&amp;self, &amp;Self::A, &amp;Self::B) -&gt; bool;
}
#}</code></pre></pre>
<p>Note that functions that use the <code>trait</code> <code>Contains</code> are no longer required
to express <code>A</code> or <code>B</code> at all:</p>
<pre><code class="language-rust ignore">// Without using associated types
fn difference&lt;A, B, C&gt;(container: &amp;C) -&gt; i32 where
    C: Contains&lt;A, B&gt; { ... }

// Using associated types
fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 { ... }
</code></pre>
<p>Let's rewrite the example from the previous section using associated types:</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Container(i32, i32);

// A trait which checks if 2 items are stored inside of container.
// Also retrieves first or last value.
trait Contains {
    // Define generic types here which methods will be able to utilize.
    type A;
    type B;

    fn contains(&amp;self, &amp;Self::A, &amp;Self::B) -&gt; bool;
    fn first(&amp;self) -&gt; i32;
    fn last(&amp;self) -&gt; i32;
}

impl Contains for Container {
    // Specify what types `A` and `B` are. If the `input` type
    // is `Container(i32, i32)`, the `output` types are determined
    // as `i32` and `i32`.
    type A = i32;
    type B = i32;

    // `&amp;Self::A` and `&amp;Self::B` are also valid here.
    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool {
        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)
    }
    // Grab the first number.
    fn first(&amp;self) -&gt; i32 { self.0 }

    // Grab the last number.
    fn last(&amp;self) -&gt; i32 { self.1 }
}

fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 {
    container.last() - container.first()
}

fn main() {
    let number_1 = 3;
    let number_2 = 10;

    let container = Container(number_1, number_2);

    println!(&quot;Does container contain {} and {}: {}&quot;,
        &amp;number_1, &amp;number_2,
        container.contains(&amp;number_1, &amp;number_2));
    println!(&quot;First number: {}&quot;, container.first());
    println!(&quot;Last number: {}&quot;, container.last());
    
    println!(&quot;The difference is: {}&quot;, difference(&amp;container));
}
</code></pre></pre>
<a class="header" href="print.html#phantom-type-parameters" id="phantom-type-parameters"><h1>Phantom type parameters</h1></a>
<p>A phantom type parameter is one that doesn't show up at runtime,
but is checked statically (and only) at compile time.</p>
<p>Data types can use extra generic type parameters to act as markers
or to perform type checking at compile time. These extra parameters
hold no storage values, and have no runtime behavior.</p>
<p>In the following example, we combine <a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html">std::marker::PhantomData</a>
with the phantom type parameter concept to create tuples containing
different data types.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::marker::PhantomData;

// A phantom tuple struct which is generic over `A` with hidden parameter `B`.
#[derive(PartialEq)] // Allow equality test for this type.
struct PhantomTuple&lt;A, B&gt;(A,PhantomData&lt;B&gt;);

// A phantom type struct which is generic over `A` with hidden parameter `B`.
#[derive(PartialEq)] // Allow equality test for this type.
struct PhantomStruct&lt;A, B&gt; { first: A, phantom: PhantomData&lt;B&gt; }

// Note: Storage is allocated for generic type `A`, but not for `B`.
//       Therefore, `B` cannot be used in computations.

fn main() {
    // Here, `f32` and `f64` are the hidden parameters.
    // PhantomTuple type specified as `&lt;char, f32&gt;`.
    let _tuple1: PhantomTuple&lt;char, f32&gt; = PhantomTuple('Q', PhantomData);
    // PhantomTuple type specified as `&lt;char, f64&gt;`.
    let _tuple2: PhantomTuple&lt;char, f64&gt; = PhantomTuple('Q', PhantomData);

    // Type specified as `&lt;char, f32&gt;`.
    let _struct1: PhantomStruct&lt;char, f32&gt; = PhantomStruct {
        first: 'Q',
        phantom: PhantomData,
    };
    // Type specified as `&lt;char, f64&gt;`.
    let _struct2: PhantomStruct&lt;char, f64&gt; = PhantomStruct {
        first: 'Q',
        phantom: PhantomData,
    };
    
    // Compile-time Error! Type mismatch so these cannot be compared:
    //println!(&quot;_tuple1 == _tuple2 yields: {}&quot;,
    //          _tuple1 == _tuple2);
    
    // Compile-time Error! Type mismatch so these cannot be compared:
    //println!(&quot;_struct1 == _struct2 yields: {}&quot;,
    //          _struct1 == _struct2);
}
</code></pre></pre>
<a class="header" href="print.html#see-also-41" id="see-also-41"><h3>See also:</h3></a>
<p><a href="/trait/derive.html">Derive</a>, <a href="/custom_types/structs.html">struct</a>, and <a href="/custom_types/structs.html">TupleStructs</a></p>
<a class="header" href="print.html#testcase-unit-clarification" id="testcase-unit-clarification"><h1>Testcase: unit clarification</h1></a>
<p>A useful method of unit conversions can be examined by implementing <code>Add</code>
with a phantom type parameter. The <code>Add</code> <code>trait</code> is examined below:</p>
<pre><code class="language-rust ignore">// This construction would impose: `Self + RHS = Output`
// where RHS defaults to Self if not specified in the implementation.
pub trait Add&lt;RHS = Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}

// `Output` must be `T&lt;U&gt;` so that `T&lt;U&gt; + T&lt;U&gt; = T&lt;U&gt;`.
impl&lt;U&gt; Add for T&lt;U&gt; {
    type Output = T&lt;U&gt;;
    ...
}
</code></pre>
<p>The whole implementation:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::ops::Add;
use std::marker::PhantomData;

/// Create void enumerations to define unit types.
#[derive(Debug, Clone, Copy)]
enum Inch {}
#[derive(Debug, Clone, Copy)]
enum Mm {}

/// `Length` is a type with phantom type parameter `Unit`,
/// and is not generic over the length type (that is `f64`).
///
/// `f64` already implements the `Clone` and `Copy` traits.
#[derive(Debug, Clone, Copy)]
struct Length&lt;Unit&gt;(f64, PhantomData&lt;Unit&gt;);

/// The `Add` trait defines the behavior of the `+` operator.
impl&lt;Unit&gt; Add for Length&lt;Unit&gt; {
     type Output = Length&lt;Unit&gt;;

    // add() returns a new `Length` struct containing the sum.
    fn add(self, rhs: Length&lt;Unit&gt;) -&gt; Length&lt;Unit&gt; {
        // `+` calls the `Add` implementation for `f64`.
        Length(self.0 + rhs.0, PhantomData)
    }
}

fn main() {
    // Specifies `one_foot` to have phantom type parameter `Inch`.
    let one_foot:  Length&lt;Inch&gt; = Length(12.0, PhantomData);
    // `one_meter` has phantom type parameter `Mm`.
    let one_meter: Length&lt;Mm&gt;   = Length(1000.0, PhantomData);

    // `+` calls the `add()` method we implemented for `Length&lt;Unit&gt;`.
    //
    // Since `Length` implements `Copy`, `add()` does not consume
    // `one_foot` and `one_meter` but copies them into `self` and `rhs`.
    let two_feet = one_foot + one_foot;
    let two_meters = one_meter + one_meter;

    // Addition works.
    println!(&quot;one foot + one_foot = {:?} in&quot;, two_feet.0);
    println!(&quot;one meter + one_meter = {:?} mm&quot;, two_meters.0);

    // Nonsensical operations fail as they should:
    // Compile-time Error: type mismatch.
    //let one_feter = one_foot + one_meter;
}
</code></pre></pre>
<a class="header" href="print.html#see-also-42" id="see-also-42"><h3>See also:</h3></a>
<p><a href="/scope/borrow.html">Borrowing (<code>&amp;</code>)</a>, <a href="/generics/bounds.html">Bounds (<code>X: Y</code>)</a>, <a href="/custom_types/enum.html">enum</a>, <a href="/fn/methods.html">impl &amp; self</a>,
<a href="/trait/ops.html">Overloading</a>, <a href="/scope/borrow/ref.html">ref</a>, <a href="/trait.html">Traits (<code>X for Y</code>)</a>, and <a href="/custom_types/structs.html">TupleStructs</a>.</p>
<a class="header" href="print.html#scoping-rules" id="scoping-rules"><h1>Scoping rules</h1></a>
<p>Scopes play an important part in ownership, borrowing, and lifetimes.
That is, they indicate to the compiler when borrows are valid, when
resources can be freed, and when variables are created or destroyed.</p>
<a class="header" href="print.html#raii" id="raii"><h1>RAII</h1></a>
<p>Variables in Rust do more than just hold data in the stack: they also <em>own</em>
resources, e.g. <code>Box&lt;T&gt;</code> owns memory in the heap. Rust enforces <a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a>
(Resource Acquisition Is Initialization), so whenever an object goes out of
scope, its destructor is called and its owned resources are freed.</p>
<p>This behavior shields against <em>resource leak</em> bugs, so you'll never have to
manually free memory or worry about memory leaks again! Here's a quick showcase:</p>
<pre><pre class="playpen"><code class="language-rust editable">// raii.rs
fn create_box() {
    // Allocate an integer on the heap
    let _box1 = Box::new(3i32);

    // `_box1` is destroyed here, and memory gets freed
}

fn main() {
    // Allocate an integer on the heap
    let _box2 = Box::new(5i32);

    // A nested scope:
    {
        // Allocate an integer on the heap
        let _box3 = Box::new(4i32);

        // `_box3` is destroyed here, and memory gets freed
    }

    // Creating lots of boxes just for fun
    // There's no need to manually free memory!
    for _ in 0u32..1_000 {
        create_box();
    }

    // `_box2` is destroyed here, and memory gets freed
}
</code></pre></pre>
<p>Of course, we can double check for memory errors using <a href="http://valgrind.org/info/"><code>valgrind</code></a>:</p>
<pre><code class="language-bash">$ rustc raii.rs &amp;&amp; valgrind ./raii
==26873== Memcheck, a memory error detector
==26873== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==26873== Using Valgrind-3.9.0 and LibVEX; rerun with -h for copyright info
==26873== Command: ./raii
==26873==
==26873==
==26873== HEAP SUMMARY:
==26873==     in use at exit: 0 bytes in 0 blocks
==26873==   total heap usage: 1,013 allocs, 1,013 frees, 8,696 bytes allocated
==26873==
==26873== All heap blocks were freed -- no leaks are possible
==26873==
==26873== For counts of detected and suppressed errors, rerun with: -v
==26873== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 2 from 2)
</code></pre>
<p>No leaks here!</p>
<a class="header" href="print.html#see-also-43" id="see-also-43"><h3>See also:</h3></a>
<p><a href="/std/box.html">Box</a></p>
<a class="header" href="print.html#ownership-and-moves" id="ownership-and-moves"><h1>Ownership and moves</h1></a>
<p>Because variables are in charge of freeing their own resources,
<strong>resources can only have one owner</strong>. This also prevents resources
from being freed more than once. Note that not all variables own
resources (e.g. <a href="/flow_control/match/destructuring/destructure_pointers.html">references</a>).</p>
<p>When doing assignments (<code>let x = y</code>) or passing function arguments by value
(<code>foo(x)</code>), the <em>ownership</em> of the resources is transferred. In Rust-speak,
this is known as a <em>move</em>.</p>
<p>After moving resources, the previous owner can no longer be used. This avoids
creating dangling pointers.</p>
<pre><pre class="playpen"><code class="language-rust editable">// This function takes ownership of the heap allocated memory
fn destroy_box(c: Box&lt;i32&gt;) {
    println!(&quot;Destroying a box that contains {}&quot;, c);

    // `c` is destroyed and the memory freed
}

fn main() {
    // _Stack_ allocated integer
    let x = 5u32;

    // *Copy* `x` into `y` - no resources are moved
    let y = x;

    // Both values can be independently used
    println!(&quot;x is {}, and y is {}&quot;, x, y);

    // `a` is a pointer to a _heap_ allocated integer
    let a = Box::new(5i32);

    println!(&quot;a contains: {}&quot;, a);

    // *Move* `a` into `b`
    let b = a;
    // The pointer address of `a` is copied (not the data) into `b`.
    // Both are now pointers to the same heap allocated data, but
    // `b` now owns it.
    
    // Error! `a` can no longer access the data, because it no longer owns the
    // heap memory
    //println!(&quot;a contains: {}&quot;, a);
    // TODO ^ Try uncommenting this line

    // This function takes ownership of the heap allocated memory from `b`
    destroy_box(b);

    // Since the heap memory has been freed at this point, this action would
    // result in dereferencing freed memory, but it's forbidden by the compiler
    // Error! Same reason as the previous Error
    //println!(&quot;b contains: {}&quot;, b);
    // TODO ^ Try uncommenting this line
}
</code></pre></pre>
<a class="header" href="print.html#mutability-1" id="mutability-1"><h1>Mutability</h1></a>
<p>Mutability of data can be changed when ownership is transferred.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let immutable_box = Box::new(5u32);

    println!(&quot;immutable_box contains {}&quot;, immutable_box);

    // Mutability error
    //*immutable_box = 4;

    // *Move* the box, changing the ownership (and mutability)
    let mut mutable_box = immutable_box;

    println!(&quot;mutable_box contains {}&quot;, mutable_box);

    // Modify the contents of the box
    *mutable_box = 4;

    println!(&quot;mutable_box now contains {}&quot;, mutable_box);
}
</code></pre></pre>
<a class="header" href="print.html#borrowing" id="borrowing"><h1>Borrowing</h1></a>
<p>Most of the time, we'd like to access data without taking ownership over
it. To accomplish this, Rust uses a <em>borrowing</em> mechanism. Instead of
passing objects by-value (<code>T</code>), objects can be passed by reference (<code>&amp;T</code>).</p>
<p>The compiler statically guarantees (via its borrow checker) that references
<em>always</em> point to valid objects. That is, while references to an object
exist, the object cannot be destroyed.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// This function takes ownership of a box and destroys it
fn eat_box_i32(boxed_i32: Box&lt;i32&gt;) {
    println!(&quot;Destroying box that contains {}&quot;, boxed_i32);
}

// This function borrows an i32
fn borrow_i32(borrowed_i32: &amp;i32) {
    println!(&quot;This int is: {}&quot;, borrowed_i32);
}

fn main() {
    // Create a boxed i32, and a stacked i32
    let boxed_i32 = Box::new(5_i32);
    let stacked_i32 = 6_i32;

    // Borrow the contents of the box. Ownership is not taken,
    // so the contents can be borrowed again.
    borrow_i32(&amp;boxed_i32);
    borrow_i32(&amp;stacked_i32);

    {
        // Take a reference to the data contained inside the box
        let _ref_to_i32: &amp;i32 = &amp;boxed_i32;

        // Error!
        // Can't destroy `boxed_i32` while the inner value is borrowed.
        eat_box_i32(boxed_i32);
        // FIXME ^ Comment out this line

        // `_ref_to_i32` goes out of scope and is no longer borrowed.
    }

    // `boxed_i32` can now give up ownership to `eat_box` and be destroyed
    eat_box_i32(boxed_i32);
}
</code></pre></pre>
<a class="header" href="print.html#mutability-2" id="mutability-2"><h1>Mutability</h1></a>
<p>Mutable data can be mutably borrowed using <code>&amp;mut T</code>. This is called
a <em>mutable reference</em> and gives read/write access to the borrower.
In contrast, <code>&amp;T</code> borrows the data via an immutable reference, and
the borrower can read the data but not modify it:</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">#[allow(dead_code)]
#[derive(Clone, Copy)]
struct Book {
    // `&amp;'static str` is a reference to a string allocated in read only memory
    author: &amp;'static str,
    title: &amp;'static str,
    year: u32,
}

// This function takes a reference to a book
fn borrow_book(book: &amp;Book) {
    println!(&quot;I immutably borrowed {} - {} edition&quot;, book.title, book.year);
}

// This function takes a reference to a mutable book and changes `year` to 2014
fn new_edition(book: &amp;mut Book) {
    book.year = 2014;
    println!(&quot;I mutably borrowed {} - {} edition&quot;, book.title, book.year);
}

fn main() {
    // Create an immutable Book named `immutabook`
    let immutabook = Book {
        // string literals have type `&amp;'static str`
        author: &quot;Douglas Hofstadter&quot;,
        title: &quot;Gödel, Escher, Bach&quot;,
        year: 1979,
    };

    // Create a mutable copy of `immutabook` and call it `mutabook`
    let mut mutabook = immutabook;
    
    // Immutably borrow an immutable object
    borrow_book(&amp;immutabook);

    // Immutably borrow a mutable object
    borrow_book(&amp;mutabook);
    
    // Borrow a mutable object as mutable
    new_edition(&amp;mut mutabook);
    
    // Error! Cannot borrow an immutable object as mutable
    new_edition(&amp;mut immutabook);
    // FIXME ^ Comment out this line
}
</code></pre></pre>
<a class="header" href="print.html#see-also-44" id="see-also-44"><h3>See also:</h3></a>
<p><a href="../lifetime/static_lifetime.html"><code>static</code></a></p>
<a class="header" href="print.html#freezing" id="freezing"><h1>Freezing</h1></a>
<p>When data is immutably borrowed, it also <em>freezes</em>. <em>Frozen</em> data can't be
modified via the original object until all references to it go out of scope:</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    let mut _mutable_integer = 7i32;

    {
        // Borrow `_mutable_integer`
        let _large_integer = &amp;_mutable_integer;

        // Error! `_mutable_integer` is frozen in this scope
        _mutable_integer = 50;
        // FIXME ^ Comment out this line

        // `_large_integer` goes out of scope
    }

    // Ok! `_mutable_integer` is not frozen in this scope
    _mutable_integer = 3;
}
</code></pre></pre>
<a class="header" href="print.html#aliasing-1" id="aliasing-1"><h1>Aliasing</h1></a>
<p>Data can be immutably borrowed any number of times, but while immutably
borrowed, the original data can't be mutably borrowed. On the other hand,
only <em>one</em> mutable borrow is allowed at a time. The original data can be
borrowed again only <em>after</em> the mutable reference goes out of scope.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Point { x: i32, y: i32, z: i32 }

fn main() {
    let mut point = Point { x: 0, y: 0, z: 0 };

    {
        let borrowed_point = &amp;point;
        let another_borrow = &amp;point;

        // Data can be accessed via the references and the original owner
        println!(&quot;Point has coordinates: ({}, {}, {})&quot;,
                 borrowed_point.x, another_borrow.y, point.z);

        // Error! Can't borrow point as mutable because it's currently
        // borrowed as immutable.
        //let mutable_borrow = &amp;mut point;
        // TODO ^ Try uncommenting this line

        // Immutable references go out of scope
    }

    {
        let mutable_borrow = &amp;mut point;

        // Change data via mutable reference
        mutable_borrow.x = 5;
        mutable_borrow.y = 2;
        mutable_borrow.z = 1;

        // Error! Can't borrow `point` as immutable because it's currently
        // borrowed as mutable.
        //let y = &amp;point.y;
        // TODO ^ Try uncommenting this line

        // Error! Can't print because `println!` takes an immutable reference.
        //println!(&quot;Point Z coordinate is {}&quot;, point.z);
        // TODO ^ Try uncommenting this line

        // Ok! Mutable references can be passed as immutable to `println!`
        println!(&quot;Point has coordinates: ({}, {}, {})&quot;,
                 mutable_borrow.x, mutable_borrow.y, mutable_borrow.z);

        // Mutable reference goes out of scope
    }

    // Immutable references to point are allowed again
    let borrowed_point = &amp;point;
    println!(&quot;Point now has coordinates: ({}, {}, {})&quot;,
             borrowed_point.x, borrowed_point.y, borrowed_point.z);
}
</code></pre></pre>
<a class="header" href="print.html#the-ref-pattern" id="the-ref-pattern"><h1>The ref pattern</h1></a>
<p>When doing pattern matching or destructuring via the <code>let</code> binding, the <code>ref</code>
keyword can be used to take references to the fields of a struct/tuple. The
example below shows a few instances where this can be useful:</p>
<pre><pre class="playpen"><code class="language-rust editable">#[derive(Clone, Copy)]
struct Point { x: i32, y: i32 }

fn main() {
    let c = 'Q';

    // A `ref` borrow on the left side of an assignment is equivalent to
    // an `&amp;` borrow on the right side.
    let ref ref_c1 = c;
    let ref_c2 = &amp;c;

    println!(&quot;ref_c1 equals ref_c2: {}&quot;, *ref_c1 == *ref_c2);

    let point = Point { x: 0, y: 0 };

    // `ref` is also valid when destructuring a struct.
    let _copy_of_x = {
        // `ref_to_x` is a reference to the `x` field of `point`.
        let Point { x: ref ref_to_x, y: _ } = point;

        // Return a copy of the `x` field of `point`.
        *ref_to_x
    };

    // A mutable copy of `point`
    let mut mutable_point = point;

    {
        // `ref` can be paired with `mut` to take mutable references.
        let Point { x: _, y: ref mut mut_ref_to_y } = mutable_point;

        // Mutate the `y` field of `mutable_point` via a mutable reference.
        *mut_ref_to_y = 1;
    }

    println!(&quot;point is ({}, {})&quot;, point.x, point.y);
    println!(&quot;mutable_point is ({}, {})&quot;, mutable_point.x, mutable_point.y);

    // A mutable tuple that includes a pointer
    let mut mutable_tuple = (Box::new(5u32), 3u32);
    
    {
        // Destructure `mutable_tuple` to change the value of `last`.
        let (_, ref mut last) = mutable_tuple;
        *last = 2u32;
    }
    
    println!(&quot;tuple is {:?}&quot;, mutable_tuple);
}
</code></pre></pre>
<a class="header" href="print.html#lifetimes" id="lifetimes"><h1>Lifetimes</h1></a>
<p>A <em>lifetime</em> is a construct the compiler (also called the borrow checker)
uses to ensure all borrows are valid. Specifically, a variable's lifetime
begins when it is created and ends when it is destroyed. While lifetimes
and scopes are often referred to together, they are not the same.</p>
<p>Take, for example, the case where we borrow a variable via <code>&amp;</code>. The
borrow has a lifetime that is determined by where it is declared. As a result,
the borrow is valid as long as it ends before the lender is destroyed. However,
the scope of the borrow is determined by where the reference is used.</p>
<p>In the following example and in the rest of this section, we will see how
lifetimes relate to scopes, as well as how the two differ.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Lifetimes are annotated below with lines denoting the creation
// and destruction of each variable.
// `i` has the longest lifetime because its scope entirely encloses 
// both `borrow1` and `borrow2`. The duration of `borrow1` compared 
// to `borrow2` is irrelevant since they are disjoint.
fn main() {
    let i = 3; // Lifetime for `i` starts. ────────────────┐
    //                                                     │
    { //                                                   │
        let borrow1 = &amp;i; // `borrow1` lifetime starts. ──┐│
        //                                                ││
        println!(&quot;borrow1: {}&quot;, borrow1); //              ││
    } // `borrow1 ends. ──────────────────────────────────┘│
    //                                                     │
    //                                                     │
    { //                                                   │
        let borrow2 = &amp;i; // `borrow2` lifetime starts. ──┐│
        //                                                ││
        println!(&quot;borrow2: {}&quot;, borrow2); //              ││
    } // `borrow2` ends. ─────────────────────────────────┘│
    //                                                     │
}   // Lifetime ends. ─────────────────────────────────────┘
</code></pre></pre>
<p>Note that no names or types are assigned to label lifetimes.
This restricts how lifetimes will be able to be used as we will see.</p>
<a class="header" href="print.html#explicit-annotation" id="explicit-annotation"><h1>Explicit annotation</h1></a>
<p>The borrow checker uses explicit lifetime annotations to determine
how long references should be valid. In cases where lifetimes are not
elided<sup class="footnote-reference"><a href="print.html#1">1</a></sup>, Rust requires explicit annotations to determine what the
lifetime of a reference should be. The syntax for explicitly annotating
a lifetime uses an apostrophe character as follows:</p>
<pre><code class="language-rust ignore">foo&lt;'a&gt;
// `foo` has a lifetime parameter `'a`
</code></pre>
<p>Similar to <a href="/fn/closures/anonymity.html">closures</a>, using lifetimes requires generics.
Additionally, this lifetime syntax indicates that the lifetime of <code>foo</code>
may not exceed that of <code>'a</code>. Explicit annotation of a type has the form
<code>&amp;'a T</code> where <code>'a</code> has already been introduced.</p>
<p>In cases with multiple lifetimes, the syntax is similar:</p>
<pre><code class="language-rust ignore">foo&lt;'a, 'b&gt;
// `foo` has lifetime parameters `'a` and `'b`
</code></pre>
<p>In this case, the lifetime of <code>foo</code> cannot exceed that of either <code>'a</code> <em>or</em> <code>'b</code>.</p>
<p>See the following example for explicit lifetime annotation in use:</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// `print_refs` takes two references to `i32` which have different
// lifetimes `'a` and `'b`. These two lifetimes must both be at
// least as long as the function `print_refs`.
fn print_refs&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) {
    println!(&quot;x is {} and y is {}&quot;, x, y);
}

// A function which takes no arguments, but has a lifetime parameter `'a`.
fn failed_borrow&lt;'a&gt;() {
    let _x = 12;

    // ERROR: `_x` does not live long enough
    //let y: &amp;'a i32 = &amp;_x;
    // Attempting to use the lifetime `'a` as an explicit type annotation 
    // inside the function will fail because the lifetime of `&amp;_x` is shorter
    // than that of `y`. A short lifetime cannot be coerced into a longer one.
}

fn main() {
    // Create variables to be borrowed below.
    let (four, nine) = (4, 9);
    
    // Borrows (`&amp;`) of both variables are passed into the function.
    print_refs(&amp;four, &amp;nine);
    // Any input which is borrowed must outlive the borrower. 
    // In other words, the lifetime of `four` and `nine` must 
    // be longer than that of `print_refs`.
    
    failed_borrow();
    // `failed_borrow` contains no references to force `'a` to be 
    // longer than the lifetime of the function, but `'a` is longer.
    // Because the lifetime is never constrained, it defaults to `'static`.
}
</code></pre></pre>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="/scope/lifetime/elision.html">elision</a> implicitly annotates lifetimes and so is different.</p>
</div>
<a class="header" href="print.html#see-also-45" id="see-also-45"><h3>See also:</h3></a>
<p><a href="/generics.html">generics</a> and <a href="/fn/closures.html">closures</a></p>
<a class="header" href="print.html#functions-2" id="functions-2"><h1>Functions</h1></a>
<p>Ignoring <a href="/scope/lifetime/elision.html">elision</a>, function signatures with lifetimes have a few constraints:</p>
<ul>
<li>any reference <em>must</em> have an annotated lifetime.</li>
<li>any reference being returned <em>must</em> have the same lifetime as an input or
be <code>static</code>.</li>
</ul>
<p>Additionally, note that returning references without input is banned if it
would result in returning references to invalid data. The following example shows
off some valid forms of functions with lifetimes:</p>
<pre><pre class="playpen"><code class="language-rust editable">// One input reference with lifetime `'a` which must live
// at least as long as the function.
fn print_one&lt;'a&gt;(x: &amp;'a i32) {
    println!(&quot;`print_one`: x is {}&quot;, x);
}

// Mutable references are possible with lifetimes as well.
fn add_one&lt;'a&gt;(x: &amp;'a mut i32) {
    *x += 1;
}

// Multiple elements with different lifetimes. In this case, it
// would be fine for both to have the same lifetime `'a`, but
// in more complex cases, different lifetimes may be required.
fn print_multi&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) {
    println!(&quot;`print_multi`: x is {}, y is {}&quot;, x, y);
}

// Returning references that have been passed in is acceptable.
// However, the correct lifetime must be returned.
fn pass_x&lt;'a, 'b&gt;(x: &amp;'a i32, _: &amp;'b i32) -&gt; &amp;'a i32 { x }

//fn invalid_output&lt;'a&gt;() -&gt; &amp;'a i32 { &amp;7 }
// The above is invalid: `'a` must live longer than the function.
// Here, `&amp;7` would create an `i32`, followed by a reference.
// Then the data is dropped upon exiting the scope, leaving 
// a reference to invalid data to be returned.

fn main() {
    let x = 7;
    let y = 9;
    
    print_one(&amp;x);
    print_multi(&amp;x, &amp;y);
    
    let z = pass_x(&amp;x, &amp;y);
    print_one(z);

    let mut t = 3;
    add_one(&amp;mut t);
    print_one(&amp;t);
}
</code></pre></pre>
<a class="header" href="print.html#see-also-46" id="see-also-46"><h3>See also:</h3></a>
<p><a href="/fn.html">functions</a></p>
<a class="header" href="print.html#methods-1" id="methods-1"><h1>Methods</h1></a>
<p>Methods are annotated similarly to functions:</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Owner(i32);

impl Owner {
    // Annotate lifetimes as in a standalone function.
    fn add_one&lt;'a&gt;(&amp;'a mut self) { self.0 += 1; }
    fn print&lt;'a&gt;(&amp;'a self) {
        println!(&quot;`print`: {}&quot;, self.0);
    }
}

fn main() {
    let mut owner  = Owner(18);

    owner.add_one();
    owner.print();
}
</code></pre></pre>
<a class="header" href="print.html#see-also-47" id="see-also-47"><h3>See also:</h3></a>
<p><a href="/fn/methods.html">methods</a></p>
<a class="header" href="print.html#structs-1" id="structs-1"><h1>Structs</h1></a>
<p>Annotation of lifetimes in structures are also similar to functions:</p>
<pre><pre class="playpen"><code class="language-rust editable">// A type `Borrowed` which houses a reference to an
// `i32`. The reference to `i32` must outlive `Borrowed`.
#[derive(Debug)]
struct Borrowed&lt;'a&gt;(&amp;'a i32);

// Similarly, both references here must outlive this structure.
#[derive(Debug)]
struct NamedBorrowed&lt;'a&gt; {
    x: &amp;'a i32,
    y: &amp;'a i32,
}

// An enum which is either an `i32` or a reference to one.
#[derive(Debug)]
enum Either&lt;'a&gt; {
    Num(i32),
    Ref(&amp;'a i32),
}

fn main() {
    let x = 18;
    let y = 15;

    let single = Borrowed(&amp;x);
    let double = NamedBorrowed { x: &amp;x, y: &amp;y };
    let reference = Either::Ref(&amp;x);
    let number    = Either::Num(y);

    println!(&quot;x is borrowed in {:?}&quot;, single);
    println!(&quot;x and y are borrowed in {:?}&quot;, double);
    println!(&quot;x is borrowed in {:?}&quot;, reference);
    println!(&quot;y is *not* borrowed in {:?}&quot;, number);
}
</code></pre></pre>
<a class="header" href="print.html#see-also-48" id="see-also-48"><h3>See also:</h3></a>
<p><a href="/custom_types/structs.html"><code>structs</code></a></p>
<a class="header" href="print.html#bounds-1" id="bounds-1"><h1>Bounds</h1></a>
<p>Just like generic types can be bounded, lifetimes (themselves generic)
use bounds as well. The <code>:</code> character has a slightly different meaning here,
but <code>+</code> is the same. Note how the following read:</p>
<ol>
<li><code>T: 'a</code>: <em>All</em> references in <code>T</code> must outlive lifetime <code>'a</code>.</li>
<li><code>T: Trait + 'a</code>: Type <code>T</code> must implement trait <code>Trait</code> and <em>all</em> references
in <code>T</code> must outlive <code>'a</code>.</li>
</ol>
<p>The example below shows the above syntax in action:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt::Debug; // Trait to bound with.

#[derive(Debug)]
struct Ref&lt;'a, T: 'a&gt;(&amp;'a T);
// `Ref` contains a reference to a generic type `T` that has
// an unknown lifetime `'a`. `T` is bounded such that any
// *references* in `T` must outlive `'a`. Additionally, the lifetime
// of `Ref` may not exceed `'a`.

// A generic function which prints using the `Debug` trait.
fn print&lt;T&gt;(t: T) where
    T: Debug {
    println!(&quot;`print`: t is {:?}&quot;, t);
}

// Here a reference to `T` is taken where `T` implements
// `Debug` and all *references* in `T` outlive `'a`. In
// addition, `'a` must outlive the function.
fn print_ref&lt;'a, T&gt;(t: &amp;'a T) where
    T: Debug + 'a {
    println!(&quot;`print_ref`: t is {:?}&quot;, t);
}

fn main() {
    let x = 7;
    let ref_x = Ref(&amp;x);

    print_ref(&amp;ref_x);
    print(ref_x);
}
</code></pre></pre>
<a class="header" href="print.html#see-also-49" id="see-also-49"><h3>See also:</h3></a>
<p><a href="/generics.html">generics</a>, <a href="/generics/bounds.html">bounds in generics</a>, and
<a href="/generics/multi_bounds.html">multiple bounds in generics</a></p>
<a class="header" href="print.html#coercion" id="coercion"><h1>Coercion</h1></a>
<p>A longer lifetime can be coerced into a shorter one
so that it works inside a scope it normally wouldn't work in.
This comes in the form of inferred coercion by the Rust compiler,
and also in the form of declaring a lifetime difference:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Here, Rust infers a lifetime that is as short as possible.
// The two references are then coerced to that lifetime.
fn multiply&lt;'a&gt;(first: &amp;'a i32, second: &amp;'a i32) -&gt; i32 {
    first * second
}

// `&lt;'a: 'b, 'b&gt;` reads as lifetime `'a` is at least as long as `'b`.
// Here, we take in an `&amp;'a i32` and return a `&amp;'b i32` as a result of coercion.
fn choose_first&lt;'a: 'b, 'b&gt;(first: &amp;'a i32, _: &amp;'b i32) -&gt; &amp;'b i32 {
    first
}

fn main() {
    let first = 2; // Longer lifetime
    
    {
        let second = 3; // Shorter lifetime
        
        println!(&quot;The product is {}&quot;, multiply(&amp;first, &amp;second));
        println!(&quot;{} is the first&quot;, choose_first(&amp;first, &amp;second));
    };
}
</code></pre></pre>
<a class="header" href="print.html#static" id="static"><h1>static</h1></a>
<p>A <code>'static</code> lifetime is the longest possible lifetime, and lasts for
the lifetime of the running program. A <code>'static</code> lifetime may also be
coerced to a shorter lifetime. There are two ways to make a variable
with <code>'static</code> lifetime, and both are stored in the read-only memory
of the binary:</p>
<ul>
<li>Make a constant with the <code>static</code> declaration.</li>
<li>Make a <code>string</code> literal which has type: <code>&amp;'static str</code>.</li>
</ul>
<p>See the following example for a display of each method:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Make a constant with `'static` lifetime.
static NUM: i32 = 18;

// Returns a reference to `NUM` where its `'static` 
// lifetime is coerced to that of the input argument.
fn coerce_static&lt;'a&gt;(_: &amp;'a i32) -&gt; &amp;'a i32 {
    &amp;NUM
}

fn main() {
    {
        // Make a `string` literal and print it:
        let static_string = &quot;I'm in read-only memory&quot;;
        println!(&quot;static_string: {}&quot;, static_string);

        // When `static_string` goes out of scope, the reference
        // can no longer be used, but the data remains in the binary.
    }
    
    {
        // Make an integer to use for `coerce_static`:
        let lifetime_num = 9;

        // Coerce `NUM` to lifetime of `lifetime_num`:
        let coerced_static = coerce_static(&amp;lifetime_num);

        println!(&quot;coerced_static: {}&quot;, coerced_static);
    }
    
    println!(&quot;NUM: {} stays accessible!&quot;, NUM);
}
</code></pre></pre>
<a class="header" href="print.html#see-also-50" id="see-also-50"><h3>See also:</h3></a>
<p><a href="/custom_types/constants.html"><code>'static</code> constants</a></p>
<a class="header" href="print.html#elision" id="elision"><h1>elision</h1></a>
<p>Some lifetime patterns are overwelmingly common and so the borrow checker
will implicitly add them to save typing and to improve readability.
This process of implicit addition is called elision. Elision exists in Rust
solely because these patterns are common.</p>
<p>The following code shows a few examples of elision. For a more comprehensive
description of elision, see <a href="https://doc.rust-lang.org/book/lifetimes.html#lifetime-elision">lifetime elision</a> in the book.</p>
<pre><pre class="playpen"><code class="language-rust editable">// `elided_input` and `annotated_input` essentially have identical signatures
// because the lifetime of `elided_input` is elided by the compiler:
fn elided_input(x: &amp;i32) {
    println!(&quot;`elided_input`: {}&quot;, x)
}

fn annotated_input&lt;'a&gt;(x: &amp;'a i32) {
    println!(&quot;`annotated_input`: {}&quot;, x)
}

// Similarly, `elided_pass` and `annotated_pass` have identical signatures
// because the lifetime is added implicitly to `elided_pass`:
fn elided_pass(x: &amp;i32) -&gt; &amp;i32 { x }

fn annotated_pass&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32 { x }

fn main() {
    let x = 3;
    
    elided_input(&amp;x);
    annotated_input(&amp;x);

    println!(&quot;`elided_pass`: {}&quot;, elided_pass(&amp;x));
    println!(&quot;`annotated_pass`: {}&quot;, annotated_pass(&amp;x));
}
</code></pre></pre>
<a class="header" href="print.html#see-also-51" id="see-also-51"><h3>See also:</h3></a>
<p><a href="https://doc.rust-lang.org/book/lifetimes.html#lifetime-elision">elision</a></p>
<a class="header" href="print.html#traits-1" id="traits-1"><h1>Traits</h1></a>
<p>A <code>trait</code> is a collection of methods defined for an unknown type:
<code>Self</code>. They can access other methods declared in the same trait.</p>
<p>Traits can be implemented for any data type. In the example below,
we define <code>Animal</code>, a group of methods. The <code>Animal</code> <code>trait</code> is
then implemented for the <code>Sheep</code> data type, allowing the use of
methods from <code>Animal</code> with a <code>Sheep</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Sheep { naked: bool, name: &amp;'static str }

trait Animal {
    // Static method signature; `Self` refers to the implementor type.
    fn new(name: &amp;'static str) -&gt; Self;

    // Instance method signatures; these will return a string.
    fn name(&amp;self) -&gt; &amp;'static str;
    fn noise(&amp;self) -&gt; &amp;'static str;

    // Traits can provide default method definitions.
    fn talk(&amp;self) {
        println!(&quot;{} says {}&quot;, self.name(), self.noise());
    }
}

impl Sheep {
    fn is_naked(&amp;self) -&gt; bool {
        self.naked
    }

    fn shear(&amp;mut self) {
        if self.is_naked() {
            // Implementor methods can use the implementor's trait methods.
            println!(&quot;{} is already naked...&quot;, self.name());
        } else {
            println!(&quot;{} gets a haircut!&quot;, self.name);

            self.naked = true;
        }
    }
}

// Implement the `Animal` trait for `Sheep`.
impl Animal for Sheep {
    // `Self` is the implementor type: `Sheep`.
    fn new(name: &amp;'static str) -&gt; Sheep {
        Sheep { name: name, naked: false }
    }

    fn name(&amp;self) -&gt; &amp;'static str {
        self.name
    }

    fn noise(&amp;self) -&gt; &amp;'static str {
        if self.is_naked() {
            &quot;baaaaah?&quot;
        } else {
            &quot;baaaaah!&quot;
        }
    }
    
    // Default trait methods can be overridden.
    fn talk(&amp;self) {
        // For example, we can add some quiet contemplation.
        println!(&quot;{} pauses briefly... {}&quot;, self.name, self.noise());
    }
}

fn main() {
    // Type annotation is necessary in this case.
    let mut dolly: Sheep = Animal::new(&quot;Dolly&quot;);
    // TODO ^ Try removing the type annotations.

    dolly.talk();
    dolly.shear();
    dolly.talk();
}
</code></pre></pre>
<a class="header" href="print.html#derive" id="derive"><h1>Derive</h1></a>
<p>The compiler is capable of providing basic implementations for some traits via
the <code>#[derive]</code> <a href="/attribute.html">attribute</a>. These traits can still be
manually implemented if a more complex behavior is required.</p>
<p>The following is a list of derivable traits:</p>
<ul>
<li>Comparison traits:
<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>Eq</code></a>, <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a>, <a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>Ord</code></a>, <a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a></li>
<li><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>, to create <code>T</code> from <code>&amp;T</code> via a copy.</li>
<li><a href="https://doc.rust-lang.org/core/marker/trait.Copy.html"><code>Copy</code></a>, to give a type 'copy semantics' instead of 'move semantics'</li>
<li><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html"><code>Hash</code></a>, to compute a hash from <code>&amp;T</code>.</li>
<li><a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a>, to create an empty instance of a data type.</li>
<li><code>Zero</code>, to create a zero instance of a numeric data type.</li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a>, to format a value using the <code>{:?}</code> formatter.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust example">// `Centimeters`, a tuple struct that can be compared
#[derive(PartialEq, PartialOrd)]
struct Centimeters(f64);

// `Inches`, a tuple struct that can be printed
#[derive(Debug)]
struct Inches(i32);

impl Inches {
    fn to_centimeters(&amp;self) -&gt; Centimeters {
        let &amp;Inches(inches) = self;

        Centimeters(inches as f64 * 2.54)
    }
}

// `Seconds`, a tuple struct no additional attributes
struct Seconds(i32);

fn main() {
    let _one_second = Seconds(1);

    // Error: `Seconds` can't be printed; it doesn't implement the `Debug` trait
    //println!(&quot;One second looks like: {:?}&quot;, _one_second);
    // TODO ^ Try uncommenting this line

    // Error: `Seconds` can't be compared; it doesn't implement the `PartialEq` trait
    //let _this_is_true = (_one_second == _one_second);
    // TODO ^ Try uncommenting this line

    let foot = Inches(12);

    println!(&quot;One foot equals {:?}&quot;, foot);

    let meter = Centimeters(100.0);

    let cmp =
        if foot.to_centimeters() &lt; meter {
            &quot;smaller&quot;
        } else {
            &quot;bigger&quot;
        };

    println!(&quot;One foot is {} than one meter.&quot;, cmp);
}
</code></pre></pre>
<a class="header" href="print.html#see-also-52" id="see-also-52"><h3>See also:</h3></a>
<p><a href="https://doc.rust-lang.org/reference/attributes.html#derive"><code>derive</code></a></p>
<a class="header" href="print.html#operator-overloading" id="operator-overloading"><h1>Operator Overloading</h1></a>
<p>In Rust, many of the operators can be overloaded via traits. That is, some operators can
be used to accomplish different tasks based on their input arguments. This is possible
because operators are syntactic sugar for method calls. For example, the <code>+</code> operator in
<code>a + b</code> calls the <code>add</code> method (as in <code>a.add(b)</code>). This <code>add</code> method is part of the <code>Add</code>
trait. Hence, the <code>+</code> operator can be used by any implementor of the <code>Add</code> trait.</p>
<p>A list of the traits, such as <code>Add</code>, that overload operators is available <a href="https://doc.rust-lang.org/core/ops/">here</a>.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::ops;

struct Foo;
struct Bar;

#[derive(Debug)]
struct FooBar;

#[derive(Debug)]
struct BarFoo;

// The `std::ops::Add` trait is used to specify the functionality of `+`.
// Here, we make `Add&lt;Bar&gt;` - the trait for addition with a RHS of type `Bar`.
// The following block implements the operation: Foo + Bar = FooBar
impl ops::Add&lt;Bar&gt; for Foo {
    type Output = FooBar;

    fn add(self, _rhs: Bar) -&gt; FooBar {
        println!(&quot;&gt; Foo.add(Bar) was called&quot;);

        FooBar
    }
}

// By reversing the types, we end up implementing non-commutative addition.
// Here, we make `Add&lt;Foo&gt;` - the trait for addition with a RHS of type `Foo`.
// This block implements the operation: Bar + Foo = BarFoo
impl ops::Add&lt;Foo&gt; for Bar {
    type Output = BarFoo;

    fn add(self, _rhs: Foo) -&gt; BarFoo {
        println!(&quot;&gt; Bar.add(Foo) was called&quot;);

        BarFoo
    }
}

fn main() {
    println!(&quot;Foo + Bar = {:?}&quot;, Foo + Bar);
    println!(&quot;Bar + Foo = {:?}&quot;, Bar + Foo);
}
</code></pre></pre>
<a class="header" href="print.html#see-also-53" id="see-also-53"><h3>See Also</h3></a>
<p><a href="https://doc.rust-lang.org/core/ops/trait.Add.html">Add</a>, <a href="https://doc.rust-lang.org/book/syntax-index.html">Syntax Index</a></p>
<a class="header" href="print.html#drop" id="drop"><h1>Drop</h1></a>
<p>The <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> trait only has one method: <code>drop</code>, which is called automatically
when an object goes out of scope. The main use of the <code>Drop</code> trait is to free the
resources that the implementor instance owns.</p>
<p><code>Box</code>, <code>Vec</code>, <code>String</code>, <code>File</code>, and <code>Process</code> are some examples of types that
implement the <code>Drop</code> trait to free resources. The <code>Drop</code> trait can also be
manually implemented for any custom data type.</p>
<p>The following example adds a print to console to the <code>drop</code> function to announce
when it is called.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Droppable {
    name: &amp;'static str,
}

// This trivial implementation of `drop` adds a print to console.
impl Drop for Droppable {
    fn drop(&amp;mut self) {
        println!(&quot;&gt; Dropping {}&quot;, self.name);
    }
}

fn main() {
    let _a = Droppable { name: &quot;a&quot; };

    // block A
    {
        let _b = Droppable { name: &quot;b&quot; };

        // block B
        {
            let _c = Droppable { name: &quot;c&quot; };
            let _d = Droppable { name: &quot;d&quot; };

            println!(&quot;Exiting block B&quot;);
        }
        println!(&quot;Just exited block B&quot;);

        println!(&quot;Exiting block A&quot;);
    }
    println!(&quot;Just exited block A&quot;);

    // Variable can be manually dropped using the `drop` function
    drop(_a);
    // TODO ^ Try commenting this line

    println!(&quot;end of the main function&quot;);

    // `_a` *won't* be `drop`ed again here, because it already has been
    // (manually) `drop`ed
}
</code></pre></pre>
<a class="header" href="print.html#iterators" id="iterators"><h1>Iterators</h1></a>
<p>The <code>Iterator</code> trait is used to implement iterators over collections such as arrays.</p>
<p>The trait requires only a method to be defined for the <code>next</code> element,
which may be manually defined in an <code>impl</code> block or automatically
defined (as in arrays and ranges).</p>
<p>As a point of convenience for common situations, the <code>for</code> construct
turns some collections into iterators using the <a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>.into_iterator()</code></a> method.</p>
<p>Methods that can be accessed using the <code>Iterator</code> trait in addition
to those shown in the example below can be found <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html">here</a>.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Fibonacci {
    curr: u32,
    next: u32,
}

// Implement `Iterator` for `Fibonacci`.
// The `Iterator` trait only requires a method to be defined for the `next` element.
impl Iterator for Fibonacci {
    type Item = u32;
    
    // Here, we define the sequence using `.curr` and `.next`.
    // The return type is `Option&lt;T&gt;`:
    //     * When the `Iterator` is finished, `None` is returned.
    //     * Otherwise, the next value is wrapped in `Some` and returned.
    fn next(&amp;mut self) -&gt; Option&lt;u32&gt; {
        let new_next = self.curr + self.next;

        self.curr = self.next;
        self.next = new_next;

        // Since there's no endpoint to a Fibonacci sequence, the `Iterator` 
        // will never return `None`, and `Some` is always returned.
        Some(self.curr)
    }
}

// Returns a Fibonacci sequence generator
fn fibonacci() -&gt; Fibonacci {
    Fibonacci { curr: 1, next: 1 }
}

fn main() {
    // `0..3` is an `Iterator` that generates: 0, 1, and 2.
    let mut sequence = 0..3;

    println!(&quot;Four consecutive `next` calls on 0..3&quot;);
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());

    // `for` works through an `Iterator` until it returns `None`.
    // Each `Some` value is unwrapped and bound to a variable (here, `i`).
    println!(&quot;Iterate through 0..3 using `for`&quot;);
    for i in 0..3 {
        println!(&quot;&gt; {}&quot;, i);
    }

    // The `take(n)` method reduces an `Iterator` to its first `n` terms.
    println!(&quot;The first four terms of the Fibonacci sequence are: &quot;);
    for i in fibonacci().take(4) {
        println!(&quot;&gt; {}&quot;, i);
    }

    // The `skip(n)` method shortens an `Iterator` by dropping its first `n` terms.
    println!(&quot;The next four terms of the Fibonacci sequence are: &quot;);
    for i in fibonacci().skip(4).take(4) {
        println!(&quot;&gt; {}&quot;, i);
    }

    let array = [1u32, 3, 3, 7];

    // The `iter` method produces an `Iterator` over an array/slice.
    println!(&quot;Iterate the following array {:?}&quot;, &amp;array);
    for i in array.iter() {
        println!(&quot;&gt; {}&quot;, i);
    }
}
</code></pre></pre>
<a class="header" href="print.html#clone" id="clone"><h1>Clone</h1></a>
<p>When dealing with resources, the default behavior is to transfer them during
assignments or function calls. However, sometimes we need to make a
copy of the resource as well.</p>
<p>The <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a> trait helps us do exactly this. Most commonly, we can
use the <code>.clone()</code> method defined by the <code>Clone</code> trait.</p>
<pre><pre class="playpen"><code class="language-rust editable">// A unit struct without resources
#[derive(Debug, Clone, Copy)]
struct Nil;

// A tuple struct with resources that implements the `Clone` trait
#[derive(Clone, Debug)]
struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);

fn main() {
    // Instantiate `Nil`
    let nil = Nil;
    // Copy `Nil`, there are no resources to move
    let copied_nil = nil;

    // Both `Nil`s can be used independently
    println!(&quot;original: {:?}&quot;, nil);
    println!(&quot;copy: {:?}&quot;, copied_nil);

    // Instantiate `Pair`
    let pair = Pair(Box::new(1), Box::new(2));
    println!(&quot;original: {:?}&quot;, pair);

    // Copy `pair` into `moved_pair`, moves resources
    let moved_pair = pair;
    println!(&quot;copy: {:?}&quot;, moved_pair);

    // Error! `pair` has lost its resources
    //println!(&quot;original: {:?}&quot;, pair);
    // TODO ^ Try uncommenting this line
    
    // Clone `moved_pair` into `cloned_pair` (resources are included)
    let cloned_pair = moved_pair.clone();
    // Drop the original pair using std::mem::drop
    drop(moved_pair);

    // Error! `moved_pair` has been dropped
    //println!(&quot;copy: {:?}&quot;, moved_pair);
    // TODO ^ Try uncommenting this line

    // The result from .clone() can still be used!
    println!(&quot;clone: {:?}&quot;, cloned_pair);
}
</code></pre></pre>
<a class="header" href="print.html#macro_rules" id="macro_rules"><h1>macro_rules!</h1></a>
<p>Rust provides a powerful macro system that allows metaprogramming. As you've
seen in previous chapters, macros look like functions, except that their name
ends with a bang <code>!</code>, but instead of generating a function call, macros are
expanded into source code that gets compiled with the rest of the program.</p>
<p>Macros are created using the <code>macro_rules!</code> macro.</p>
<pre><pre class="playpen"><code class="language-rust editable">// This is a simple macro named `say_hello`.
macro_rules! say_hello {
    // `()` indicates that the macro takes no argument.
    () =&gt; (
        // The macro will expand into the contents of this block.
        println!(&quot;Hello!&quot;);
    )
}

fn main() {
    // This call will expand into `println!(&quot;Hello&quot;);`
    say_hello!()
}
</code></pre></pre>
<a class="header" href="print.html#designators" id="designators"><h1>Designators</h1></a>
<p>The arguments of a macro are prefixed by a dollar sign <code>$</code> and type annotated
with a <em>designator</em>:</p>
<pre><pre class="playpen"><code class="language-rust editable">macro_rules! create_function {
    // This macro takes an argument of designator `ident` and
    // creates a function named `$func_name`.
    // The `ident` designator is used for variable/function names.
    ($func_name:ident) =&gt; (
        fn $func_name() {
            // The `stringify!` macro converts an `ident` into a string.
            println!(&quot;You called {:?}()&quot;,
                     stringify!($func_name))
        }
    )
}

// Create functions named `foo` and `bar` with the above macro.
create_function!(foo);
create_function!(bar);

macro_rules! print_result {
    // This macro takes an expression of type `expr` and prints
    // it as a string along with its result.
    // The `expr` designator is used for expressions.
    ($expression:expr) =&gt; (
        // `stringify!` will convert the expression *as it is* into a string.
        println!(&quot;{:?} = {:?}&quot;,
                 stringify!($expression),
                 $expression)
    )
}

fn main() {
    foo();
    bar();

    print_result!(1u32 + 1);

    // Recall that blocks are expressions too!
    print_result!({
        let x = 1u32;

        x * x + 2 * x - 1
    });
}
</code></pre></pre>
<p>This is a list of all the designators:</p>
<ul>
<li><code>block</code></li>
<li><code>expr</code> is used for expressions</li>
<li><code>ident</code> is used for variable/function names</li>
<li><code>item</code></li>
<li><code>pat</code> (<em>pattern</em>)</li>
<li><code>path</code></li>
<li><code>stmt</code> (<em>statement</em>)</li>
<li><code>tt</code> (<em>token tree</em>)</li>
<li><code>ty</code> (<em>type</em>)</li>
</ul>
<a class="header" href="print.html#overload" id="overload"><h1>Overload</h1></a>
<p>Macros can be overloaded to accept different combinations of arguments.
In that regard, <code>macro_rules!</code> can work similarly to a match block:</p>
<pre><pre class="playpen"><code class="language-rust editable">// `test!` will compare `$left` and `$right`
// in different ways depending on how you invoke it:
macro_rules! test {
    // Arguments don't need to be separated by a comma.
    // Any template can be used!
    ($left:expr; and $right:expr) =&gt; (
        println!(&quot;{:?} and {:?} is {:?}&quot;,
                 stringify!($left),
                 stringify!($right),
                 $left &amp;&amp; $right)
    );
    // ^ each arm must end with a semicolon.
    ($left:expr; or $right:expr) =&gt; (
        println!(&quot;{:?} or {:?} is {:?}&quot;,
                 stringify!($left),
                 stringify!($right),
                 $left || $right)
    );
}

fn main() {
    test!(1i32 + 1 == 2i32; and 2i32 * 2 == 4i32);
    test!(true; or false);
}
</code></pre></pre>
<a class="header" href="print.html#repeat" id="repeat"><h1>Repeat</h1></a>
<p>Macros can use <code>+</code> in the argument list to indicate that an argument may
repeat at least once, or <code>*</code>, to indicate that the argument may repeat zero or
more times.</p>
<p>In the following example, surrounding the matcher with <code>$(...),+</code> will
match one or more expression, separated by commas.
Also note that the semicolon is optional on the last case.</p>
<pre><pre class="playpen"><code class="language-rust editable">// `min!` will calculate the minimum of any number of arguments.
macro_rules! find_min {
    // Base case:
    ($x:expr) =&gt; ($x);
    // `$x` followed by at least one `$y,`
    ($x:expr, $($y:expr),+) =&gt; (
        // Call `find_min!` on the tail `$y`
        std::cmp::min($x, find_min!($($y),+))
    )
}

fn main() {
    println!(&quot;{}&quot;, find_min!(1u32));
    println!(&quot;{}&quot;, find_min!(1u32 + 2 , 2u32));
    println!(&quot;{}&quot;, find_min!(5u32, 2u32 * 3, 4u32));
}
</code></pre></pre>
<a class="header" href="print.html#dry-dont-repeat-yourself" id="dry-dont-repeat-yourself"><h1>DRY (Don't Repeat Yourself)</h1></a>
<p>Macros allow writing DRY code by factoring out the common parts of functions
and/or test suites. Here is an example that implements and tests the <code>+=</code>, <code>*=</code>
and <code>-=</code> operators on <code>Vec&lt;T&gt;</code>:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::ops::{Add, Mul, Sub};

macro_rules! assert_equal_len {
    // The `tt` (token tree) designator is used for
    // operators and tokens.
    ($a:ident, $b: ident, $func:ident, $op:tt) =&gt; (
        assert!($a.len() == $b.len(),
                &quot;{:?}: dimension mismatch: {:?} {:?} {:?}&quot;,
                stringify!($func),
                ($a.len(),),
                stringify!($op),
                ($b.len(),));
    )
}

macro_rules! op {
    ($func:ident, $bound:ident, $op:tt, $method:ident) =&gt; (
        fn $func&lt;T: $bound&lt;T, Output=T&gt; + Copy&gt;(xs: &amp;mut Vec&lt;T&gt;, ys: &amp;Vec&lt;T&gt;) {
            assert_equal_len!(xs, ys, $func, $op);

            for (x, y) in xs.iter_mut().zip(ys.iter()) {
                *x = $bound::$method(*x, *y);
                // *x = x.$method(*y);
            }
        }
    )
}

// Implement `add_assign`, `mul_assign`, and `sub_assign` functions.
op!(add_assign, Add, +=, add);
op!(mul_assign, Mul, *=, mul);
op!(sub_assign, Sub, -=, sub);

mod test {
    use std::iter;
    macro_rules! test {
        ($func: ident, $x:expr, $y:expr, $z:expr) =&gt; {
            #[test]
            fn $func() {
                for size in 0usize..10 {
                    let mut x: Vec&lt;_&gt; = iter::repeat($x).take(size).collect();
                    let y: Vec&lt;_&gt; = iter::repeat($y).take(size).collect();
                    let z: Vec&lt;_&gt; = iter::repeat($z).take(size).collect();

                    super::$func(&amp;mut x, &amp;y);

                    assert_eq!(x, z);
                }
            }
        }
    }

    // Test `add_assign`, `mul_assign` and `sub_assign`
    test!(add_assign, 1u32, 2u32, 3u32);
    test!(mul_assign, 2u32, 3u32, 6u32);
    test!(sub_assign, 3u32, 2u32, 1u32);
}
</code></pre></pre>
<pre><code class="language-bash">$ rustc --test dry.rs &amp;&amp; ./dry
running 3 tests
test test::mul_assign ... ok
test test::add_assign ... ok
test test::sub_assign ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<a class="header" href="print.html#error-handling" id="error-handling"><h1>Error handling</h1></a>
<p>Error handling is the process of handling the possibility of failure. For
example, failing to read a file and then continuing to use that <em>bad</em> input
would clearly be problematic. Noticing and explicitly managing those errors
saves the rest of the program from various pitfalls.</p>
<p>For a more rigorous discussion of error handling, refer to the error
handling section in the <a href="https://doc.rust-lang.org/book/error-handling.html">official book</a>.</p>
<a class="header" href="print.html#panic" id="panic"><h1><code>panic</code></h1></a>
<p>The simplest error handling mechanism we will see is <code>panic</code>. It prints an
error message, starts unwinding the task, and usually exits the program.
Here, we explicitly call <code>panic</code> on our error condition:</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn give_princess(gift: &amp;str) {
    // Princesses hate snakes, so we need to stop if she disapproves!
    if gift == &quot;snake&quot; { panic!(&quot;AAAaaaaa!!!!&quot;); }

    println!(&quot;I love {}s!!!!!&quot;, gift);
}

fn main() {
    give_princess(&quot;teddy bear&quot;);
    give_princess(&quot;snake&quot;);
}
</code></pre></pre>
<a class="header" href="print.html#option--unwrap" id="option--unwrap"><h1><code>Option</code> &amp; <code>unwrap</code></h1></a>
<p>In the last example, we showed that we can induce program failure at will.
We told our program to <code>panic</code> if the princess received an inappropriate
gift - a snake. But what if the princess expected a gift and didn't receive
one? That case would be just as bad, so it needs to be handled!</p>
<p>We <em>could</em> test this against the null string (<code>&quot;&quot;</code>) as we do with a snake.
Since we're using Rust, let's instead have the compiler point out cases
where there's no gift.</p>
<p>An <code>enum</code> called <code>Option&lt;T&gt;</code> in the <code>std</code> library is used when absence is a
possibility. It manifests itself as one of two &quot;options&quot;:</p>
<ul>
<li><code>Some(T)</code>: An element of type <code>T</code> was found</li>
<li><code>None</code>: No element was found</li>
</ul>
<p>These cases can either be explicitly handled via <code>match</code> or implicitly with
<code>unwrap</code>. Implicit handling will either return the inner element or <code>panic</code>.</p>
<p>Note that it's possible to manually customize <code>panic</code> with <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.expect">expect</a>,
but <code>unwrap</code> otherwise leaves us with a less meaningful output than explicit
handling. In the following example, explicit handling yields a more
controlled result while retaining the option to <code>panic</code> if desired.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// The commoner has seen it all, and can handle any gift well.
// All gifts are handled explicitly using `match`.
fn give_commoner(gift: Option&lt;&amp;str&gt;) {
    // Specify a course of action for each case.
    match gift {
        Some(&quot;snake&quot;) =&gt; println!(&quot;Yuck! I'm throwing that snake in a fire.&quot;),
        Some(inner)   =&gt; println!(&quot;{}? How nice.&quot;, inner),
        None          =&gt; println!(&quot;No gift? Oh well.&quot;),
    }
}

// Our sheltered princess will `panic` at the sight of snakes.
// All gifts are handled implicitly using `unwrap`.
fn give_princess(gift: Option&lt;&amp;str&gt;) {
    // `unwrap` returns a `panic` when it receives a `None`.
    let inside = gift.unwrap();
    if inside == &quot;snake&quot; { panic!(&quot;AAAaaaaa!!!!&quot;); }

    println!(&quot;I love {}s!!!!!&quot;, inside);
}

fn main() {
    let food  = Some(&quot;cabbage&quot;);
    let snake = Some(&quot;snake&quot;);
    let void  = None;

    give_commoner(food);
    give_commoner(snake);
    give_commoner(void);

    let bird = Some(&quot;robin&quot;);
    let nothing = None;

    give_princess(bird);
    give_princess(nothing);
}
</code></pre></pre>
<a class="header" href="print.html#combinators-map" id="combinators-map"><h1>Combinators: <code>map</code></h1></a>
<p><code>match</code> is a valid method for handling <code>Option</code>s. However, you may
eventually find heavy usage tedious, especially with operations only valid
with an input. In these cases, <a href="https://doc.rust-lang.org/book/glossary.html#combinators">combinators</a> can be used to
manage control flow in a modular fashion.</p>
<p><code>Option</code> has a built in method called <code>map()</code>, a combinator for the simple
mapping of <code>Some -&gt; Some</code> and <code>None -&gt; None</code>. Multiple <code>map()</code> calls can be
chained together for even more flexibility.</p>
<p>In the following example, <code>process()</code> replaces all functions previous
to it while staying compact.</p>
<pre><pre class="playpen"><code class="language-rust editable">#![allow(dead_code)]

#[derive(Debug)] enum Food { Apple, Carrot, Potato }

#[derive(Debug)] struct Peeled(Food);
#[derive(Debug)] struct Chopped(Food);
#[derive(Debug)] struct Cooked(Food);

// Peeling food. If there isn't any, then return `None`.
// Otherwise, return the peeled food.
fn peel(food: Option&lt;Food&gt;) -&gt; Option&lt;Peeled&gt; {
    match food {
        Some(food) =&gt; Some(Peeled(food)),
        None       =&gt; None,
    }
}

// Chopping food. If there isn't any, then return `None`.
// Otherwise, return the chopped food.
fn chop(peeled: Option&lt;Peeled&gt;) -&gt; Option&lt;Chopped&gt; {
    match peeled {
        Some(Peeled(food)) =&gt; Some(Chopped(food)),
        None               =&gt; None,
    }
}

// Cooking food. Here, we showcase `map()` instead of `match` for case handling.
fn cook(chopped: Option&lt;Chopped&gt;) -&gt; Option&lt;Cooked&gt; {
    chopped.map(|Chopped(food)| Cooked(food))
}

// A function to peel, chop, and cook food all in sequence.
// We chain multiple uses of `map()` to simplify the code.
fn process(food: Option&lt;Food&gt;) -&gt; Option&lt;Cooked&gt; {
    food.map(|f| Peeled(f))
        .map(|Peeled(f)| Chopped(f))
        .map(|Chopped(f)| Cooked(f))
}

// Check whether there's food or not before trying to eat it!
fn eat(food: Option&lt;Cooked&gt;) {
    match food {
        Some(food) =&gt; println!(&quot;Mmm. I love {:?}&quot;, food),
        None       =&gt; println!(&quot;Oh no! It wasn't edible.&quot;),
    }
}

fn main() {
    let apple = Some(Food::Apple);
    let carrot = Some(Food::Carrot);
    let potato = None;

    let cooked_apple = cook(chop(peel(apple)));
    let cooked_carrot = cook(chop(peel(carrot)));
    // Let's try the simpler looking `process()` now.
    let cooked_potato = process(potato);

    eat(cooked_apple);
    eat(cooked_carrot);
    eat(cooked_potato);
}
</code></pre></pre>
<a class="header" href="print.html#see-also-54" id="see-also-54"><h3>See also:</h3></a>
<p><a href="/fn/closures.html">closures</a>, <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>, <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.map"><code>Option::map()</code></a></p>
<a class="header" href="print.html#combinators-and_then" id="combinators-and_then"><h1>Combinators: <code>and_then</code></h1></a>
<p><code>map()</code> was described as a chainable way to simplify <code>match</code> statements.
However, using <code>map()</code> on a function that returns an <code>Option&lt;T&gt;</code> results
in the nested <code>Option&lt;Option&lt;T&gt;&gt;</code>. Chaining multiple calls together can
then become confusing. That's where another combinator called <code>and_then()</code>,
known in some languages as flatmap, comes in.</p>
<p><code>and_then()</code> calls its function input with the wrapped value and returns the result. If the <code>Option</code> is <code>None</code>, then it returns <code>None</code> instead.</p>
<p>In the following example, <code>cookable_v2()</code> results in an <code>Option&lt;Food&gt;</code>.
Using <code>map()</code> instead of <code>and_then()</code> would have given an
<code>Option&lt;Option&lt;Food&gt;&gt;</code>, which is an invalid type for <code>eat()</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">#![allow(dead_code)]

#[derive(Debug)] enum Food { CordonBleu, Steak, Sushi }
#[derive(Debug)] enum Day { Monday, Tuesday, Wednesday }

// We don't have the ingredients to make Sushi.
fn have_ingredients(food: Food) -&gt; Option&lt;Food&gt; {
    match food {
        Food::Sushi =&gt; None,
        _           =&gt; Some(food),
    }
}

// We have the recipe for everything except Cordon Bleu.
fn have_recipe(food: Food) -&gt; Option&lt;Food&gt; {
    match food {
        Food::CordonBleu =&gt; None,
        _                =&gt; Some(food),
    }
}

// To make a dish, we need both the ingredients and the recipe.
// We can represent the logic with a chain of `match`es:
fn cookable_v1(food: Food) -&gt; Option&lt;Food&gt; {
    match have_ingredients(food) {
        None       =&gt; None,
        Some(food) =&gt; match have_recipe(food) {
            None       =&gt; None,
            Some(food) =&gt; Some(food),
        },
    }
}

// This can conveniently be rewritten more compactly with `and_then()`:
fn cookable_v2(food: Food) -&gt; Option&lt;Food&gt; {
    have_ingredients(food).and_then(have_recipe)
}

fn eat(food: Food, day: Day) {
    match cookable_v2(food) {
        Some(food) =&gt; println!(&quot;Yay! On {:?} we get to eat {:?}.&quot;, day, food),
        None       =&gt; println!(&quot;Oh no. We don't get to eat on {:?}?&quot;, day),
    }
}

fn main() {
    let (cordon_bleu, steak, sushi) = (Food::CordonBleu, Food::Steak, Food::Sushi);

    eat(cordon_bleu, Day::Monday);
    eat(steak, Day::Tuesday);
    eat(sushi, Day::Wednesday);
}
</code></pre></pre>
<a class="header" href="print.html#see-also-55" id="see-also-55"><h3>See also:</h3></a>
<p><a href="/fn/closures.html">closures</a>, <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>, and <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.and_then"><code>Option::and_then()</code></a></p>
<a class="header" href="print.html#result" id="result"><h1><code>Result</code></h1></a>
<p><a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> is a richer version of the <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a> type that
describes possible <em>error</em> instead of possible <em>absence</em>.</p>
<p>That is, <code>Result&lt;T, E&gt;</code> could have one of two outcomes:</p>
<ul>
<li><code>Ok&lt;T&gt;</code>: An element <code>T</code> was found</li>
<li><code>Err&lt;E&gt;</code>: An error was found with element <code>E</code></li>
</ul>
<p>By convention, the expected outcome is <code>Ok</code> while the unexpected outcome is <code>Err</code>.</p>
<p>Like <code>Option</code>, <code>Result</code> has many methods associated with it. <code>unwrap()</code>, for
example, either yields the element <code>T</code> or <code>panic</code>s. For case handling,
there are many combinators between <code>Result</code> and <code>Option</code> that overlap.</p>
<p>In working with Rust, you will likely encounter methods that return the
<code>Result</code> type, such as the <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse()</code></a> method. It might not always
be possible to parse a string into the other type, so <code>parse()</code> returns a
<code>Result</code> indicating possible failure.</p>
<p>Let's see what happens when we successfully and unsuccessfully <code>parse()</code> a string:</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn double_number(number_str: &amp;str) -&gt; i32 {
    // Let's try using `unwrap()` to get the number out. Will it bite us?
    2 * number_str.parse::&lt;i32&gt;().unwrap()
}

fn main() {
    let twenty = double_number(&quot;10&quot;);
    println!(&quot;double is {}&quot;, twenty);

    let tt = double_number(&quot;t&quot;);
    println!(&quot;double is {}&quot;, tt);
}
</code></pre></pre>
<p>In the unsuccessful case, <code>parse()</code> leaves us with an error for <code>unwrap()</code>
to <code>panic</code> on. Additionally, the <code>panic</code> exits our program and provides an
unpleasant error message.</p>
<p>To improve the quality of our error message, we should be more specific
about the return type and consider explicitly handling the error.</p>
<a class="header" href="print.html#map-for-result" id="map-for-result"><h1><code>map</code> for <code>Result</code></h1></a>
<p>Panicking in the previous example gave us an unhelpful error message.
To avoid that, we need to be more specific about the return type. There, the
regular element is of type <code>i32</code>.</p>
<p>To determine the <code>Err</code> type, we look to
<a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse()</code></a>, which is implemented with the <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a> trait for
<a href="https://doc.rust-lang.org/std/primitive.i32.html"><code>i32</code></a>. As a result, the <code>Err</code> type is specified as <a href="https://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>ParseIntError</code></a>.</p>
<p>In the example below, the straightforward <code>match</code> statement leads to code
that is overall more cumbersome. Luckily, the <code>map</code> method of <code>Option</code> is
one of many combinators also implemented for <code>Result</code>. <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>enum.Result</code></a>
contains a complete listing.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

// With the return type rewritten, we use pattern matching without `unwrap()`.
fn double_number(number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    match number_str.parse::&lt;i32&gt;() {
        Ok(n)  =&gt; Ok(2 * n),
        Err(e) =&gt; Err(e),
    }
}

// As with `Option`, we can use combinators such as `map()`.
// This function is otherwise identical to the one above and reads:
// Modify n if the value is valid, otherwise pass on the error.
fn double_number_map(number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    number_str.parse::&lt;i32&gt;().map(|n| 2 * n)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    // This still presents a reasonable answer.
    let twenty = double_number(&quot;10&quot;);
    print(twenty);

    // The following now provides a much more helpful error message.
    let tt = double_number_map(&quot;t&quot;);
    print(tt);
}
</code></pre></pre>
<a class="header" href="print.html#aliases-for-result" id="aliases-for-result"><h1>aliases for <code>Result</code></h1></a>
<p>How about when we want to reuse a specific <code>Result</code> type many times?
Recall that Rust allows us to create <a href="/cast/alias.html">aliases</a>. Conveniently,
we can define one for the specific <code>Result</code> in question.</p>
<p>At a module level, creating aliases can be particularly helpful. Errors
found in a specific module often have the same <code>Err</code> type, so a single alias
can succinctly define <em>all</em> associated <code>Results</code>. This is so useful that the <code>std</code> library even supplies one: <code>io::Result</code>!</p>
<p>Here's a quick example to show off the syntax:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

// Define a generic alias for a `Result` with the error type `ParseIntError`.
type AliasedResult&lt;T&gt; = Result&lt;T, ParseIntError&gt;;

// Use the above alias to refer to our specific `Result` type.
fn double_number(number_str: &amp;str) -&gt; AliasedResult&lt;i32&gt; {
    number_str.parse::&lt;i32&gt;().map(|n| 2 * n)
}

// Here, the alias again allows us to save some space.
fn print(result: AliasedResult&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(double_number(&quot;10&quot;));
    print(double_number(&quot;t&quot;));
}
</code></pre></pre>
<a class="header" href="print.html#see-also-56" id="see-also-56"><h3>See also:</h3></a>
<p><a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> and <a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a></p>
<a class="header" href="print.html#multiple-error-types" id="multiple-error-types"><h1>Multiple error types</h1></a>
<p>The previous examples have always been very convenient; <code>Result</code>s interact
with other <code>Result</code>s and <code>Option</code>s interact with other <code>Option</code>s.</p>
<p>Sometimes an <code>Option</code> needs to interact with a <code>Result</code>, or a
<code>Result&lt;T, Error1&gt;</code> needs to interact with a <code>Result&lt;T, Error2&gt;</code>. In those
cases, we want to manage our different error types in a way that makes them
composable and easy to interact with.</p>
<p>In the following code, two instances of <code>unwrap</code> generate different error
types. <code>Vec::first</code> returns an <code>Option</code>, while <code>parse::&lt;i32&gt;</code> returns a
<code>Result&lt;i32, ParseIntError&gt;</code>:</p>
<pre><code class="language-rust ignore">fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; i32 {
    let first = vec.first().unwrap(); // Generate error 1
    2 * first.parse::&lt;i32&gt;().unwrap() // Generate error 2
}

fn main() {
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    println!(&quot;The first doubled is {}&quot;, double_first(empty));
    // Error 1: the input vector is empty

    println!(&quot;The first doubled is {}&quot;, double_first(strings));
    // Error 2: the element doesn't parse to a number
}
</code></pre>
<p>Using our knowledge of combinators, we can rewrite the above to explicitly
handle errors. Since two different types of errors can occur, we need to
convert them to a common type such as a <code>String</code>.</p>
<p>To do so, we convert both the <code>Option</code> and <code>Result</code> into <code>Result</code>s, and
then map their errors to the same type:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Use `String` as our error type
type Result&lt;T&gt; = std::result::Result&lt;T, String&gt;;

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    vec.first()
       // Convert the `Option` to a `Result` if there is a value.
       // Otherwise, provide an `Err` containing this `String`.
       .ok_or(&quot;Please use a vector with at least one element.&quot;.to_owned())
       .and_then(|s| s.parse::&lt;i32&gt;()
                      // Map any errors that `parse` yields to `String`.
                      .map_err(|e| e.to_string())
                      // `Result&lt;T, String&gt;` is the new return type, 
                      // and we can now double the number inside.
                      .map(|i| 2 * i))
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<p>In the next section, we'll see an alternate method of explicitly handling these errors.</p>
<a class="header" href="print.html#see-also-57" id="see-also-57"><h3>See Also:</h3></a>
<p><a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or"><code>Option::ok_or</code></a>, <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"><code>Result::map_err</code></a></p>
<a class="header" href="print.html#early-returns" id="early-returns"><h1>Early returns</h1></a>
<p>In the previous example, we explicitly handled the errors using combinators.
Another way to deal with this case analysis is to use a combination of
<code>match</code> statements and <em>early returns</em>.</p>
<p>That is, we can simply stop executing the function and return the error if
one occurs. For some, this form of code can be easier to both read and
write. Consider this version of the previous example, rewritten using early returns:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Use `String` as our error type
type Result&lt;T&gt; = std::result::Result&lt;T, String&gt;;

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
   // Convert the `Option` to a `Result` if there is a value.
   // Otherwise, provide an `Err` containing this `String`.
    let first = match vec.first() {
        Some(first) =&gt; first,
        None =&gt; return Err(&quot;Please use a vector with at least one element.&quot;.to_owned())
    };

    // Double the number inside if `parse` works fine.
    // Otherwise, map any errors that `parse` yields to `String`.
    match first.parse::&lt;i32&gt;() {
        Ok(i) =&gt; Ok(2 * i),
        Err(e) =&gt; Err(e.to_string()),
    }
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<p>At this point, we've learned to explicitly handle errors using combinators
and early returns. While we generally want to avoid panicking, explicitly
handling all of our errors is cumbersome.</p>
<p>In the next section, we'll introduce <code>?</code> for the cases where we simply
need to <code>unwrap</code> without possibly inducing <code>panic</code>.</p>
<a class="header" href="print.html#introducing-" id="introducing-"><h1>Introducing <code>?</code></h1></a>
<p>Sometimes we just want the simplicity of <code>unwrap</code> without the possibility of
a <code>panic</code>. Until now, <code>unwrap</code> has forced us to nest deeper and deeper when
what we really wanted was to get the variable <em>out</em>. This is exactly the purpose of <code>?</code>.</p>
<p>Upon finding an <code>Err</code>, there are two valid actions to take:</p>
<ol>
<li><code>panic!</code> which we already decided to try to avoid if possible</li>
<li><code>return</code> because an <code>Err</code> means it cannot be handled</li>
</ol>
<p><code>?</code> is <em>almost</em><sup class="footnote-reference"><a href="print.html#1">1</a></sup> exactly equivalent to an <code>unwrap</code> which <code>return</code>s
instead of <code>panic</code>s on <code>Err</code>s. Let's see how we can simplify the earlier
example that used combinators:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Use `String` as our error type
type Result&lt;T&gt; = std::result::Result&lt;T, String&gt;;

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    let first = vec.first()
        .ok_or(&quot;Please use a vector with at least one element.&quot;.to_owned())?;
    
    let value = first.parse::&lt;i32&gt;()
        .map_err(|e| e.to_string())?;
    
    Ok(2 * value)
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<p>Note that up until now, we've been using <code>String</code>s as errors. However, they
are somewhat limiting as an error type. In the next section, we'll learn how
to make more structured and informative errors by defining their types.</p>
<a class="header" href="print.html#the-try-macro" id="the-try-macro"><h2>The <code>try!</code> macro</h2></a>
<p>Before there was <code>?</code>, the same functionality was achieved with the <code>try!</code> macro.
The <code>?</code> operator is now recommended, but you may still find <code>try!</code> when looking
at older code. The same <code>double_first</code> function from the previous example
would look like this using <code>try!</code>:</p>
<pre><code class="language-rust ignore">fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    let first = try!(vec.first()
        .ok_or(&quot;Please use a vector with at least one element.&quot;.to_owned()));
    
    let value = try!(first.parse::&lt;i32&gt;()
        .map_err(|e| e.to_string()));
    
    Ok(2 * value)
}
</code></pre>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>See <a href="/error/reenter_question_mark.html">re-enter ?</a> for more details.</p>
</div>
<a class="header" href="print.html#see-also-58" id="see-also-58"><h3>See also:</h3></a>
<p><a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> and <a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a></p>
<a class="header" href="print.html#defining-an-error-type" id="defining-an-error-type"><h1>Defining an error type</h1></a>
<p>Rust allows us to define our own error types. In general, a &quot;good&quot; error type:</p>
<ul>
<li>Represents different errors with the same type</li>
<li>Presents nice error messages to the user</li>
<li>Is easy to compare with other types
<ul>
<li>Good: <code>Err(EmptyVec)</code></li>
<li>Bad: <code>Err(&quot;Please use a vector with at least one element&quot;.to_owned())</code></li>
</ul>
</li>
<li>Can hold information about the error
<ul>
<li>Good: <code>Err(BadChar(c, position))</code></li>
<li>Bad: <code>Err(&quot;+ cannot be used here&quot;.to_owned())</code></li>
</ul>
</li>
</ul>
<p>Note that a <code>String</code> (which we've been using up to this point) fulfills the
first two criteria, but not the last two. This makes <code>String</code> errors verbose
to create and difficult to react to. It should not be necessary to pollute
logic heavy code with <code>String</code> formatting simply to display nicely.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;
use std::fmt;

type Result&lt;T&gt; = std::result::Result&lt;T, DoubleError&gt;;

#[derive(Debug)]
// Define our error types. These may be customized for our error handling cases. 
// Now we will be able to write our own errors, defer to an underlying error
// implementation, or do something in between.
enum DoubleError {
    // We don't require any extra info to detail this error.
    EmptyVec,
    // We will defer to the parse error implementation for their error.
    // Supplying extra info requires adding more data to the type.
    Parse(ParseIntError),
}

// Generation of an error is completely separate from how it is displayed.
// There's no need to be concerned about cluttering complex logic with the display style.
//
// Note that we don't store any extra info about the errors. This means we can't state
// which string failed to parse without modifying our types to carry that information.
impl fmt::Display for DoubleError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match *self {
            DoubleError::EmptyVec =&gt;
                write!(f, &quot;please use a vector with at least one element&quot;),
            // This is a wrapper, so defer to the underlying types' implementation of `fmt`.
            DoubleError::Parse(ref e) =&gt; e.fmt(f),
        }
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    vec.first()
       // Change the error to our new type.
       .ok_or(DoubleError::EmptyVec)
       .and_then(|s| s.parse::&lt;i32&gt;()
            // Update to the new error type here also.
            .map_err(DoubleError::Parse)
            .map(|i| 2 * i))
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<a class="header" href="print.html#see-also-59" id="see-also-59"><h3>See also:</h3></a>
<p><a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> and <a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a></p>
<a class="header" href="print.html#other-uses-of-" id="other-uses-of-"><h1>Other uses of <code>?</code></h1></a>
<p>Notice in the previous example that our immediate reaction to calling
<code>parse</code> is to <code>map</code> the error from a library error into our new custom
error type:</p>
<pre><code class="language-rust ignore">.and_then(|s| s.parse::&lt;i32&gt;())
    .map_err(DoubleError::Parse)
</code></pre>
<p>Since this is a simple and common operation, it would be convenient if it
could be elided. Alas, because <code>and_then</code> is not sufficiently flexible, it
cannot. However, we can instead use <code>?</code>.</p>
<p><code>?</code> was previously explained as either <code>unwrap</code> or <code>return Err(err)</code>.
This is only mostly true. It actually means <code>unwrap</code> or
<code>return Err(From::from(err))</code>. Since <code>From::from</code> is a conversion utility
between different types, this means that if you <code>?</code> where the error is
convertible to the return type, it will convert automatically.</p>
<p>Here, we rewrite the previous example using <code>?</code>. As a result, the
<code>map_err</code> will go away when <code>From::from</code> is implemented for our error type:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;
use std::fmt;

type Result&lt;T&gt; = std::result::Result&lt;T, DoubleError&gt;;

#[derive(Debug)]
enum DoubleError {
    EmptyVec,
    Parse(ParseIntError),
}

// Implement the conversion from `ParseIntError` to `DoubleError`. 
// This will be automatically called by `?` if a `ParseIntError` 
// needs to be converted into a `DoubleError`.
impl From&lt;ParseIntError&gt; for DoubleError {
    fn from(err: ParseIntError) -&gt; DoubleError {
        DoubleError::Parse(err)
    }
}

impl fmt::Display for DoubleError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match *self {
            DoubleError::EmptyVec =&gt;
                write!(f, &quot;please use a vector with at least one element&quot;),
            DoubleError::Parse(ref e) =&gt; e.fmt(f),
        }
    }
}

// The same structure as before but rather than chain all `Results`
// and `Options` along, we `?` to get the inner value out immediately.
fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    // Still convert to `Result` by stating how to convert `None`.
    let first = vec.first().ok_or(DoubleError::EmptyVec)?;
    let parsed = first.parse::&lt;i32&gt;()?;

    Ok(2 * parsed)
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<p>This is actually fairly clean now. Compared with the original <code>panic</code>, it
is very similar to replacing the <code>unwrap</code> calls with <code>?</code> except that the
return types are <code>Result</code>. As a result, they must be destructured at the
top level.</p>
<p>Note that you should not expect error handling of this sort to always
replace <code>unwrap</code>. This type of error handling tripled our line count and
cannot really be considered simple (even when heavily biased by the small
code size).</p>
<p>Indeed, moving a 1000 line library from <code>unwrap</code> to more proper error
handling might be feasible in an additional 100 lines of code. However, the
necessary refactoring would most definitely not be trivial.</p>
<p>Many libraries might get away with only implementing <code>Display</code> and
adding <code>From</code> on an as needed basis. However, more serious libraries will
eventually need to meet higher expectations of error handling implementation.</p>
<a class="header" href="print.html#see-also-60" id="see-also-60"><h3>See also:</h3></a>
<p><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From::from</code></a> and <a href="https://doc.rust-lang.org/reference/expressions.html#the--operator"><code>?</code></a></p>
<a class="header" href="print.html#boxing-errors" id="boxing-errors"><h1><code>Box</code>ing errors</h1></a>
<p>By implementing <code>Display</code> and <code>From</code> for our error type, we enabled
almost all of the <code>std</code> library error handling tools. However, we missed
something: the ability to easily <code>Box</code> our error type.</p>
<p>The <code>std</code> library automatically converts any type that implements the
<code>Error</code> trait into the trait object <code>Box&lt;Error&gt;</code>, via <code>From</code>. To a
library user, this conveniently allows the following:</p>
<pre><code class="language-rust ignore">fn foo(...) -&gt; Result&lt;T, Box&lt;Error&gt;&gt; { ... }
</code></pre>
<p>A user may use any variety of external libraries which each provide their own error
types. In order to define a valid <code>Result&lt;T, E&gt;</code> type, the user has a few choices:</p>
<ul>
<li>define a new wrapper error type around the library's error types</li>
<li>convert the error types to <code>String</code> or another intermediate choice</li>
<li><code>Box</code> the error types into <code>Box&lt;Error&gt;</code> via type erasure</li>
</ul>
<p>&quot;Boxing&quot; the error type is a common choice. The drawback is that the
underlying error type is only known at runtime and not
<a href="https://doc.rust-lang.org/book/trait-objects.html#dynamic-dispatch">statically determined</a>. As mentioned above, all that
needs to be done is to implement the <code>Error</code> trait:</p>
<pre><code class="language-rust ignore">trait Error: Debug + Display {
    fn description(&amp;self) -&gt; &amp;str;
    fn cause(&amp;self) -&gt; Option&lt;&amp;Error&gt;;
}
</code></pre>
<p>With this implementation, let's look at our most recent example. Note that
it is just as valid with the error type of <code>Box&lt;Error&gt;</code> as it was before
with <code>DoubleError</code>:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::error;
use std::fmt;
use std::num::ParseIntError;

// Change the alias to `Box&lt;error::Error&gt;`.
type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;error::Error&gt;&gt;;

#[derive(Debug)]
enum DoubleError {
    EmptyVec,
    Parse(ParseIntError),
}

impl From&lt;ParseIntError&gt; for DoubleError {
    fn from(err: ParseIntError) -&gt; DoubleError {
        DoubleError::Parse(err)
    }
}

impl fmt::Display for DoubleError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match *self {
            DoubleError::EmptyVec =&gt;
                write!(f, &quot;please use a vector with at least one element&quot;),
            DoubleError::Parse(ref e) =&gt; e.fmt(f),
        }
    }
}

impl error::Error for DoubleError {
    fn description(&amp;self) -&gt; &amp;str {
        match *self {
            // A very short description of the error. Doesn't need to be the
            // same as `Display`.
            DoubleError::EmptyVec =&gt; &quot;empty vectors not allowed&quot;,
            // This already impls `Error`, so defer to its own implementation.
            DoubleError::Parse(ref e) =&gt; e.description(),
        }
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {
        match *self {
            // No underlying cause so return `None`.
            DoubleError::EmptyVec =&gt; None,
            // The cause is the underlying implementation error type. Is implicitly
            // cast to the trait object `&amp;error::Error`. This works because the
            // underlying type already implements the `Error` trait.
            DoubleError::Parse(ref e) =&gt; Some(e),
        }
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    let first = vec.first().ok_or(DoubleError::EmptyVec)?;
    let parsed = first.parse::&lt;i32&gt;()?;

    Ok(2 * parsed)
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<a class="header" href="print.html#see-also-61" id="see-also-61"><h3>See also:</h3></a>
<p><a href="https://doc.rust-lang.org/book/trait-objects.html#dynamic-dispatch">Dynamic dispatch</a> and <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code> trait</a></p>
<a class="header" href="print.html#iterating-over-results" id="iterating-over-results"><h1>Iterating over <code>Result</code>s</h1></a>
<p>An <code>Iter::map</code> operation might fail, for example:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let possible_numbers: Vec&lt;_&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .collect();
    println!(&quot;Results: {:?}&quot;, possible_numbers);
}
</code></pre></pre>
<p>Let's step through strategies for handling this.</p>
<a class="header" href="print.html#ignore-the-failed-items-with-filter_map" id="ignore-the-failed-items-with-filter_map"><h2>Ignore the failed items with <code>filter_map()</code></h2></a>
<p><code>filter_map</code> calls a function and filters out the results that are <code>None</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let numbers: Vec&lt;_&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .filter_map(Result::ok)
        .collect();
    println!(&quot;Results: {:?}&quot;, numbers);
}
</code></pre></pre>
<a class="header" href="print.html#fail-the-entire-operation-with-collect" id="fail-the-entire-operation-with-collect"><h2>Fail the entire operation with <code>collect()</code></h2></a>
<p><code>Result</code> implements <code>FromIter</code> so that a vector of results (<code>Vec&lt;Result&lt;T, E&gt;&gt;</code>)
can be turned into a result with a vector (<code>Result&lt;Vec&lt;T&gt;, E&gt;</code>). Once an
<code>Result::Err</code> is found, the iteration will terminate.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let numbers: Result&lt;Vec&lt;_&gt;, _&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .collect();
    println!(&quot;Results: {:?}&quot;, numbers);
}
</code></pre></pre>
<p>This same technique can be used with <code>Option</code>.</p>
<a class="header" href="print.html#collect-all-valid-values-and-failures-with-partition" id="collect-all-valid-values-and-failures-with-partition"><h2>Collect all valid values and failures with <code>partition()</code></h2></a>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let (numbers, errors): (Vec&lt;_&gt;, Vec&lt;_&gt;) = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .partition(Result::is_ok);
    println!(&quot;Numbers: {:?}&quot;, numbers);
    println!(&quot;Errors: {:?}&quot;, errors);
}
</code></pre></pre>
<p>When you look at the results, you'll note that everything is still wrapped in
<code>Result</code>.  A little more boilerplate is needed for this.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let (numbers, errors): (Vec&lt;_&gt;, Vec&lt;_&gt;) = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .partition(Result::is_ok);
    let numbers: Vec&lt;_&gt; = numbers.into_iter().map(Result::unwrap).collect();
    let errors: Vec&lt;_&gt; = errors.into_iter().map(Result::unwrap_err).collect();
    println!(&quot;Numbers: {:?}&quot;, numbers);
    println!(&quot;Errors: {:?}&quot;, errors);
}
</code></pre></pre>
<a class="header" href="print.html#std-library-types" id="std-library-types"><h1>Std library types</h1></a>
<p>The <code>std</code> library provides many custom types which expands drastically on
the <code>primitives</code>. Some of these include:</p>
<ul>
<li>growable <code>String</code>s like: <code>&quot;hello world&quot;</code></li>
<li>growable vectors: <code>[1, 2, 3]</code></li>
<li>optional types: <code>Option&lt;i32&gt;</code></li>
<li>error handling types: <code>Result&lt;i32, i32&gt;</code></li>
<li>heap allocated pointers: <code>Box&lt;i32&gt;</code></li>
</ul>
<a class="header" href="print.html#see-also-62" id="see-also-62"><h3>See also:</h3></a>
<p><a href="/primitives.html">primitives</a> and <a href="https://doc.rust-lang.org/std/">the std library</a></p>
<a class="header" href="print.html#box-stack-and-heap" id="box-stack-and-heap"><h1>Box, stack and heap</h1></a>
<p>All values in Rust are stack allocated by default. Values can be <em>boxed</em>
(allocated in the heap) by creating a <code>Box&lt;T&gt;</code>. A box is a smart pointer to a
heap allocated value of type <code>T</code>. When a box goes out of scope, its destructor
is called, the inner object is destroyed, and the memory in the heap is freed.</p>
<p>Boxed values can be dereferenced using the <code>*</code> operator; this removes one layer
of indirection.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::mem;

#[allow(dead_code)]
#[derive(Debug, Clone, Copy)]
struct Point {
    x: f64,
    y: f64,
}

#[allow(dead_code)]
struct Rectangle {
    p1: Point,
    p2: Point,
}

fn origin() -&gt; Point {
    Point { x: 0.0, y: 0.0 }
}

fn boxed_origin() -&gt; Box&lt;Point&gt; {
    // Allocate this point in the heap, and return a pointer to it
    Box::new(Point { x: 0.0, y: 0.0 })
}

fn main() {
    // (all the type annotations are superfluous)
    // Stack allocated variables
    let point: Point = origin();
    let rectangle: Rectangle = Rectangle {
        p1: origin(),
        p2: Point { x: 3.0, y: 4.0 }
    };

    // Heap allocated rectangle
    let boxed_rectangle: Box&lt;Rectangle&gt; = Box::new(Rectangle {
        p1: origin(),
        p2: origin()
    });

    // The output of functions can be boxed
    let boxed_point: Box&lt;Point&gt; = Box::new(origin());

    // Double indirection
    let box_in_a_box: Box&lt;Box&lt;Point&gt;&gt; = Box::new(boxed_origin());

    println!(&quot;Point occupies {} bytes in the stack&quot;,
             mem::size_of_val(&amp;point));
    println!(&quot;Rectangle occupies {} bytes in the stack&quot;,
             mem::size_of_val(&amp;rectangle));

    // box size = pointer size
    println!(&quot;Boxed point occupies {} bytes in the stack&quot;,
             mem::size_of_val(&amp;boxed_point));
    println!(&quot;Boxed rectangle occupies {} bytes in the stack&quot;,
             mem::size_of_val(&amp;boxed_rectangle));
    println!(&quot;Boxed box occupies {} bytes in the stack&quot;,
             mem::size_of_val(&amp;box_in_a_box));

    // Copy the data contained in `boxed_point` into `unboxed_point`
    let unboxed_point: Point = *boxed_point;
    println!(&quot;Unboxed point occupies {} bytes in the stack&quot;,
             mem::size_of_val(&amp;unboxed_point));
}
</code></pre></pre>
<a class="header" href="print.html#vectors" id="vectors"><h1>Vectors</h1></a>
<p>Vectors are re-sizable arrays. Like slices, their size is not known at compile
time, but they can grow or shrink at any time. A vector is represented using
3 words: a pointer to the data, its length, and its capacity. The capacity
indicates how much memory is reserved for the vector. The vector can grow as
long as the length is smaller than the capacity. When this threshold needs to
be surpassed, the vector is reallocated with a larger capacity.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // Iterators can be collected into vectors
    let collected_iterator: Vec&lt;i32&gt; = (0..10).collect();
    println!(&quot;Collected (0..10) into: {:?}&quot;, collected_iterator);

    // The `vec!` macro can be used to initialize a vector
    let mut xs = vec![1i32, 2, 3];
    println!(&quot;Initial vector: {:?}&quot;, xs);

    // Insert new element at the end of the vector
    println!(&quot;Push 4 into the vector&quot;);
    xs.push(4);
    println!(&quot;Vector: {:?}&quot;, xs);

    // Error! Immutable vectors can't grow
    collected_iterator.push(0);
    // FIXME ^ Comment out this line

    // The `len` method yields the current size of the vector
    println!(&quot;Vector size: {}&quot;, xs.len());

    // Indexing is done using the square brackets (indexing starts at 0)
    println!(&quot;Second element: {}&quot;, xs[1]);

    // `pop` removes the last element from the vector and returns it
    println!(&quot;Pop last element: {:?}&quot;, xs.pop());

    // Out of bounds indexing yields a panic
    println!(&quot;Fourth element: {}&quot;, xs[3]);
    // FIXME ^ Comment out this line

    // `Vector`s can be easily iterated over
    println!(&quot;Contents of xs:&quot;);
    for x in xs.iter() {
        println!(&quot;&gt; {}&quot;, x);
    }

    // A `Vector` can also be iterated over while the iteration
    // count is enumerated in a separate variable (`i`)
    for (i, x) in xs.iter().enumerate() {
        println!(&quot;In position {} we have value {}&quot;, i, x);
    }

    // Thanks to `iter_mut`, mutable `Vector`s can also be iterated
    // over in a way that allows modifying each value
    for x in xs.iter_mut() {
        *x *= 3;
    }
    println!(&quot;Updated vector: {:?}&quot;, xs);
}
</code></pre></pre>
<p>More <code>Vec</code> methods can be found under the
<a href="https://doc.rust-lang.org/std/vec/">std::vec</a> module</p>
<a class="header" href="print.html#strings" id="strings"><h1>Strings</h1></a>
<p>There are two types of strings in Rust: <code>String</code> and <code>&amp;str</code>.</p>
<p>A <code>String</code> is stored as a vector of bytes (<code>Vec&lt;u8&gt;</code>), but guaranteed to
always be a valid UTF-8 sequence. <code>String</code> is heap allocated, growable and not
null terminated.</p>
<p><code>&amp;str</code> is a slice (<code>&amp;[u8]</code>) that always points to a valid UTF-8 sequence, and
can be used to view into a <code>String</code>, just like <code>&amp;[T]</code> is a view into <code>Vec&lt;T&gt;</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // (all the type annotations are superfluous)
    // A reference to a string allocated in read only memory
    let pangram: &amp;'static str = &quot;the quick brown fox jumps over the lazy dog&quot;;
    println!(&quot;Pangram: {}&quot;, pangram);

    // Iterate over words in reverse, no new string is allocated
    println!(&quot;Words in reverse&quot;);
    for word in pangram.split_whitespace().rev() {
        println!(&quot;&gt; {}&quot;, word);
    }

    // Copy chars into a vector, sort and remove duplicates
    let mut chars: Vec&lt;char&gt; = pangram.chars().collect();
    chars.sort();
    chars.dedup();

    // Create an empty and growable `String`
    let mut string = String::new();
    for c in chars {
        // Insert a char at the end of string
        string.push(c);
        // Insert a string at the end of string
        string.push_str(&quot;, &quot;);
    }

    // The trimmed string is a slice to the original string, hence no new
    // allocation is performed
    let chars_to_trim: &amp;[char] = &amp;[' ', ','];
    let trimmed_str: &amp;str = string.trim_matches(chars_to_trim);
    println!(&quot;Used characters: {}&quot;, trimmed_str);

    // Heap allocate a string
    let alice = String::from(&quot;I like dogs&quot;);
    // Allocate new memory and store the modified string there
    let bob: String = alice.replace(&quot;dog&quot;, &quot;cat&quot;);

    println!(&quot;Alice says: {}&quot;, alice);
    println!(&quot;Bob says: {}&quot;, bob);
}
</code></pre></pre>
<p>More <code>str</code>/<code>String</code> methods can be found under the
<a href="https://doc.rust-lang.org/std/str/">std::str</a> and
<a href="https://doc.rust-lang.org/std/string/">std::string</a>
modules</p>
<a class="header" href="print.html#option" id="option"><h1><code>Option</code></h1></a>
<p>Sometimes it's desirable to catch the failure of some parts of a program
instead of calling <code>panic!</code>; this can be accomplished using the <code>Option</code> enum.</p>
<p>The <code>Option&lt;T&gt;</code> enum has two variants:</p>
<ul>
<li><code>None</code>, to indicate failure or lack of value, and</li>
<li><code>Some(value)</code>, a tuple struct that wraps a <code>value</code> with type <code>T</code>.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// An integer division that doesn't `panic!`
fn checked_division(dividend: i32, divisor: i32) -&gt; Option&lt;i32&gt; {
    if divisor == 0 {
        // Failure is represented as the `None` variant
        None
    } else {
        // Result is wrapped in a `Some` variant
        Some(dividend / divisor)
    }
}

// This function handles a division that may not succeed
fn try_division(dividend: i32, divisor: i32) {
    // `Option` values can be pattern matched, just like other enums
    match checked_division(dividend, divisor) {
        None =&gt; println!(&quot;{} / {} failed!&quot;, dividend, divisor),
        Some(quotient) =&gt; {
            println!(&quot;{} / {} = {}&quot;, dividend, divisor, quotient)
        },
    }
}

fn main() {
    try_division(4, 2);
    try_division(1, 0);

    // Binding `None` to a variable needs to be type annotated
    let none: Option&lt;i32&gt; = None;
    let _equivalent_none = None::&lt;i32&gt;;

    let optional_float = Some(0f32);

    // Unwrapping a `Some` variant will extract the value wrapped.
    println!(&quot;{:?} unwraps to {:?}&quot;, optional_float, optional_float.unwrap());

    // Unwrapping a `None` variant will `panic!`
    println!(&quot;{:?} unwraps to {:?}&quot;, none, none.unwrap());
}
</code></pre></pre>
<a class="header" href="print.html#result-1" id="result-1"><h1><code>Result</code></h1></a>
<p>We've seen that the <code>Option</code> enum can be used as a return value from functions
that may fail, where <code>None</code> can be returned to indicate failure. However,
sometimes it is important to express <em>why</em> an operation failed. To do this we
have the <code>Result</code> enum.</p>
<p>The <code>Result&lt;T, E&gt;</code> enum has two variants:</p>
<ul>
<li><code>Ok(value)</code> which indicates that the operation succeeded, and wraps the
<code>value</code> returned by the operation. (<code>value</code> has type <code>T</code>)</li>
<li><code>Err(why)</code>, which indicates that the operation failed, and wraps <code>why</code>,
which (hopefully) explains the cause of the failure. (<code>why</code> has type <code>E</code>)</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">mod checked {
    // Mathematical &quot;errors&quot; we want to catch
    #[derive(Debug)]
    pub enum MathError {
        DivisionByZero,
        NonPositiveLogarithm,
        NegativeSquareRoot,
    }

    pub type MathResult = Result&lt;f64, MathError&gt;;

    pub fn div(x: f64, y: f64) -&gt; MathResult {
        if y == 0.0 {
            // This operation would `fail`, instead let's return the reason of
            // the failure wrapped in `Err`
            Err(MathError::DivisionByZero)
        } else {
            // This operation is valid, return the result wrapped in `Ok`
            Ok(x / y)
        }
    }

    pub fn sqrt(x: f64) -&gt; MathResult {
        if x &lt; 0.0 {
            Err(MathError::NegativeSquareRoot)
        } else {
            Ok(x.sqrt())
        }
    }

    pub fn ln(x: f64) -&gt; MathResult {
        if x &lt;= 0.0 {
            Err(MathError::NonPositiveLogarithm)
        } else {
            Ok(x.ln())
        }
    }
}

// `op(x, y)` === `sqrt(ln(x / y))`
fn op(x: f64, y: f64) -&gt; f64 {
    // This is a three level match pyramid!
    match checked::div(x, y) {
        Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
        Ok(ratio) =&gt; match checked::ln(ratio) {
            Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
            Ok(ln) =&gt; match checked::sqrt(ln) {
                Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
                Ok(sqrt) =&gt; sqrt,
            },
        },
    }
}

fn main() {
    // Will this fail?
    println!(&quot;{}&quot;, op(1.0, 10.0));
}
</code></pre></pre>
<a class="header" href="print.html#" id=""><h1><code>?</code></h1></a>
<p>Chaining results using match can get pretty untidy; luckily, the <code>?</code> operator
can be used to make things pretty again. <code>?</code> is used at the end of an expression
returning a <code>Result</code>, and is equivalent to a match expression, where the
<code>Err(err)</code> branch expands to an early <code>return Err(err)</code>, and the <code>Ok(ok)</code> branch
expands to an <code>ok</code> expression.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">mod checked {
    #[derive(Debug)]
    enum MathError {
        DivisionByZero,
        NonPositiveLogarithm,
        NegativeSquareRoot,
    }

    type MathResult = Result&lt;f64, MathError&gt;;

    fn div(x: f64, y: f64) -&gt; MathResult {
        if y == 0.0 {
            Err(MathError::DivisionByZero)
        } else {
            Ok(x / y)
        }
    }

    fn sqrt(x: f64) -&gt; MathResult {
        if x &lt; 0.0 {
            Err(MathError::NegativeSquareRoot)
        } else {
            Ok(x.sqrt())
        }
    }

    fn ln(x: f64) -&gt; MathResult {
        if x &lt;= 0.0 {
            Err(MathError::NonPositiveLogarithm)
        } else {
            Ok(x.ln())
        }
    }

    // Intermediate function
    fn op_(x: f64, y: f64) -&gt; MathResult {
        // if `div` &quot;fails&quot;, then `DivisionByZero` will be `return`ed
        let ratio = div(x, y)?;

        // if `ln` &quot;fails&quot;, then `NegativeLogarithm` will be `return`ed
        let ln = ln(ratio)?;

        sqrt(ln)
    }

    pub fn op(x: f64, y: f64) {
        match op_(x, y) {
            Err(why) =&gt; panic!(match why {
                MathError::NonPositiveLogarithm
                    =&gt; &quot;logarithm of non-positive number&quot;,
                MathError::DivisionByZero
                    =&gt; &quot;division by zero&quot;,
                MathError::NegativeSquareRoot
                    =&gt; &quot;square root of negative number&quot;,
            }),
            Ok(value) =&gt; println!(&quot;{}&quot;, value),
        }
    }
}

fn main() {
    checked::op(1.0, 10.0);
}
</code></pre></pre>
<p>Be sure to check the <a href="https://doc.rust-lang.org/std/result/index.html">documentation</a>,
as there are many methods to map/compose <code>Result</code>.</p>
<a class="header" href="print.html#panic-1" id="panic-1"><h1><code>panic!</code></h1></a>
<p>The <code>panic!</code> macro can be used to generate a panic and start unwinding
its stack. While unwinding, the runtime will take care of freeing all the
resources <em>owned</em> by the thread by calling the destructor of all its objects.</p>
<p>Since we are dealing with programs with only one thread, <code>panic!</code> will cause the
program to report the panic message and exit.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// Re-implementation of integer division (/)
fn division(dividend: i32, divisor: i32) -&gt; i32 {
    if divisor == 0 {
        // Division by zero triggers a panic
        panic!(&quot;division by zero&quot;);
    } else {
        dividend / divisor
    }
}

// The `main` task
fn main() {
    // Heap allocated integer
    let _x = Box::new(0i32);

    // This operation will trigger a task failure
    division(3, 0);

    println!(&quot;This point won't be reached!&quot;);

    // `_x` should get destroyed at this point
}
</code></pre></pre>
<p>Let's check that <code>panic!</code> doesn't leak memory.</p>
<pre><code class="language-text">$ rustc panic.rs &amp;&amp; valgrind ./panic
==4401== Memcheck, a memory error detector
==4401== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==4401== Using Valgrind-3.10.0.SVN and LibVEX; rerun with -h for copyright info
==4401== Command: ./panic
==4401== 
thread '&lt;main&gt;' panicked at 'division by zero', panic.rs:5
==4401== 
==4401== HEAP SUMMARY:
==4401==     in use at exit: 0 bytes in 0 blocks
==4401==   total heap usage: 18 allocs, 18 frees, 1,648 bytes allocated
==4401== 
==4401== All heap blocks were freed -- no leaks are possible
==4401== 
==4401== For counts of detected and suppressed errors, rerun with: -v
==4401== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</code></pre>
<a class="header" href="print.html#hashmap" id="hashmap"><h1>HashMap</h1></a>
<p>Where vectors store values by an integer index, <code>HashMap</code>s store values by key.
<code>HashMap</code> keys can be booleans, integers, strings,
or any other type that implements the <code>Eq</code> and <code>Hash</code> traits.
More on this in the next section.</p>
<p>Like vectors, <code>HashMap</code>s are growable, but HashMaps can also shrink themselves
when they have excess space.
You can create a HashMap with a certain starting capacity using
<code>HashMap::with_capacity(uint)</code>, or use <code>HashMap::new()</code> to get a HashMap
with a default initial capacity (recommended).</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::collections::HashMap;

fn call(number: &amp;str) -&gt; &amp;str {
    match number {
        &quot;798-1364&quot; =&gt; &quot;We're sorry, the call cannot be completed as dialed. 
            Please hang up and try again.&quot;,
        &quot;645-7689&quot; =&gt; &quot;Hello, this is Mr. Awesome's Pizza. My name is Fred.
            What can I get for you today?&quot;,
        _ =&gt; &quot;Hi! Who is this again?&quot;
    }
}

fn main() { 
    let mut contacts = HashMap::new();

    contacts.insert(&quot;Daniel&quot;, &quot;798-1364&quot;);
    contacts.insert(&quot;Ashley&quot;, &quot;645-7689&quot;);
    contacts.insert(&quot;Katie&quot;, &quot;435-8291&quot;);
    contacts.insert(&quot;Robert&quot;, &quot;956-1745&quot;);

    // Takes a reference and returns Option&lt;&amp;V&gt;
    match contacts.get(&amp;&quot;Daniel&quot;) {
        Some(&amp;number) =&gt; println!(&quot;Calling Daniel: {}&quot;, call(number)),
        _ =&gt; println!(&quot;Don't have Daniel's number.&quot;),
    }

    // `HashMap::insert()` returns `None`
    // if the inserted value is new, `Some(value)` otherwise
    contacts.insert(&quot;Daniel&quot;, &quot;164-6743&quot;);

    match contacts.get(&amp;&quot;Ashley&quot;) {
        Some(&amp;number) =&gt; println!(&quot;Calling Ashley: {}&quot;, call(number)),
        _ =&gt; println!(&quot;Don't have Ashley's number.&quot;),
    }

    contacts.remove(&amp;(&quot;Ashley&quot;)); 

    // `HashMap::iter()` returns an iterator that yields 
    // (&amp;'a key, &amp;'a value) pairs in arbitrary order.
    for (contact, &amp;number) in contacts.iter() {
        println!(&quot;Calling {}: {}&quot;, contact, call(number)); 
    }
}
</code></pre></pre>
<p>For more information on how hashing and hash maps
(sometimes called hash tables) work, have a look at
<a href="https://en.wikipedia.org/wiki/Hash_table">Hash Table Wikipedia</a></p>
<a class="header" href="print.html#alternatecustom-key-types" id="alternatecustom-key-types"><h1>Alternate/custom key types</h1></a>
<p>Any type that implements the <code>Eq</code> and <code>Hash</code> traits can be a key in <code>HashMap</code>.
This includes:</p>
<ul>
<li><code>bool</code> (though not very useful since there is only two possible keys)</li>
<li><code>int</code>, <code>uint</code>, and all variations thereof</li>
<li><code>String</code> and <code>&amp;str</code> (protip: you can have a <code>HashMap</code> keyed by <code>String</code>
and call <code>.get()</code> with an <code>&amp;str</code>)</li>
</ul>
<p>Note that <code>f32</code> and <code>f64</code> do <em>not</em> implement <code>Hash</code>,
likely because <a href="https://en.wikipedia.org/wiki/Floating_point#Accuracy_problems">floating-point precision errors</a>
would make using them as hashmap keys horribly error-prone.</p>
<p>All collection classes implement <code>Eq</code> and <code>Hash</code>
if their contained type also respectively implements <code>Eq</code> and <code>Hash</code>.
For example, <code>Vec&lt;T&gt;</code> will implement <code>Hash</code> if <code>T</code> implements <code>Hash</code>.</p>
<p>You can easily implement <code>Eq</code> and <code>Hash</code> for a custom type with just one line:
<code>#[derive(PartialEq, Eq, Hash)]</code></p>
<p>The compiler will do the rest. If you want more control over the details,
you can implement <code>Eq</code> and/or <code>Hash</code> yourself.
This guide will not cover the specifics of implementing <code>Hash</code>.</p>
<p>To play around with using a <code>struct</code> in <code>HashMap</code>,
let's try making a very simple user logon system:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::collections::HashMap;

// Eq requires that you derive PartialEq on the type.
#[derive(PartialEq, Eq, Hash)]
struct Account&lt;'a&gt;{
    username: &amp;'a str,
    password: &amp;'a str,
}

struct AccountInfo&lt;'a&gt;{
    name: &amp;'a str,
    email: &amp;'a str,
}

type Accounts&lt;'a&gt; = HashMap&lt;Account&lt;'a&gt;, AccountInfo&lt;'a&gt;&gt;;

fn try_logon&lt;'a&gt;(accounts: &amp;Accounts&lt;'a&gt;,
        username: &amp;'a str, password: &amp;'a str){
    println!(&quot;Username: {}&quot;, username);
    println!(&quot;Password: {}&quot;, password);
    println!(&quot;Attempting logon...&quot;);

    let logon = Account {
        username: username,
        password: password,
    };

    match accounts.get(&amp;logon) {
        Some(account_info) =&gt; {
            println!(&quot;Successful logon!&quot;);
            println!(&quot;Name: {}&quot;, account_info.name);
            println!(&quot;Email: {}&quot;, account_info.email);
        },
        _ =&gt; println!(&quot;Login failed!&quot;),
    }
}

fn main(){
    let mut accounts: Accounts = HashMap::new();

    let account = Account {
        username: &quot;j.everyman&quot;,
        password: &quot;password123&quot;,
    };

    let account_info = AccountInfo {
        name: &quot;John Everyman&quot;,
        email: &quot;j.everyman@email.com&quot;,
    };

    accounts.insert(account, account_info);

    try_logon(&amp;accounts, &quot;j.everyman&quot;, &quot;psasword123&quot;);

    try_logon(&amp;accounts, &quot;j.everyman&quot;, &quot;password123&quot;);
}
</code></pre></pre>
<a class="header" href="print.html#hashset" id="hashset"><h1>HashSet</h1></a>
<p>Consider a <code>HashSet</code> as a <code>HashMap</code> where we just care about the keys (
<code>HashSet&lt;T&gt;</code> is, in actuality, just a wrapper around <code>HashMap&lt;T, ()&gt;</code>).</p>
<p>&quot;What's the point of that?&quot; you ask. &quot;I could just store the keys in a <code>Vec</code>.&quot;</p>
<p>A <code>HashSet</code>'s unique feature is that
it is guaranteed to not have duplicate elements.
That's the contract that any set collection fulfills.
<code>HashSet</code> is just one implementation. (see also: <a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html"><code>BTreeSet</code></a>)</p>
<p>If you insert a value that is already present in the <code>HashSet</code>,
(i.e. the new value is equal to the existing and they both have the same hash),
then the new value will replace the old.</p>
<p>This is great for when you never want more than one of something,
or when you want to know if you've already got something.</p>
<p>But sets can do more than that.</p>
<p>Sets have 4 primary operations (all of the following calls return an iterator):</p>
<ul>
<li>
<p><code>union</code>: get all the unique elements in both sets.</p>
</li>
<li>
<p><code>difference</code>: get all the elements that are in the first set but not the second.</p>
</li>
<li>
<p><code>intersection</code>: get all the elements that are only in <em>both</em> sets.</p>
</li>
<li>
<p><code>symmetric_difference</code>:
get all the elements that are in one set or the other, but <em>not</em> both.</p>
</li>
</ul>
<p>Try all of these in the following example.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">use std::collections::HashSet;

fn main() {
    let mut a: HashSet&lt;i32&gt; = vec!(1i32, 2, 3).into_iter().collect();
    let mut b: HashSet&lt;i32&gt; = vec!(2i32, 3, 4).into_iter().collect();

    assert!(a.insert(4));
    assert!(a.contains(&amp;4));

    // `HashSet::insert()` returns false if
    // there was a value already present.
    assert!(b.insert(4), &quot;Value 4 is already in set B!&quot;);
    // FIXME ^ Comment out this line

    b.insert(5);

    // If a collection's element type implements `Debug`,
    // then the collection implements `Debug`.
    // It usually prints its elements in the format `[elem1, elem2, ...]`
    println!(&quot;A: {:?}&quot;, a);
    println!(&quot;B: {:?}&quot;, b);

    // Print [1, 2, 3, 4, 5] in arbitrary order
    println!(&quot;Union: {:?}&quot;, a.union(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // This should print [1]
    println!(&quot;Difference: {:?}&quot;, a.difference(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // Print [2, 3, 4] in arbitrary order.
    println!(&quot;Intersection: {:?}&quot;, a.intersection(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // Print [1, 5]
    println!(&quot;Symmetric Difference: {:?}&quot;,
             a.symmetric_difference(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());
}
</code></pre></pre>
<p>(Examples adapted from the <a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html#method.difference">documentation.</a>)</p>
<a class="header" href="print.html#std-misc" id="std-misc"><h1>Std misc</h1></a>
<p>Many other types are provided by the std library to support
things such as:</p>
<ul>
<li>Threads</li>
<li>Channels</li>
<li>File I/O</li>
</ul>
<p>These expand beyond what the <a href="/primitives.html">primitives</a> provide.</p>
<a class="header" href="print.html#see-also-63" id="see-also-63"><h3>See also:</h3></a>
<p><a href="/primitives.html">primitives</a> and <a href="https://doc.rust-lang.org/std/">the std library</a></p>
<a class="header" href="print.html#threads" id="threads"><h1>Threads</h1></a>
<p>Rust provides a mechanism for spawning native OS threads via the <code>spawn</code>
function, the argument of this function is a moving closure.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::thread;

static NTHREADS: i32 = 10;

// This is the `main` thread
fn main() {
    // Make a vector to hold the children which are spawned.
    let mut children = vec![];

    for i in 0..NTHREADS {
        // Spin up another thread
        children.push(thread::spawn(move || {
            println!(&quot;this is thread number {}&quot;, i)
        }));
    }

    for child in children {
        // Wait for the thread to finish. Returns a result.
        let _ = child.join();
    }
}
</code></pre></pre>
<p>These threads will be scheduled by the OS.</p>
<a class="header" href="print.html#testcase-map-reduce" id="testcase-map-reduce"><h1>Testcase: map-reduce</h1></a>
<p>Rust makes it very easy to parallelise data processing, without many of the headaches traditionally associated with such an attempt.</p>
<p>The standard library provides great threading primitives out of the box.
These, combined with Rust's concept of Ownership and aliasing rules, automatically prevent
data races.</p>
<p>The aliasing rules (one writable reference XOR many readable references) automatically prevent
you from manipulating state that is visible to other threads. (Where synchronisation is needed,
there are synchronisation
primitives like <code>Mutex</code>es or <code>Channel</code>s.)</p>
<p>In this example, we will calculate the sum of all digits in a block of numbers.
We will do this by parcelling out chunks of the block into different threads. Each thread will sum
its tiny block of digits, and subsequently we will sum the intermediate sums produced by each
thread.</p>
<p>Note that, although we're passing references across thread boundaries, Rust understands that we're
only passing read-only references, and that thus no unsafety or data races can occur. Because
we're <code>move</code>-ing the data segments into the thread, Rust will also ensure the data is kept alive
until the threads exit, so no dangling pointers occur.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::thread;

// This is the `main` thread
fn main() {

    // This is our data to process.
    // We will calculate the sum of all digits via a threaded  map-reduce algorithm.
    // Each whitespace separated chunk will be handled in a different thread.
    //
    // TODO: see what happens to the output if you insert spaces!
    let data = &quot;86967897737416471853297327050364959
11861322575564723963297542624962850
70856234701860851907960690014725639
38397966707106094172783238747669219
52380795257888236525459303330302837
58495327135744041048897885734297812
69920216438980873548808413720956532
16278424637452589860345374828574668&quot;;

    // Make a vector to hold the child-threads which we will spawn.
    let mut children = vec![];

    /*************************************************************************
     * &quot;Map&quot; phase
     *
     * Divide our data into segments, and apply initial processing
     ************************************************************************/

    // split our data into segments for individual calculation
    // each chunk will be a reference (&amp;str) into the actual data
    let chunked_data = data.split_whitespace();

    // Iterate over the data segments.
    // .enumerate() adds the current loop index to whatever is iterated
    // the resulting tuple &quot;(index, element)&quot; is then immediately
    // &quot;destructured&quot; into two variables, &quot;i&quot; and &quot;data_segment&quot; with a
    // &quot;destructuring assignment&quot;
    for (i, data_segment) in chunked_data.enumerate() {
        println!(&quot;data segment {} is \&quot;{}\&quot;&quot;, i, data_segment);

        // Process each data segment in a separate thread
        //
        // spawn() returns a handle to the new thread,
        // which we MUST keep to access the returned value
        //
        // 'move || -&gt; u32' is syntax for a closure that:
        // * takes no arguments ('||')
        // * takes ownership of its captured variables ('move') and
        // * returns an unsigned 32-bit integer ('-&gt; u32')
        //
        // Rust is smart enough to infer the '-&gt; u32' from 
        // the closure itself so we could have left that out.
        //
        // TODO: try removing the 'move' and see what happens
        children.push(thread::spawn(move || -&gt; u32 {
            // Calculate the intermediate sum of this segment:
            let result = data_segment
                        // iterate over the characters of our segment..
                        .chars()
                        // .. convert text-characters to their number value..
                        .map(|c| c.to_digit(10).expect(&quot;should be a digit&quot;))
                        // .. and sum the resulting iterator of numbers
                        .sum();

            // println! locks stdout, so no text-interleaving occurs
            println!(&quot;processed segment {}, result={}&quot;, i, result);

            // &quot;return&quot; not needed, because Rust is an &quot;expression language&quot;, the
            // last evaluated expression in each block is automatically its value.
            result

        }));
    }


    /*************************************************************************
     * &quot;Reduce&quot; phase
     *
     * Collect our intermediate results, and combine them into a final result
     ************************************************************************/

    // collect each thread's intermediate results into a new Vec
    let mut intermediate_sums = vec![];
    for child in children {
        // collect each child thread's return-value
        let intermediate_sum = child.join().unwrap();
        intermediate_sums.push(intermediate_sum);
    }

    // combine all intermediate sums into a single final sum.
    //
    // we use the &quot;turbofish&quot; ::&lt;&gt; to provide sum() with a type hint.
    //
    // TODO: try without the turbofish, by instead explicitly 
    // specifying the type of intermediate_sums
    let final_result = intermediate_sums.iter().sum::&lt;u32&gt;();

    println!(&quot;Final sum result: {}&quot;, final_result);
}


</code></pre></pre>
<a class="header" href="print.html#assignments" id="assignments"><h3>Assignments</h3></a>
<p>It is not wise to let our number of threads depend on user inputted data.
What if the user decides to insert a lot of spaces? Do we <em>really</em> want to spawn 2,000 threads?
Modify the program so that the data is always chunked into a limited number of chunks,
defined by a static constant at the beginning of the program.</p>
<a class="header" href="print.html#see-also-64" id="see-also-64"><h3>See also:</h3></a>
<ul>
<li><a href="/std_misc/threads.html">Threads</a></li>
<li><a href="/std/vec.html">vectors</a> and <a href="/trait/iter.html">iterators</a></li>
<li><a href="/fn/closures.html">closures</a>, <a href="/scope/move.html">move</a> semantics and <a href="https://doc.rust-lang.org/book/closures.html#move-closures"><code>move</code> closures</a></li>
<li><a href="https://doc.rust-lang.org/book/patterns.html#destructuring">destructuring</a> assignments</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect">turbofish notation</a> to help type inference</li>
<li><a href="/error/option_unwrap.html">unwrap vs. expect</a></li>
<li><a href="https://doc.rust-lang.org/book/loops.html#enumerate">enumerate</a></li>
</ul>
<a class="header" href="print.html#channels" id="channels"><h1>Channels</h1></a>
<p>Rust provides asynchronous <code>channels</code> for communication between threads. Channels
allow a unidirectional flow of information between two end-points: the
<code>Sender</code> and the <code>Receiver</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::sync::mpsc::{Sender, Receiver};
use std::sync::mpsc;
use std::thread;

static NTHREADS: i32 = 3;

fn main() {
    // Channels have two endpoints: the `Sender&lt;T&gt;` and the `Receiver&lt;T&gt;`,
    // where `T` is the type of the message to be transferred
    // (type annotation is superfluous)
    let (tx, rx): (Sender&lt;i32&gt;, Receiver&lt;i32&gt;) = mpsc::channel();

    for id in 0..NTHREADS {
        // The sender endpoint can be copied
        let thread_tx = tx.clone();

        // Each thread will send its id via the channel
        thread::spawn(move || {
            // The thread takes ownership over `thread_tx`
            // Each thread queues a message in the channel
            thread_tx.send(id).unwrap();

            // Sending is a non-blocking operation, the thread will continue
            // immediately after sending its message
            println!(&quot;thread {} finished&quot;, id);
        });
    }

    // Here, all the messages are collected
    let mut ids = Vec::with_capacity(NTHREADS as usize);
    for _ in 0..NTHREADS {
        // The `recv` method picks a message from the channel
        // `recv` will block the current thread if there are no messages available
        ids.push(rx.recv());
    }

    // Show the order in which the messages were sent
    println!(&quot;{:?}&quot;, ids);
}
</code></pre></pre>
<a class="header" href="print.html#path" id="path"><h1>Path</h1></a>
<p>The <code>Path</code> struct represents file paths in the underlying filesystem. There are
two flavors of <code>Path</code>: <code>posix::Path</code>, for UNIX-like systems, and
<code>windows::Path</code>, for Windows. The prelude exports the appropriate
platform-specific <code>Path</code> variant.</p>
<p>A <code>Path</code> can be created from an <code>OsStr</code>, and provides several methods to get
information from the file/directory the path points to.</p>
<p>Note that a <code>Path</code> is <em>not</em> internally represented as an UTF-8 string, but
instead is stored as a vector of bytes (<code>Vec&lt;u8&gt;</code>). Therefore, converting a
<code>Path</code> to a <code>&amp;str</code> is <em>not</em> free and may fail (an <code>Option</code> is returned).</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::path::Path;

fn main() {
    // Create a `Path` from an `&amp;'static str`
    let path = Path::new(&quot;.&quot;);

    // The `display` method returns a `Show`able structure
    let _display = path.display();

    // `join` merges a path with a byte container using the OS specific
    // separator, and returns the new path
    let new_path = path.join(&quot;a&quot;).join(&quot;b&quot;);

    // Convert the path into a string slice
    match new_path.to_str() {
        None =&gt; panic!(&quot;new path is not a valid UTF-8 sequence&quot;),
        Some(s) =&gt; println!(&quot;new path is {}&quot;, s),
    }
}

</code></pre></pre>
<p>Be sure to check at other <code>Path</code> methods (<code>posix::Path</code> or <code>windows::Path</code>) and
the <code>Metadata</code> struct.</p>
<a class="header" href="print.html#see-also-65" id="see-also-65"><h3>See also</h3></a>
<p><a href="https://doc.rust-lang.org/std/ffi/struct.OsStr.html">OsStr</a> and <a href="https://doc.rust-lang.org/std/fs/struct.Metadata.html">Metadata</a>.</p>
<a class="header" href="print.html#file-io" id="file-io"><h1>File I/O</h1></a>
<p>The <code>File</code> struct represents a file that has been opened (it wraps a file
descriptor), and gives read and/or write access to the underlying file.</p>
<p>Since many things can go wrong when doing file I/O, all the <code>File</code> methods
return the <code>io::Result&lt;T&gt;</code> type, which is an alias for <code>Result&lt;T, io::Error&gt;</code>.</p>
<p>This makes the failure of all I/O operations <em>explicit</em>. Thanks to this, the
programmer can see all the failure paths, and is encouraged to handle them in
a proactive manner.</p>
<a class="header" href="print.html#open" id="open"><h1><code>open</code></h1></a>
<p>The <code>open</code> static method can be used to open a file in read-only mode.</p>
<p>A <code>File</code> owns a resource, the file descriptor and takes care of closing the
file when it is <code>drop</code>ed.</p>
<pre><code class="language-rust editable ignore">use std::error::Error;
use std::fs::File;
use std::io::prelude::*;
use std::path::Path;

fn main() {
    // Create a path to the desired file
    let path = Path::new(&quot;hello.txt&quot;);
    let display = path.display();

    // Open the path in read-only mode, returns `io::Result&lt;File&gt;`
    let mut file = match File::open(&amp;path) {
        // The `description` method of `io::Error` returns a string that
        // describes the error
        Err(why) =&gt; panic!(&quot;couldn't open {}: {}&quot;, display,
                                                   why.description()),
        Ok(file) =&gt; file,
    };

    // Read the file contents into a string, returns `io::Result&lt;usize&gt;`
    let mut s = String::new();
    match file.read_to_string(&amp;mut s) {
        Err(why) =&gt; panic!(&quot;couldn't read {}: {}&quot;, display,
                                                   why.description()),
        Ok(_) =&gt; print!(&quot;{} contains:\n{}&quot;, display, s),
    }

    // `file` goes out of scope, and the &quot;hello.txt&quot; file gets closed
}

</code></pre>
<p>Here's the expected successful output:</p>
<pre><code class="language-bash">$ echo &quot;Hello World!&quot; &gt; hello.txt
$ rustc open.rs &amp;&amp; ./open
hello.txt contains:
Hello World!
</code></pre>
<p>(You are encouraged to test the previous example under different failure
conditions: <code>hello.txt</code> doesn't exist, or <code>hello.txt</code> is not readable,
etc.)</p>
<a class="header" href="print.html#create" id="create"><h1><code>create</code></h1></a>
<p>The <code>create</code> static method opens a file in write-only mode. If the file
already existed, the old content is destroyed. Otherwise, a new file is
created.</p>
<pre><code class="language-rust ignore">static LOREM_IPSUM: &amp;'static str =
&quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
&quot;;

use std::error::Error;
use std::io::prelude::*;
use std::fs::File;
use std::path::Path;

fn main() {
    let path = Path::new(&quot;out/lorem_ipsum.txt&quot;);
    let display = path.display();

    // Open a file in write-only mode, returns `io::Result&lt;File&gt;`
    let mut file = match File::create(&amp;path) {
        Err(why) =&gt; panic!(&quot;couldn't create {}: {}&quot;,
                           display,
                           why.description()),
        Ok(file) =&gt; file,
    };

    // Write the `LOREM_IPSUM` string to `file`, returns `io::Result&lt;()&gt;`
    match file.write_all(LOREM_IPSUM.as_bytes()) {
        Err(why) =&gt; {
            panic!(&quot;couldn't write to {}: {}&quot;, display,
                                               why.description())
        },
        Ok(_) =&gt; println!(&quot;successfully wrote to {}&quot;, display),
    }
}
</code></pre>
<p>Here's the expected successful output:</p>
<pre><code class="language-bash">$ mkdir out
$ rustc create.rs &amp;&amp; ./create
successfully wrote to out/lorem_ipsum.txt
$ cat out/lorem_ipsum.txt
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
</code></pre>
<p>(As in the previous example, you are encouraged to test this example under
failure conditions.)</p>
<p>There is also a more generic <code>open_mode</code> method that can open files in other
modes like: read+write, append, etc.</p>
<a class="header" href="print.html#child-processes" id="child-processes"><h1>Child processes</h1></a>
<p>The <code>process::Output</code> struct represents the output of a finished child process,
and the <code>process::Command</code> struct is a process builder.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::process::Command;

fn main() {
    let output = Command::new(&quot;rustc&quot;)
        .arg(&quot;--version&quot;)
        .output().unwrap_or_else(|e| {
            panic!(&quot;failed to execute process: {}&quot;, e)
    });

    if output.status.success() {
        let s = String::from_utf8_lossy(&amp;output.stdout);

        print!(&quot;rustc succeeded and stdout was:\n{}&quot;, s);
    } else {
        let s = String::from_utf8_lossy(&amp;output.stderr);

        print!(&quot;rustc failed and stderr was:\n{}&quot;, s);
    }
}
</code></pre></pre>
<p>(You are encouraged to try the previous example with an incorrect flag passed
to <code>rustc</code>)</p>
<a class="header" href="print.html#pipes" id="pipes"><h1>Pipes</h1></a>
<p>The <code>std::Child</code> struct represents a running child process, and exposes the
<code>stdin</code>, <code>stdout</code> and <code>stderr</code> handles for interaction with the underlying
process via pipes.</p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::io::prelude::*;
use std::process::{Command, Stdio};

static PANGRAM: &amp;'static str =
&quot;the quick brown fox jumped over the lazy dog\n&quot;;

fn main() {
    // Spawn the `wc` command
    let process = match Command::new(&quot;wc&quot;)
                                .stdin(Stdio::piped())
                                .stdout(Stdio::piped())
                                .spawn() {
        Err(why) =&gt; panic!(&quot;couldn't spawn wc: {}&quot;, why.description()),
        Ok(process) =&gt; process,
    };

    // Write a string to the `stdin` of `wc`.
    //
    // `stdin` has type `Option&lt;ChildStdin&gt;`, but since we know this instance
    // must have one, we can directly `unwrap` it.
    match process.stdin.unwrap().write_all(PANGRAM.as_bytes()) {
        Err(why) =&gt; panic!(&quot;couldn't write to wc stdin: {}&quot;,
                           why.description()),
        Ok(_) =&gt; println!(&quot;sent pangram to wc&quot;),
    }

    // Because `stdin` does not live after the above calls, it is `drop`ed,
    // and the pipe is closed.
    //
    // This is very important, otherwise `wc` wouldn't start processing the
    // input we just sent.

    // The `stdout` field also has type `Option&lt;ChildStdout&gt;` so must be unwrapped.
    let mut s = String::new();
    match process.stdout.unwrap().read_to_string(&amp;mut s) {
        Err(why) =&gt; panic!(&quot;couldn't read wc stdout: {}&quot;,
                           why.description()),
        Ok(_) =&gt; print!(&quot;wc responded with:\n{}&quot;, s),
    }
}
</code></pre>
<a class="header" href="print.html#wait" id="wait"><h1>Wait</h1></a>
<p>If you'd like to wait for a <code>process::Child</code> to finish, you must call
<code>Child::wait</code>, which will return a <code>process::ExitStatus</code>.</p>
<pre><code class="language-rust ignore">use std::process::Command;

fn main() {
    let mut child = Command::new(&quot;sleep&quot;).arg(&quot;5&quot;).spawn().unwrap();
    let _result = child.wait().unwrap();

    println!(&quot;reached end of main&quot;);
}
</code></pre>
<pre><code class="language-bash">$ rustc wait.rs &amp;&amp; ./wait
reached end of main
# `wait` keeps running for 5 seconds
# `sleep 5` command ends, and then our `wait` program finishes
</code></pre>
<a class="header" href="print.html#filesystem-operations" id="filesystem-operations"><h1>Filesystem Operations</h1></a>
<p>The <code>std::io::fs</code> module contains several functions that deal with the
filesystem.</p>
<pre><code class="language-rust ignore">use std::fs;
use std::fs::{File, OpenOptions};
use std::io;
use std::io::prelude::*;
use std::os::unix;
use std::path::Path;

// A simple implementation of `% cat path`
fn cat(path: &amp;Path) -&gt; io::Result&lt;String&gt; {
    let mut f = File::open(path)?;
    let mut s = String::new();
    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}

// A simple implementation of `% echo s &gt; path`
fn echo(s: &amp;str, path: &amp;Path) -&gt; io::Result&lt;()&gt; {
    let mut f = File::create(path)?;

    f.write_all(s.as_bytes())
}

// A simple implementation of `% touch path` (ignores existing files)
fn touch(path: &amp;Path) -&gt; io::Result&lt;()&gt; {
    match OpenOptions::new().create(true).write(true).open(path) {
        Ok(_) =&gt; Ok(()),
        Err(e) =&gt; Err(e),
    }
}

fn main() {
    println!(&quot;`mkdir a`&quot;);
    // Create a directory, returns `io::Result&lt;()&gt;`
    match fs::create_dir(&quot;a&quot;) {
        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),
        Ok(_) =&gt; {},
    }

    println!(&quot;`echo hello &gt; a/b.txt`&quot;);
    // The previous match can be simplified using the `unwrap_or_else` method
    echo(&quot;hello&quot;, &amp;Path::new(&quot;a/b.txt&quot;)).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`mkdir -p a/c/d`&quot;);
    // Recursively create a directory, returns `io::Result&lt;()&gt;`
    fs::create_dir_all(&quot;a/c/d&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`touch a/c/e.txt`&quot;);
    touch(&amp;Path::new(&quot;a/c/e.txt&quot;)).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`ln -s ../b.txt a/c/b.txt`&quot;);
    // Create a symbolic link, returns `io::Result&lt;()&gt;`
    if cfg!(target_family = &quot;unix&quot;) {
        unix::fs::symlink(&quot;../b.txt&quot;, &quot;a/c/b.txt&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
        });
    }

    println!(&quot;`cat a/c/b.txt`&quot;);
    match cat(&amp;Path::new(&quot;a/c/b.txt&quot;)) {
        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),
        Ok(s) =&gt; println!(&quot;&gt; {}&quot;, s),
    }

    println!(&quot;`ls a`&quot;);
    // Read the contents of a directory, returns `io::Result&lt;Vec&lt;Path&gt;&gt;`
    match fs::read_dir(&quot;a&quot;) {
        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),
        Ok(paths) =&gt; for path in paths {
            println!(&quot;&gt; {:?}&quot;, path.unwrap().path());
        },
    }

    println!(&quot;`rm a/c/e.txt`&quot;);
    // Remove a file, returns `io::Result&lt;()&gt;`
    fs::remove_file(&quot;a/c/e.txt&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`rmdir a/c/d`&quot;);
    // Remove an empty directory, returns `io::Result&lt;()&gt;`
    fs::remove_dir(&quot;a/c/d&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });
}

</code></pre>
<p>Here's the expected successful output:</p>
<pre><code class="language-bash">$ rustc fs.rs &amp;&amp; ./fs
`mkdir a`
`echo hello &gt; a/b.txt`
`mkdir -p a/c/d`
`touch a/c/e.txt`
`ln -s ../b.txt a/c/b.txt`
`cat a/c/b.txt`
&gt; hello
`ls a`
&gt; &quot;a/b.txt&quot;
&gt; &quot;a/c&quot;
`rm a/c/e.txt`
`rmdir a/c/d`
</code></pre>
<p>And the final state of the <code>a</code> directory is:</p>
<pre><code class="language-text">$ tree a
a
|-- b.txt
`-- c
    `-- b.txt -&gt; ../b.txt

1 directory, 2 files
</code></pre>
<p>An alternative way to define the function <code>cat</code> is with <code>?</code> notation:</p>
<pre><code class="language-rust ignore">fn cat(path: &amp;Path) -&gt; io::Result&lt;String&gt; {
    let mut f = File::open(path)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
</code></pre>
<a class="header" href="print.html#see-also-66" id="see-also-66"><h3>See also:</h3></a>
<p><a href="/attribute/cfg.html"><code>cfg!</code></a></p>
<a class="header" href="print.html#program-arguments" id="program-arguments"><h1>Program arguments</h1></a>
<p>The command line arguments can be accessed using <code>std::env::args</code>, which
returns an iterator that yields a String for each argument:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    // The first argument is the path that was used to call the program.
    println!(&quot;My path is {}.&quot;, args[0]);

    // The rest of the arguments are the passed command line parameters.
    // Call the program like this:
    //   $ ./args arg1 arg2
    println!(&quot;I got {:?} arguments: {:?}.&quot;, args.len() - 1, &amp;args[1..]);
}
</code></pre></pre>
<pre><code class="language-bash">$ ./args 1 2 3
My path is ./args.
I got 3 arguments: [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].
</code></pre>
<a class="header" href="print.html#argument-parsing" id="argument-parsing"><h1>Argument parsing</h1></a>
<p>Matching can be used to parse simple arguments:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::env;

fn increase(number: i32) {
    println!(&quot;{}&quot;, number + 1);
}

fn decrease(number: i32) {
    println!(&quot;{}&quot;, number - 1);
}

fn help() {
    println!(&quot;usage:
match_args &lt;string&gt;
    Check whether given string is the answer.
match_args {{increase|decrease}} &lt;integer&gt;
    Increase or decrease given integer by one.&quot;);
}

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    match args.len() {
        // no arguments passed
        1 =&gt; {
            println!(&quot;My name is 'match_args'. Try passing some arguments!&quot;);
        },
        // one argument passed
        2 =&gt; {
            match args[1].parse() {
                Ok(42) =&gt; println!(&quot;This is the answer!&quot;),
                _ =&gt; println!(&quot;This is not the answer.&quot;),
            }
        },
        // one command and one argument passed
        3 =&gt; {
            let cmd = &amp;args[1];
            let num = &amp;args[2];
            // parse the number
            let number: i32 = match num.parse() {
                Ok(n) =&gt; {
                    n
                },
                Err(_) =&gt; {
                    println!(&quot;error: second argument not an integer&quot;);
                    help();
                    return;
                },
            };
            // parse the command
            match &amp;cmd[..] {
                &quot;increase&quot; =&gt; increase(number),
                &quot;decrease&quot; =&gt; decrease(number),
                _ =&gt; {
                    println!(&quot;error: invalid command&quot;);
                    help();
                },
            }
        },
        // all the other cases
        _ =&gt; {
            // show a help message
            help();
        }
    }
}
</code></pre></pre>
<pre><code class="language-bash">$ ./match_args Rust
This is not the answer.
$ ./match_args 42
This is the answer!
$ ./match_args do something
error: second argument not an integer
usage:
match_args &lt;string&gt;
    Check whether given string is the answer.
match_args {increase|decrease} &lt;integer&gt;
    Increase or decrease given integer by one.
$ ./match_args do 42
error: invalid command
usage:
match_args &lt;string&gt;
    Check whether given string is the answer.
match_args {increase|decrease} &lt;integer&gt;
    Increase or decrease given integer by one.
$ ./match_args increase 42
43
</code></pre>
<a class="header" href="print.html#foreign-function-interface" id="foreign-function-interface"><h1>Foreign Function Interface</h1></a>
<p>Rust provides a Foreign Function Interface (FFI) to C libraries. Foreign
functions must be declared inside an <code>extern</code> block annotated with a <code>#[link]</code>
attribute containing the name of the foreign library.</p>
<pre><code class="language-rust ignore">use std::fmt;

// this extern block links to the libm library
#[link(name = &quot;m&quot;)]
extern {
    // this is a foreign function
    // that computes the square root of a single precision complex number
    fn csqrtf(z: Complex) -&gt; Complex;
}

fn main() {
    // z = -1 + 0i
    let z = Complex { re: -1., im: 0. };

    // calling a foreign function is an unsafe operation
    let z_sqrt = unsafe {
        csqrtf(z)
    };

    println!(&quot;the square root of {:?} is {:?}&quot;, z, z_sqrt);
}

// Minimal implementation of single precision complex numbers
#[repr(C)]
#[derive(Clone, Copy)]
struct Complex {
    re: f32,
    im: f32,
}

impl fmt::Debug for Complex {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        if self.im &lt; 0. {
            write!(f, &quot;{}-{}i&quot;, self.re, -self.im)
        } else {
            write!(f, &quot;{}+{}i&quot;, self.re, self.im)
        }
    }
}
</code></pre>
<p>Since calling foreign functions is considered unsafe, it's common to write safe
wrappers around them.</p>
<pre><code class="language-rust ignore">use std::fmt;

#[link(name = &quot;m&quot;)]
extern {
    fn ccosf(z: Complex) -&gt; Complex;
}

// safe wrapper
fn cos(z: Complex) -&gt; Complex {
    unsafe { ccosf(z) }
}

fn main() {
    // z = 0 + 1i
    let z = Complex { re: 0., im: 1. };

    println!(&quot;cos({:?}) = {:?}&quot;, z, cos(z));
}

// Minimal implementation of single precision complex numbers
#[repr(C)]
#[derive(Clone, Copy)]
struct Complex {
    re: f32,
    im: f32,
}

impl fmt::Debug for Complex {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        if self.im &lt; 0. {
            write!(f, &quot;{}-{}i&quot;, self.re, -self.im)
        } else {
            write!(f, &quot;{}+{}i&quot;, self.re, self.im)
        }
    }
}
</code></pre>
<a class="header" href="print.html#meta" id="meta"><h1>Meta</h1></a>
<p>Some topics aren't exactly relevant to how you program but provide you
tooling or infrastructure support which just makes things better for
everyone. These topics include:</p>
<ul>
<li>Documentation: Generate library documentation for users via the included
<code>rustdoc</code>.</li>
<li>Testing: Create testsuites for libraries to give confidence that your
library does exactly what it's supposed to.</li>
<li>Benchmarking: Create benchmarks for functionality to be confident that
they run quickly.</li>
</ul>
<a class="header" href="print.html#documentation" id="documentation"><h1>Documentation</h1></a>
<p>Doc comments are very useful for big projects that require documentation. When
running <a href="https://doc.rust-lang.org/book/documentation.html">Rustdoc</a>, these are the comments that get compiled into
documentation. They are denoted by a <code>///</code>, and support <a href="https://en.wikipedia.org/wiki/Markdown">Markdown</a>.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">#![crate_name = &quot;doc&quot;]

/// A human being is represented here
pub struct Person {
    /// A person must have a name, no matter how much Juliet may hate it
    name: String,
}

impl Person {
    /// Returns a person with the name given them
    ///
    /// # Arguments
    ///
    /// * `name` - A string slice that holds the name of the person
    ///
    /// # Example
    ///
    /// ```
    /// // You can have rust code between fences inside the comments
    /// // If you pass --test to Rustdoc, it will even test it for you!
    /// use doc::Person;
    /// let person = Person::new(&quot;name&quot;);
    /// ```
    pub fn new(name: &amp;str) -&gt; Person {
        Person {
            name: name.to_string(),
        }
    }

    /// Gives a friendly hello!
    ///
    /// Says &quot;Hello, [name]&quot; to the `Person` it is called on.
    pub fn hello(&amp; self) {
        println!(&quot;Hello, {}!&quot;, self.name);
    }
}

fn main() {
    let john = Person::new(&quot;John&quot;);

    john.hello();
}
</code></pre></pre>
<p>To run the tests, first build the code as a library, then tell rustdoc where
to find the library so it can link it into each doctest program:</p>
<pre><code class="language-bash">$ rustc doc.rs --crate-type lib
$ rustdoc --test --extern doc=&quot;libdoc.rlib&quot; doc.rs
</code></pre>
<p>(When you run <code>cargo test</code> on a library crate, Cargo will automatically
generate and run the correct rustc and rustdoc commands.)</p>
<a class="header" href="print.html#testing" id="testing"><h1>Testing</h1></a>
<p>Functions can be tested by using these <a href="/attribute.html">attributes</a>:</p>
<ul>
<li><code>#[test]</code> marks a function as a unit test. The function must take zero
parameters and return nothing.</li>
<li><code>#[should_panic]</code> marks a function as a panicking test.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">// Conditionally compile `main` only when the test-suite is *not* being run.
#[cfg(not(test))]
fn main() {
    println!(&quot;If you see this, the tests were not compiled nor ran!&quot;);
}

// Conditionally compile the module `test` only when the test-suite is run.
#[cfg(test)]
mod test {
    // A helper function `distance_test` will need.
    fn distance(a: (f32, f32), b: (f32, f32)) -&gt; f32 {
        (
            (b.0 - a.0).powi(2) +
            (b.1 - a.1).powi(2)
        ).sqrt()
    }

    #[test]
    fn distance_test() {
        assert!(distance((0f32, 0f32), (1f32, 1f32)) == (2f32).sqrt());
    }
    
    #[test]
    #[should_panic]
    fn failing_test() {
        assert!(1i32 == 2i32);
    }
}
</code></pre></pre>
<p>Tests can be run with <code>cargo test</code> or <code>rustc --test</code>.</p>
<pre><code class="language-bash">$ rustc --test unit_test.rs
$ ./unit_test 

running 2 tests
test test::distance_test ... ok
test test::failing_test ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>If <code>--test</code> were not included, then this would happen</p>
<pre><code class="language-bash">$ rustc unit_test.rs
$ ./unit_test
If you see this, the tests were not compiled nor ran!
</code></pre>
<a class="header" href="print.html#see-also-67" id="see-also-67"><h3>See also:</h3></a>
<p><a href="/attribute.html">attributes</a>, <a href="/attribute/cfg.html">conditional compilation</a>, and <a href="/mod.html"><code>mod</code></a>.</p>
<a class="header" href="print.html#unsafe-operations" id="unsafe-operations"><h1>Unsafe Operations</h1></a>
<p>As an introduction to this section, to borrow from <a href="https://doc.rust-lang.org/book/unsafe.html">the official docs</a>, &quot;one should try to minimize the
amount of unsafe code in a code base.&quot; With that in mind, let's get started!
Unsafe blocks in Rust are used to bypass protections put in place by the
compiler; specifically, there are four primary things that unsafe blocks are
used for:</p>
<ul>
<li>dereferencing raw pointers</li>
<li>calling a function over FFI (but this is covered in <a href="/std_misc/ffi.html">a previous
chapter</a> of the book)</li>
<li>changing types through <code>std::mem::transmute</code></li>
<li>inline assembly</li>
</ul>
<a class="header" href="print.html#raw-pointers" id="raw-pointers"><h3>Raw Pointers</h3></a>
<p>Raw pointers <code>*</code> and references <code>&amp;T</code> function similarly, but references are
always safe because they are guaranteed to point to valid data due to the
borrow checker. Dereferencing a raw pointer can only be done through an unsafe
block.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let raw_p: *const u32 = &amp;10;

    unsafe {
        assert!(*raw_p == 10);
    }
}
</code></pre></pre>
<a class="header" href="print.html#transmute" id="transmute"><h3>Transmute</h3></a>
<p>Allows simple conversion from one type to another, however both types must have
the same size and alignment:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let u: &amp;[u8] = &amp;[49, 50, 51];

    unsafe {
        assert!(u == std::mem::transmute::&lt;&amp;str, &amp;[u8]&gt;(&quot;123&quot;));
    }
}
</code></pre></pre>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
             // START - Rust-By-Example customization
            $("#edit-button").click(function(){
                 var editWindow = window.open("https://github.com/rust-lang/rust-by-example/edit/master/src/print.md");
             });
            // END - Rust-By-Example customization
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script>
            $(document).ready(function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>